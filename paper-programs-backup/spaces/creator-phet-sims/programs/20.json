{
  "number": 20,
  "originalCode": "// Load Simulation\n// Keywords: \n// Description: \n\nimportScripts('paper.js');\n\n(async () => {\n\n  const onProgramAdded = ( paperNumber, scratchpad, sharedData ) => {\n    // Create the simulation simFrame.\nconst simFrame = document.createElement('iframe');\nsimFrame.src = 'https://phet-dev.colorado.edu/html/quadrilateral/1.0.0-paperLandTest.3/phet/quadrilateral_en_phet.html?brand=phet&ea&deviceConnection&postMessageOnLoad&voicingInitiallyEnabled'\n//simFrame.src = 'http://localhost:8080/quadrilateral/quadrilateral_en.html?brand=phet&ea&debugger&deviceConnection&postMessageOnLoad&voicingInitiallyEnabled'\n\n// Styling to make the iframe go on top of the interactive display.\n// HACK ALERT!! If this id changes, there will be problems.\nconst displayElement = document.getElementById('scenery-display');\n\n// Remove the iframe from the flow of the document and adjust its size\nsimFrame.style.position = 'absolute';\nsimFrame.style.width = `${displayElement.offsetWidth}px`;\nsimFrame.style.height = `${displayElement.offsetHeight}px`;\nsimFrame.style.top = `${displayElement.offsetTop}px`;\nsimFrame.style.left = `${displayElement.offsetLeft}px`;\n\n// Add the iframe as a sibling of the display element.\ndisplayElement.parentNode.insertBefore(simFrame, displayElement.nextSibling);\n\n// Save a reference to the iframe so that it can be removed onProgramRemoved.\nscratchpad.simFrame = simFrame;\n\n// A message that will be sent from paper playground into the simulation, attempting to calibrate.\nconst loadMessage = JSON.stringify({\n    type: 'quadrilateralCalibration',\n    width: sharedData.displaySize.width,\n    height: sharedData.displaySize.height\n});\n\nconst iframeWindow = simFrame.contentWindow;\n\n// Try sending the message right away just in case (but we probably need to wait for the sim to load).\niframeWindow.postMessage(loadMessage, '*');\n\n// The sim sends a message when loading is complete (postMessageOnLoad query param). When loading is complete,\n// send a message back attempting to calibrate to map paper playground coordinates to simulation coordinates.\nscratchpad.windowMessageListener = event => {\n    const data = JSON.parse(event.data);\n\n    if (data.type === 'load') {\n        iframeWindow.postMessage(loadMessage, '*');\n    }\n};\nwindow.addEventListener('message', scratchpad.windowMessageListener);\n\n// Forward 4 positions in normalized paper-land coordinates to the simulation.\nconst updateFromPaperLandPositions = (vertexA, vertexB, vertexC, vertexD) => {\n\n    // Convert each point from normalized paper-land coordinates to\n    // display coordinates - working in display coordinates is better\n    // because no matter what the projection transform is, paper positions\n    // will more likely match quadrilateral positions.\n    const displayWidth = sharedData.displaySize.width;\n    const displayHeight = sharedData.displaySize.height;\n    const displayPointA = phet.paperLand.utils.paperToDisplayCoordinates( vertexA, displayWidth, displayHeight );\n    const displayPointB = phet.paperLand.utils.paperToDisplayCoordinates( vertexB, displayWidth, displayHeight );\n    const displayPointC = phet.paperLand.utils.paperToDisplayCoordinates( vertexC, displayWidth, displayHeight );\n    const displayPointD = phet.paperLand.utils.paperToDisplayCoordinates( vertexD, displayWidth, displayHeight );\n\n    iframeWindow.postMessage(JSON.stringify({\n        type: 'quadrilateralControl',\n        vertexA: {\n            x: displayPointA.x,\n            y: displayPointA.y\n        },\n        vertexB: {\n            x: displayPointB.x,\n            y: displayPointB.y\n        },\n        vertexC: {\n            x: displayPointC.x,\n            y: displayPointC.y\n        },\n        vertexD: {\n            x: displayPointD.x,\n            y: displayPointD.y\n        },\n    }), '*');\n};\n\n// When all corner programs are detected, add a multilink that will update\n// simulation positions to match paper positions.\nscratchpad.vertexPositionMultilink = phet.paperLand.addModelPropertyMultilink(\n    ['vertexA', 'vertexB', 'vertexC', 'vertexD'],\n    (vertexA, vertexB, vertexC, vertexD) => {\n        updateFromPaperLandPositions( vertexA, vertexB, vertexC, vertexD );\n\n    }\n);\n\n// When the program representing all vertex positions is added,\n// forward those values to the simulation.\nscratchpad.combinedVertexPositionMultilink = phet.paperLand.addModelPropertyMultilink(\n    [ 'vertexACombined', 'vertexBCombined', 'vertexCCombined', 'vertexDCombined' ],\n    ( vertexA, vertexB, vertexC, vertexD ) => {\n        updateFromPaperLandPositions( vertexA, vertexB, vertexC, vertexD );\n    }\n);\n  };\n\n  const onProgramRemoved = ( paperNumber, scratchpad, sharedData ) => {\n    // Remove the simFrame from the body when the program is removed\nscratchpad.simFrame.remove();\ndelete scratchpad.simFrame;\n\n// Remove the multilink for the vertex positions on individual programs.\nphet.paperLand.removeModelPropertyMultilink(\n    [ 'vertexA', 'vertexB', 'vertexC', 'vertexD' ],\n    scratchpad.vertexPositionMultilink\n);\ndelete scratchpad.vertexPositionMultilink;\n\n// Remove the multilink for the vertex positions on the same program.\nphet.paperLand.removeModelPropertyMultilink(\n    [ 'vertexACombined', 'vertexBCombined', 'vertexCCombined', 'vertexDCombined' ],\n    scratchpad.combinedVertexPositionMultilink\n);\ndelete scratchpad.combinedVertexPositionMultilink;\n  };\n\n  const onProgramChangedPosition = ( paperNumber, points, scratchpad, sharedData ) => {\n    \n  };\n  \n  const onProgramMarkersAdded = ( paperNumber, points, scratchpad, sharedData, markers ) => {\n    \n  };\n  \n  const onProgramMarkersRemoved = ( paperNumber, points, scratchpad, sharedData, markers ) => {\n    \n  };\n  \n  const onProgramMarkersChangedPosition = ( paperNumber, points, scratchpad, sharedData, markers ) => {\n    \n  };\n  \n  const onProgramAdjacent = ( paperNumber, otherPaperNumber, direction, scratchpad, sharedData ) => {\n    \n  };\n  \n  const onProgramSeparated = ( paperNumber, otherPaperNumber, direction, scratchpad, sharedData ) => {\n    \n  };\n\n  await paper.set( 'data', {\n    paperPlaygroundData: {\n      updateTime: Date.now(),\n      eventHandlers: {\n        onProgramAdded: onProgramAdded.toString(),\n        onProgramRemoved: onProgramRemoved.toString(),\n        onProgramChangedPosition: onProgramChangedPosition.toString(),\n        onProgramMarkersAdded: onProgramMarkersAdded.toString(),\n        onProgramMarkersRemoved: onProgramMarkersRemoved.toString(),\n        onProgramMarkersChangedPosition: onProgramMarkersChangedPosition.toString(),\n        onProgramAdjacent: onProgramAdjacent.toString(),\n        onProgramSeparated: onProgramSeparated.toString(),\n      },\n      customWhiskerLengths: {\n        top: 0.2,\n        right: 0.2,\n        bottom: 0.2,\n        left: 0.2\n      }\n    }\n  } );\n  \n  // PROJECTOR CODE //\n  // Get a canvas object for this paper to draw something to the Projector.\n  const canvas = await paper.get('canvas');\n\n  // Draw the name of the program to the projector\n  const ctx = canvas.getContext('2d');\n  ctx.font = '20px sans-serif';\n  ctx.textAlign = 'center';\n  ctx.fillStyle = 'rgb(255,0,0)';\n  ctx.fillText('', canvas.width / 2, canvas.height / 2 - 10);\n  ctx.fillStyle = 'rgb(0,255,0)';\n  ctx.font = '10px sans-serif';\n  ctx.fillText('Load Simulation', canvas.width / 2, canvas.height / 2 + 20);\n})();\n",
  "currentCode": "// Load Simulation\n// Keywords: \n// Description: \n\nimportScripts('paper.js');\n\n(async () => {\n\n  const onProgramAdded = ( paperNumber, scratchpad, sharedData ) => {\n    // Create the simulation simFrame.\nconst simFrame = document.createElement('iframe');\nsimFrame.src = 'https://phet-dev.colorado.edu/html/quadrilateral/1.0.0-paperLandTest.3/phet/quadrilateral_en_phet.html?brand=phet&ea&deviceConnection&postMessageOnLoad&voicingInitiallyEnabled'\n//simFrame.src = 'http://localhost:8080/quadrilateral/quadrilateral_en.html?brand=phet&ea&debugger&deviceConnection&postMessageOnLoad&voicingInitiallyEnabled'\n\n// Styling to make the iframe go on top of the interactive display.\n// HACK ALERT!! If this id changes, there will be problems.\nconst displayElement = document.getElementById('scenery-display');\n\n// Remove the iframe from the flow of the document and adjust its size\nsimFrame.style.position = 'absolute';\nsimFrame.style.width = `${displayElement.offsetWidth}px`;\nsimFrame.style.height = `${displayElement.offsetHeight}px`;\nsimFrame.style.top = `${displayElement.offsetTop}px`;\nsimFrame.style.left = `${displayElement.offsetLeft}px`;\n\n// Add the iframe as a sibling of the display element.\ndisplayElement.parentNode.insertBefore(simFrame, displayElement.nextSibling);\n\n// Save a reference to the iframe so that it can be removed onProgramRemoved.\nscratchpad.simFrame = simFrame;\n\n// A message that will be sent from paper playground into the simulation, attempting to calibrate.\nconst loadMessage = JSON.stringify({\n    type: 'quadrilateralCalibration',\n    width: sharedData.displaySize.width,\n    height: sharedData.displaySize.height\n});\n\nconst iframeWindow = simFrame.contentWindow;\n\n// Try sending the message right away just in case (but we probably need to wait for the sim to load).\niframeWindow.postMessage(loadMessage, '*');\n\n// The sim sends a message when loading is complete (postMessageOnLoad query param). When loading is complete,\n// send a message back attempting to calibrate to map paper playground coordinates to simulation coordinates.\nscratchpad.windowMessageListener = event => {\n    const data = JSON.parse(event.data);\n\n    if (data.type === 'load') {\n        iframeWindow.postMessage(loadMessage, '*');\n    }\n};\nwindow.addEventListener('message', scratchpad.windowMessageListener);\n\n// Forward 4 positions in normalized paper-land coordinates to the simulation.\nconst updateFromPaperLandPositions = (vertexA, vertexB, vertexC, vertexD) => {\n\n    // Convert each point from normalized paper-land coordinates to\n    // display coordinates - working in display coordinates is better\n    // because no matter what the projection transform is, paper positions\n    // will more likely match quadrilateral positions.\n    const displayWidth = sharedData.displaySize.width;\n    const displayHeight = sharedData.displaySize.height;\n    const displayPointA = phet.paperLand.utils.paperToDisplayCoordinates( vertexA, displayWidth, displayHeight );\n    const displayPointB = phet.paperLand.utils.paperToDisplayCoordinates( vertexB, displayWidth, displayHeight );\n    const displayPointC = phet.paperLand.utils.paperToDisplayCoordinates( vertexC, displayWidth, displayHeight );\n    const displayPointD = phet.paperLand.utils.paperToDisplayCoordinates( vertexD, displayWidth, displayHeight );\n\n    iframeWindow.postMessage(JSON.stringify({\n        type: 'quadrilateralControl',\n        vertexA: {\n            x: displayPointA.x,\n            y: displayPointA.y\n        },\n        vertexB: {\n            x: displayPointB.x,\n            y: displayPointB.y\n        },\n        vertexC: {\n            x: displayPointC.x,\n            y: displayPointC.y\n        },\n        vertexD: {\n            x: displayPointD.x,\n            y: displayPointD.y\n        },\n    }), '*');\n};\n\n// When all corner programs are detected, add a multilink that will update\n// simulation positions to match paper positions.\nscratchpad.vertexPositionMultilink = phet.paperLand.addModelPropertyMultilink(\n    ['vertexA', 'vertexB', 'vertexC', 'vertexD'],\n    (vertexA, vertexB, vertexC, vertexD) => {\n        updateFromPaperLandPositions( vertexA, vertexB, vertexC, vertexD );\n\n    }\n);\n\n// When the program representing all vertex positions is added,\n// forward those values to the simulation.\nscratchpad.combinedVertexPositionMultilink = phet.paperLand.addModelPropertyMultilink(\n    [ 'vertexACombined', 'vertexBCombined', 'vertexCCombined', 'vertexDCombined' ],\n    ( vertexA, vertexB, vertexC, vertexD ) => {\n        updateFromPaperLandPositions( vertexA, vertexB, vertexC, vertexD );\n    }\n);\n  };\n\n  const onProgramRemoved = ( paperNumber, scratchpad, sharedData ) => {\n    // Remove the simFrame from the body when the program is removed\nscratchpad.simFrame.remove();\ndelete scratchpad.simFrame;\n\n// Remove the multilink for the vertex positions on individual programs.\nphet.paperLand.removeModelPropertyMultilink(\n    [ 'vertexA', 'vertexB', 'vertexC', 'vertexD' ],\n    scratchpad.vertexPositionMultilink\n);\ndelete scratchpad.vertexPositionMultilink;\n\n// Remove the multilink for the vertex positions on the same program.\nphet.paperLand.removeModelPropertyMultilink(\n    [ 'vertexACombined', 'vertexBCombined', 'vertexCCombined', 'vertexDCombined' ],\n    scratchpad.combinedVertexPositionMultilink\n);\ndelete scratchpad.combinedVertexPositionMultilink;\n  };\n\n  const onProgramChangedPosition = ( paperNumber, points, scratchpad, sharedData ) => {\n    \n  };\n  \n  const onProgramMarkersAdded = ( paperNumber, points, scratchpad, sharedData, markers ) => {\n    \n  };\n  \n  const onProgramMarkersRemoved = ( paperNumber, points, scratchpad, sharedData, markers ) => {\n    \n  };\n  \n  const onProgramMarkersChangedPosition = ( paperNumber, points, scratchpad, sharedData, markers ) => {\n    \n  };\n  \n  const onProgramAdjacent = ( paperNumber, otherPaperNumber, direction, scratchpad, sharedData ) => {\n    \n  };\n  \n  const onProgramSeparated = ( paperNumber, otherPaperNumber, direction, scratchpad, sharedData ) => {\n    \n  };\n\n  await paper.set( 'data', {\n    paperPlaygroundData: {\n      updateTime: Date.now(),\n      eventHandlers: {\n        onProgramAdded: onProgramAdded.toString(),\n        onProgramRemoved: onProgramRemoved.toString(),\n        onProgramChangedPosition: onProgramChangedPosition.toString(),\n        onProgramMarkersAdded: onProgramMarkersAdded.toString(),\n        onProgramMarkersRemoved: onProgramMarkersRemoved.toString(),\n        onProgramMarkersChangedPosition: onProgramMarkersChangedPosition.toString(),\n        onProgramAdjacent: onProgramAdjacent.toString(),\n        onProgramSeparated: onProgramSeparated.toString(),\n      },\n      customWhiskerLengths: {\n        top: 0.2,\n        right: 0.2,\n        bottom: 0.2,\n        left: 0.2\n      }\n    }\n  } );\n  \n  // PROJECTOR CODE //\n  // Get a canvas object for this paper to draw something to the Projector.\n  const canvas = await paper.get('canvas');\n\n  // Draw the name of the program to the projector\n  const ctx = canvas.getContext('2d');\n  ctx.font = '20px sans-serif';\n  ctx.textAlign = 'center';\n  ctx.fillStyle = 'rgb(255,0,0)';\n  ctx.fillText('', canvas.width / 2, canvas.height / 2 - 10);\n  ctx.fillStyle = 'rgb(0,255,0)';\n  ctx.font = '10px sans-serif';\n  ctx.fillText('Load Simulation', canvas.width / 2, canvas.height / 2 + 20);\n})();\n",
  "printed": false,
  "editorInfo": {},
  "currentCodeUrl": "program.creator-phet-sims.20.js",
  "currentCodeHash": "",
  "debugUrl": "/api/spaces/creator-phet-sims/programs/20/debugInfo",
  "claimUrl": "/api/spaces/creator-phet-sims/programs/20/claim",
  "codeHasChanged": false,
  "debugInfo": "{\"logs\":[]}"
}