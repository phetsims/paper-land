{
  "number": 1,
  "originalCode": "// Game Logic\n// Keywords: \n// Description: The 'game logic'. Uses an animation component to play the song sequence and receive notes from the player.\n// \n// The song sequence is encoded in a string for convenience. Would be nice if the array component could work but it doesn't support this case. It\n// would be better if we had a catch-all component for any kind of JavaScript object for this kind of thing.\n\nimportScripts('paper.js');\n\n(async () => {\n\n  const onProgramAdded = ( paperNumber, scratchpad, sharedData ) => {\n    \n      const playersTurn = new phet.axon.BooleanProperty(false);\n      phet.paperLand.addModelComponent( 'playersTurn', playersTurn );\n    \n\n      const playerWon = new phet.axon.BooleanProperty(false);\n      phet.paperLand.addModelComponent( 'playerWon', playerWon );\n    \n\n      const songPlaybackIndex = new phet.axon.NumberProperty( 0, {\n        range: new phet.dot.Range( 0, 8 )\n      });\n      phet.paperLand.addModelComponent( 'songPlaybackIndex', songPlaybackIndex );\n    \n\n      const timeSinceComputerNote = new phet.axon.NumberProperty( 0, {\n        range: new phet.dot.Range( 0, 10 )\n      });\n      phet.paperLand.addModelComponent( 'timeSinceComputerNote', timeSinceComputerNote );\n    \n\n      const gameSequence = new phet.axon.StringProperty( 'a-b-c-d' );\n      phet.paperLand.addModelComponent( 'gameSequence', gameSequence );\n    \n\n      const playerPlaybackSequence = new phet.axon.StringProperty( '' );\n      phet.paperLand.addModelComponent( 'playerPlaybackSequence', playerPlaybackSequence );\n    \n\n      const sequenceLength = new phet.axon.NumberProperty( 4, {\n        range: new phet.dot.Range( 0, 10 )\n      });\n      phet.paperLand.addModelComponent( 'sequenceLength', sequenceLength );\n    \n\n      // Create the text and add it to the view - using RichText for nice markup support.\n      const gameStateTextText = new phet.scenery.RichText( '', { fill: 'white' } );\n      \n      sharedData.scene.addChild( gameStateTextText );\n      scratchpad.gameStateTextText = gameStateTextText;\n      \n      // Update the text when a dependency changes.\n      scratchpad.gameStateTextTextMultilinkId = phet.paperLand.addModelPropertyMultilink( [ 'simonATrigger', 'playersTurn', 'playerWon', 'simonBTrigger', 'simonCTrigger', 'simonDTrigger' ], ( simonATrigger, playersTurn, playerWon, simonBTrigger, simonCTrigger, simonDTrigger ) => {\n      \n        // the additional reference constants\n        \n      \n        // in a local scope, define the functions that the user can use to manipulate the text\n        \n      const unitBoundsToDisplayBounds = ( bounds ) => {\n        return phet.paperLand.utils.paperToBoardBounds( bounds, sharedData.displaySize.width, sharedData.displaySize.height );\n      };\n      \n      const unitPositionToDisplayPosition = ( position ) => {\n        return phet.paperLand.utils.paperToBoardCoordinates( position, sharedData.displaySize.width, sharedData.displaySize.height );\n      };\n    \n      const setCenterX = ( x ) => {\n        gameStateTextText.centerX = phet.paperLand.utils.paperToBoardX( x, sharedData.displaySize.width );\n      };\n      \n      const setCenterY = ( y ) => {\n        gameStateTextText.centerY = phet.paperLand.utils.paperToBoardY( y, sharedData.displaySize.height );\n      };\n      \n      const setLeft = ( left ) => {\n        gameStateTextText.left = phet.paperLand.utils.paperToBoardX( left, sharedData.displaySize.width );\n      };\n      \n      const setTop = ( top ) => {\n        gameStateTextText.top = phet.paperLand.utils.paperToBoardY( top, sharedData.displaySize.height );\n      };\n      \n      const setScale = ( scale ) => {\n        gameStateTextText.setScaleMagnitude( scale );\n      };\n      \n      const setOpacity = ( opacity ) => {\n        gameStateTextText.opacity = opacity;\n      };\n      \n      const setVisible = ( visible ) => {\n        gameStateTextText.visible = visible;\n      };\n      \n      const moveToFront = () => {\n        gameStateTextText.moveToFront();\n      };\n      \n      const moveToBack = () => {\n        gameStateTextText.moveToBack();\n      };\n      \n      const setRotation = ( rotation ) => {\n        gameStateTextText.rotation = rotation;\n      };\n\n      // Set the scale in X and Y and the       \n      const matchBounds = ( bounds, stretch ) => {\n      \n        // Find the scale to apply to the x and y dimensions so that the component bounds match the provided bounds\n        const gameStateTextTextViewBounds = phet.paperLand.utils.paperToBoardBounds(bounds, sharedData.displaySize.width, sharedData.displaySize.height);\n\n        // local bounds may be zero as things load\n        // const aspectRatio = ( gameStateTextText.localBounds.width || 1 ) / ( gameStateTextText.localBounds.height || 1 );\n\n        const scaleX = gameStateTextTextViewBounds.width / ( gameStateTextText.localBounds.width || 1 );\n        const scaleY = gameStateTextTextViewBounds.height / ( gameStateTextText.localBounds.height || 1 );\n\n        if ( stretch ) {\n          gameStateTextText.setScaleMagnitude(scaleX, scaleY);\n        }\n        else {\n        \n          // Scale by the minimum of the x and y scale factors, preserving the aspect ratio\n          gameStateTextText.setScaleMagnitude( Math.min( scaleX, scaleY ) );\n        }        \n\n        // Now put the component in the center of the bounds\n        gameStateTextText.center = gameStateTextTextViewBounds.center;\n      };\n      \n\n        const setString = ( string ) => {\n          gameStateTextText.string = string;\n        };\n        \n        const setFontSize = ( size ) => {\n        \n          // RichText has no setter for size, so we need to create a new font. Use\n          // state from the old font to maintain the family.\n          const currentFont = gameStateTextText.font;\n          const newFont = new phet.scenery.Font( { size: size, family: currentFont.family } );\n          gameStateTextText.font = newFont;\n        };\n\n        const setTextColor = ( color ) => {\n          gameStateTextText.fill = color;\n        };\n\n        const setFontFamily = ( family ) => {\n        \n          // RichText has no setter for fontFamily, so we need to create a new font. Use\n          // state from the old font to maintain the size.\n          const currentFont = gameStateTextText.font;\n          const newFont = new phet.scenery.Font( { size: currentFont.size, family: family } );\n          gameStateTextText.font = newFont;\n        };\n      \n\n        // the function that the user wrote to update the text      \n        if ( playerWon ) {\n    setString( 'You won!' );\n}\nelse if ( playersTurn ) {\n    setString( 'Your turn!' );\n}\nelse if ( simonATrigger ) {\n    setString( 'Up!' );\n}\nelse if ( simonBTrigger ) {\n    setString( 'Left!' );\n}\nelse if ( simonCTrigger ) {\n    setString( 'Right!' );\n}\nelse if ( simonDTrigger ) {\n    setString( 'Down!');\n}\n\nsetFontSize( 48 );\nsetCenterX( 0.5 );\nsetCenterY( 0.5 );\n      }, {\n        otherProperties: [ phet.paperLand.displaySizeProperty ],\n        otherReferences: [  ]\n      } );\n    \n\n      const yippeeWrappedAudioBuffer = createAndLoadWrappedAudioBuffer( 'media/sounds/uploads/yipee-45360.mp3' );\n      const yippeeSoundClip = new phet.tambo.SoundClip( yippeeWrappedAudioBuffer, {\n        loop: false,\n        initialOutputLevel: 0.5\n       } );\n      phet.tambo.soundManager.addSoundGenerator( yippeeSoundClip );\n      scratchpad.yippeeWrappedAudioBuffer = yippeeWrappedAudioBuffer;\n      \n      let yippeeStopSoundTimeout = null;\n      \n      // as a safety measure, sound can only be played every 0.25 seconds - initial value is very small\n      // so that it can be played immediately\n      let yippeeLastPlayTime = 0;\n      \n      // The listener that will observe the model and play sounds is added as soon as the sounds are loaded, and\n      // added to the scratch pad so that it can be removed later.\n      scratchpad.yippeeWrappedAudioBufferListener = _buffer => {\n        if ( _buffer ) {\n        \n          // Play the sound when any dependencies change value.\n          scratchpad.yippeeSoundMultilinkId = phet.paperLand.addModelPropertyMultilink( [ 'playerWon' ], ( playerWon ) => {\n            \n            // in a local scope, define the functions that the user can use to manipulate the sound\n            const setOutputLevel = ( level ) => {\n            \n              // As a safety measure, don't let the user set a level below zero and above 2.\n              const outputLevel = Math.max( 0, Math.min( 2, level ) );\n              yippeeSoundClip.outputLevel = outputLevel;\n            };\n            const setPlaybackRate = ( rate ) => {\n            \n              // As a safety measure, the playback rate cannot go below zero.\n              const playbackRate = Math.max( 0, rate );\n              yippeeSoundClip.setPlaybackRate( playbackRate );\n            };\n            \n            // a function the user can call to play the sound\n            const play = () => {\n            \n              // Play the sound - if looping, we don't want to start playing again if already playing. The sound\n              // can only be played at a limited interval for safety.\n              if ( ( !yippeeSoundClip.isPlaying || !false ) && phet.paperLand.elapsedTimeProperty.value - yippeeLastPlayTime > 0.25 ) {\n      \n                // only start playing again if it has been stopped - but we still enter this block to update\n                // the last play time and timeouts        \n                if ( !yippeeSoundClip.isPlaying ) {\n                  yippeeSoundClip.play();\n                }\n                yippeeLastPlayTime = phet.paperLand.elapsedTimeProperty.value;\n                \n                // Set a timer to turn off the sound when the value stops changing.\n                if ( yippeeStopSoundTimeout ){\n                  window.clearTimeout( yippeeStopSoundTimeout );\n                }\n                \n                // only stop if not looping\n                if ( !false ) {\n                  yippeeStopSoundTimeout = window.setTimeout( () => {\n                    yippeeSoundClip.stop();\n                  }, 5000 );\n                }  \n              }\n            };\n            \n            const stop = () => {\n              // Set a timer to turn off the sound when the value stops changing.\n              if ( yippeeStopSoundTimeout ){\n                window.clearTimeout( yippeeStopSoundTimeout );\n              }\n              yippeeSoundClip.stop();\n            };\n            \n            if ( true ) {\n              play();\n            }\n            \n            // declare the references so that they can be used in the control function\n            \n          \n            if ( playerWon ) {\n    play();\n}\n          }, {\n            otherReferences: [  ],\n          } );  \n        }\n      };     \n      scratchpad.yippeeWrappedAudioBuffer.audioBufferProperty.link( scratchpad.yippeeWrappedAudioBufferListener );\n      \n      // Assign the sound to the scratchpad so that we can remove it later\n      scratchpad.yippeeSoundClip = yippeeSoundClip;\n    \n\n      scratchpad.playerSequenceControllerMultilinkId = phet.paperLand.addModelPropertyMultilink( [ 'markerIsOnA', 'playersTurn', 'markerIsOnB', 'markerIsOnC', 'markerIsOnD' ], ( markerIsOnA, playersTurn, markerIsOnB, markerIsOnC, markerIsOnD ) => {\n      \n        // We have behavior with components outside of the multilink that may not exist yet, we only do this\n        // work if all are available\n        if ( phet.paperLand.hasAllModelComponents( [ 'playerPlaybackSequence' ] ) ) {\n        \n          // references to the model components that are controlled by this listener AND the model compnoents\n          // that are selected as references\n          const playerPlaybackSequence = phet.paperLand.getModelComponent( 'playerPlaybackSequence' ).value;\n      \n          // the functions that are available to the client from their selected dependencies\n          const setPlayerPlaybackSequence = newValue => {\n        const modelComponent = phet.paperLand.getModelComponent( 'playerPlaybackSequence' );\n        modelComponent.value = newValue;  \n      }\n      \n      \n          // the code block that the user wrote to change controlled Properties\n          if ( playersTurn ) {\n    let nextNote;\n    if ( markerIsOnA ) {\n        nextNote = playerPlaybackSequence.length > 0 ? '-a' : 'a';\n    }\n    else if ( markerIsOnB ) {\n        nextNote = playerPlaybackSequence.length > 0 ? '-b' : 'b';\n    }\n    else if ( markerIsOnC ) {\n        nextNote = playerPlaybackSequence.length > 0 ? '-c' : 'c';\n    }\n    else if ( markerIsOnD ) {\n        nextNote = playerPlaybackSequence.length > 0 ? '-d' : 'd';\n    }\n\n    // Add the next note to the player sequence\n    if ( nextNote ) {\n        setPlayerPlaybackSequence( playerPlaybackSequence + nextNote );\n    }\n}   \n        }\n      } );\n    \n\n      const gameLoopAnimationListener = dt => {\n      \n        // listener only runs if all declared dependencies are available in the model\n        if ( phet.paperLand.hasAllModelComponents( [ 'simonATrigger', 'playersTurn', 'playerWon', 'songPlaybackIndex', 'timeSinceComputerNote', 'gameSequence', 'playerPlaybackSequence', 'simonBTrigger', 'simonCTrigger', 'simonDTrigger', 'sequenceLength' ] ) ) {\n               \n          // A reference to the elapsed time so it is usable in the function\n          const elapsedTime = phet.paperLand.elapsedTimeProperty.value;\n          \n          // references to each model component controlled by this listener\n          const simonATrigger = phet.paperLand.getModelComponent( 'simonATrigger' ).value;\nconst playersTurn = phet.paperLand.getModelComponent( 'playersTurn' ).value;\nconst playerWon = phet.paperLand.getModelComponent( 'playerWon' ).value;\nconst songPlaybackIndex = phet.paperLand.getModelComponent( 'songPlaybackIndex' ).value;\nconst timeSinceComputerNote = phet.paperLand.getModelComponent( 'timeSinceComputerNote' ).value;\nconst gameSequence = phet.paperLand.getModelComponent( 'gameSequence' ).value;\nconst playerPlaybackSequence = phet.paperLand.getModelComponent( 'playerPlaybackSequence' ).value;\nconst simonBTrigger = phet.paperLand.getModelComponent( 'simonBTrigger' ).value;\nconst simonCTrigger = phet.paperLand.getModelComponent( 'simonCTrigger' ).value;\nconst simonDTrigger = phet.paperLand.getModelComponent( 'simonDTrigger' ).value;\nconst sequenceLength = phet.paperLand.getModelComponent( 'sequenceLength' ).value;\n        \n          // the functions create in the local scope to manipulate the controlled components\n          const setSimonATrigger = newValue => {\n        const modelComponent = phet.paperLand.getModelComponent( 'simonATrigger' );\n        modelComponent.value = newValue;  \n      }\n      \nconst setPlayersTurn = newValue => {\n        const modelComponent = phet.paperLand.getModelComponent( 'playersTurn' );\n        modelComponent.value = newValue;  \n      }\n      \nconst setPlayerWon = newValue => {\n        const modelComponent = phet.paperLand.getModelComponent( 'playerWon' );\n        modelComponent.value = newValue;  \n      }\n      \nconst setSongPlaybackIndex = newValue => {\n        const modelComponent = phet.paperLand.getModelComponent( 'songPlaybackIndex' );\n        modelComponent.value = newValue;  \n      }\n      \nconst setTimeSinceComputerNote = newValue => {\n        const modelComponent = phet.paperLand.getModelComponent( 'timeSinceComputerNote' );\n        modelComponent.value = newValue;  \n      }\n      \nconst setGameSequence = newValue => {\n        const modelComponent = phet.paperLand.getModelComponent( 'gameSequence' );\n        modelComponent.value = newValue;  \n      }\n      \nconst setPlayerPlaybackSequence = newValue => {\n        const modelComponent = phet.paperLand.getModelComponent( 'playerPlaybackSequence' );\n        modelComponent.value = newValue;  \n      }\n      \nconst setSimonBTrigger = newValue => {\n        const modelComponent = phet.paperLand.getModelComponent( 'simonBTrigger' );\n        modelComponent.value = newValue;  \n      }\n      \nconst setSimonCTrigger = newValue => {\n        const modelComponent = phet.paperLand.getModelComponent( 'simonCTrigger' );\n        modelComponent.value = newValue;  \n      }\n      \nconst setSimonDTrigger = newValue => {\n        const modelComponent = phet.paperLand.getModelComponent( 'simonDTrigger' );\n        modelComponent.value = newValue;  \n      }\n      \nconst setSequenceLength = newValue => {\n        const modelComponent = phet.paperLand.getModelComponent( 'sequenceLength' );\n        modelComponent.value = newValue;  \n      }\n      \n          \n          // the function that that the user wrote\n          if ( playersTurn ) {\n    const sequenceArray = gameSequence.split( '-' );\n    const playerSequenceArray = playerPlaybackSequence.split( '-' );\n\n    // otherwise, if they are the same, player wins\n    if ( playerPlaybackSequence === gameSequence ) {\n        setPlayerWon( true );\n\n        setSequenceLength( sequenceLength + 1 );\n\n        setPlayersTurn( false );\n        setPlayerPlaybackSequence( '' );\n        setTimeSinceComputerNote( 0 );\n\n        // create a new game sequence with 4 notes\n        const letters = [ 'a', 'b', 'c', 'd' ];\n        let newSequence = letters[ Math.round( Math.random() * 3 ) ];\n        for ( let i = 0; i < sequenceLength; i++ ) {\n            const randomLetter = letters[ Math.round( Math.random() * 3 ) ];\n            newSequence = `${newSequence}-${randomLetter}`;\n        } \n        setGameSequence( newSequence );\n    }\n    else {\n\n      // if any of the player's sequences are wrong, stop and move to computer turn\n      playerSequenceArray.forEach( ( note, index ) => {\n          if ( note && sequenceArray[ index ] !== note ) {\n            setPlayersTurn( false );\n            setPlayerPlaybackSequence( '' );\n            setTimeSinceComputerNote( 0 );\n          }\n      } );\n        \n    }\n}\nelse {\n\n    // Its the computer's turn - play through the song sequence one note at a time\n\n\n    // increment time since the last note\n    setTimeSinceComputerNote( timeSinceComputerNote + dt );\n\n    // if it has been long enough, play the next note\n    const interval = 1;\n\n    if ( timeSinceComputerNote > interval / 2 ) {\n\n        // reset computer note triggers before playing the next tone\n        setSimonATrigger( false );\n        setSimonBTrigger( false );\n        setSimonCTrigger( false );\n        setSimonDTrigger( false );\n    }\n\n    if ( timeSinceComputerNote > interval ) {\n\n        // if the player won last game, reset this state so that we go back to turn text\n        setPlayerWon( false );\n\n        const gameSequenceArray = gameSequence.split( '-' );\n\n        const nextNoteToPlay = gameSequenceArray[ songPlaybackIndex ]\n\n        if ( nextNoteToPlay === 'a' ) {\n            setSimonATrigger( true );\n        }\n        else if ( nextNoteToPlay === 'b' ) {\n            setSimonBTrigger( true );\n        }\n        else if ( nextNoteToPlay === 'c' ) {\n            setSimonCTrigger( true );\n        }\n        else if ( nextNoteToPlay === 'd' ) {\n            setSimonDTrigger( true );\n        }\n\n        // reset interval to play the next note after a delay\n        setTimeSinceComputerNote( 0 );\n\n        setSongPlaybackIndex( songPlaybackIndex + 1 );\n\n        if ( songPlaybackIndex === gameSequenceArray.length ) {\n\n            // We have played through all the notes, switch to player turn\n            setPlayersTurn( true );\n            setSongPlaybackIndex( 0 );\n        }\n    }\n\n} \n        }\n      };\n      scratchpad.gameLoopAnimationListener = gameLoopAnimationListener;\n      \n      // add the listener to the step timer\n      phet.axon.stepTimer.addListener( gameLoopAnimationListener );\n      \n    \n  };\n\n  const onProgramRemoved = ( paperNumber, scratchpad, sharedData ) => {\n    \n      // Remove the component from the model\n      phet.paperLand.removeModelComponent( 'playersTurn' );\n    \n\n      // Remove the component from the model\n      phet.paperLand.removeModelComponent( 'playerWon' );\n    \n\n      // Remove the component from the model\n      phet.paperLand.removeModelComponent( 'songPlaybackIndex' );\n    \n\n      // Remove the component from the model\n      phet.paperLand.removeModelComponent( 'timeSinceComputerNote' );\n    \n\n      // Remove the component from the model\n      phet.paperLand.removeModelComponent( 'gameSequence' );\n    \n\n      // Remove the component from the model\n      phet.paperLand.removeModelComponent( 'playerPlaybackSequence' );\n    \n\n      // Remove the component from the model\n      phet.paperLand.removeModelComponent( 'sequenceLength' );\n    \n\n      // Remove the text from the view.\n      sharedData.scene.removeChild( scratchpad.gameStateTextText );\n      delete scratchpad.gameStateTextText;\n      \n      // Remove the multilink\n      phet.paperLand.removeModelPropertyMultilink( [ 'simonATrigger', 'playersTurn', 'playerWon', 'simonBTrigger', 'simonCTrigger', 'simonDTrigger' ], scratchpad.gameStateTextTextMultilinkId, {\n        otherReferences: [  ]\n      });\n      delete scratchpad.gameStateTextTextMultilinkId;\n    \n\n      phet.tambo.soundManager.removeSoundGenerator( scratchpad.yippeeSoundClip );\n      delete scratchpad.yippeeSoundClip;\n      \n      scratchpad.yippeeWrappedAudioBuffer.audioBufferProperty.unlink( scratchpad.yippeeWrappedAudioBufferListener );\n      delete scratchpad.yippeeWrappedAudioBufferListener;\n      \n      phet.paperLand.removeModelPropertyMultilink( [ 'playerWon' ], scratchpad.yippeeSoundMultilinkId, {\n        otherReferences: [  ]\n       } );\n      delete scratchpad.yippeeSoundMultilinkId;\n    \n\n      phet.paperLand.removeModelPropertyMultilink( [ 'markerIsOnA', 'playersTurn', 'markerIsOnB', 'markerIsOnC', 'markerIsOnD' ], scratchpad.playerSequenceControllerMultilinkId );\n      delete scratchpad.playerSequenceControllerMultilinkId;\n    \n\n      phet.axon.stepTimer.removeListener( scratchpad.gameLoopAnimationListener );\n      delete scratchpad.gameLoopAnimationListener;\n    \n  };\n\n  const onProgramChangedPosition = ( paperNumber, points, scratchpad, sharedData ) => {\n    \n  };\n  \n  const onProgramMarkersAdded = ( paperNumber, points, scratchpad, sharedData, markers ) => {\n    \n  };\n  \n  const onProgramMarkersRemoved = ( paperNumber, points, scratchpad, sharedData, markers ) => {\n    \n  };\n  \n  const onProgramMarkersChangedPosition = ( paperNumber, points, scratchpad, sharedData, markers ) => {\n    \n  };\n  \n  const onProgramAdjacent = ( paperNumber, otherPaperNumber, direction, scratchpad, sharedData ) => {\n    \n  };\n  \n  const onProgramSeparated = ( paperNumber, otherPaperNumber, direction, scratchpad, sharedData ) => {\n    \n  };\n\n  await paper.set( 'data', {\n    paperPlaygroundData: {\n      updateTime: Date.now(),\n      eventHandlers: {\n        onProgramAdded: onProgramAdded.toString(),\n        onProgramRemoved: onProgramRemoved.toString(),\n        onProgramChangedPosition: onProgramChangedPosition.toString(),\n        onProgramMarkersAdded: onProgramMarkersAdded.toString(),\n        onProgramMarkersRemoved: onProgramMarkersRemoved.toString(),\n        onProgramMarkersChangedPosition: onProgramMarkersChangedPosition.toString(),\n        onProgramAdjacent: onProgramAdjacent.toString(),\n        onProgramSeparated: onProgramSeparated.toString(),\n      },\n      customWhiskerLengths: {\n        top: 0.2,\n        right: 0.2,\n        bottom: 0.2,\n        left: 0.2\n      }\n    }\n  } );\n  \n  // PROJECTOR CODE //\n  // Get a canvas object for this paper to draw something to the Projector.\n  const canvas = await paper.get('canvas');\n\n  // Draw the name of the program to the projector\n  const ctx = canvas.getContext('2d');\n  ctx.font = '20px sans-serif';\n  ctx.textAlign = 'center';\n  ctx.fillStyle = 'rgb(255,0,0)';\n  ctx.fillText('', canvas.width / 2, canvas.height / 2 - 10);\n  ctx.fillStyle = 'rgb(0,255,0)';\n  ctx.font = '10px sans-serif';\n  ctx.fillText('Game Logic', canvas.width / 2, canvas.height / 2 + 20);\n})();\n",
  "currentCode": "// Game Logic\n// Keywords: \n// Description: The 'game logic'. Uses an animation component to play the song sequence and receive notes from the player.\n// \n// The song sequence is encoded in a string for convenience. Would be nice if the array component could work but it doesn't support this case. It\n// would be better if we had a catch-all component for any kind of JavaScript object for this kind of thing.\n\nimportScripts('paper.js');\n\n(async () => {\n\n  const onProgramAdded = ( paperNumber, scratchpad, sharedData ) => {\n    \n      const playersTurn = new phet.axon.BooleanProperty(false);\n      phet.paperLand.addModelComponent( 'playersTurn', playersTurn );\n    \n\n      const playerWon = new phet.axon.BooleanProperty(false);\n      phet.paperLand.addModelComponent( 'playerWon', playerWon );\n    \n\n      const songPlaybackIndex = new phet.axon.NumberProperty( 0, {\n        range: new phet.dot.Range( 0, 8 )\n      });\n      phet.paperLand.addModelComponent( 'songPlaybackIndex', songPlaybackIndex );\n    \n\n      const timeSinceComputerNote = new phet.axon.NumberProperty( 0, {\n        range: new phet.dot.Range( 0, 10 )\n      });\n      phet.paperLand.addModelComponent( 'timeSinceComputerNote', timeSinceComputerNote );\n    \n\n      const gameSequence = new phet.axon.StringProperty( 'a-b-c-d' );\n      phet.paperLand.addModelComponent( 'gameSequence', gameSequence );\n    \n\n      const playerPlaybackSequence = new phet.axon.StringProperty( '' );\n      phet.paperLand.addModelComponent( 'playerPlaybackSequence', playerPlaybackSequence );\n    \n\n      const sequenceLength = new phet.axon.NumberProperty( 4, {\n        range: new phet.dot.Range( 0, 10 )\n      });\n      phet.paperLand.addModelComponent( 'sequenceLength', sequenceLength );\n    \n\n      // Create the text and add it to the view - using RichText for nice markup support.\n      const gameStateTextText = new phet.scenery.RichText( '', { fill: 'white' } );\n      \n      sharedData.scene.addChild( gameStateTextText );\n      scratchpad.gameStateTextText = gameStateTextText;\n      \n      // Update the text when a dependency changes.\n      scratchpad.gameStateTextTextMultilinkId = phet.paperLand.addModelPropertyMultilink( [ 'simonATrigger', 'playersTurn', 'playerWon', 'simonBTrigger', 'simonCTrigger', 'simonDTrigger' ], ( simonATrigger, playersTurn, playerWon, simonBTrigger, simonCTrigger, simonDTrigger ) => {\n      \n        // the additional reference constants\n        \n      \n        // in a local scope, define the functions that the user can use to manipulate the text\n        \n      const unitBoundsToDisplayBounds = ( bounds ) => {\n        return phet.paperLand.utils.paperToBoardBounds( bounds, sharedData.displaySize.width, sharedData.displaySize.height );\n      };\n      \n      const unitPositionToDisplayPosition = ( position ) => {\n        return phet.paperLand.utils.paperToBoardCoordinates( position, sharedData.displaySize.width, sharedData.displaySize.height );\n      };\n    \n      const setCenterX = ( x ) => {\n        gameStateTextText.centerX = phet.paperLand.utils.paperToBoardX( x, sharedData.displaySize.width );\n      };\n      \n      const setCenterY = ( y ) => {\n        gameStateTextText.centerY = phet.paperLand.utils.paperToBoardY( y, sharedData.displaySize.height );\n      };\n      \n      const setLeft = ( left ) => {\n        gameStateTextText.left = phet.paperLand.utils.paperToBoardX( left, sharedData.displaySize.width );\n      };\n      \n      const setTop = ( top ) => {\n        gameStateTextText.top = phet.paperLand.utils.paperToBoardY( top, sharedData.displaySize.height );\n      };\n      \n      const setScale = ( scale ) => {\n        gameStateTextText.setScaleMagnitude( scale );\n      };\n      \n      const setOpacity = ( opacity ) => {\n        gameStateTextText.opacity = opacity;\n      };\n      \n      const setVisible = ( visible ) => {\n        gameStateTextText.visible = visible;\n      };\n      \n      const moveToFront = () => {\n        gameStateTextText.moveToFront();\n      };\n      \n      const moveToBack = () => {\n        gameStateTextText.moveToBack();\n      };\n      \n      const setRotation = ( rotation ) => {\n        gameStateTextText.rotation = rotation;\n      };\n\n      // Set the scale in X and Y and the       \n      const matchBounds = ( bounds, stretch ) => {\n      \n        // Find the scale to apply to the x and y dimensions so that the component bounds match the provided bounds\n        const gameStateTextTextViewBounds = phet.paperLand.utils.paperToBoardBounds(bounds, sharedData.displaySize.width, sharedData.displaySize.height);\n\n        // local bounds may be zero as things load\n        // const aspectRatio = ( gameStateTextText.localBounds.width || 1 ) / ( gameStateTextText.localBounds.height || 1 );\n\n        const scaleX = gameStateTextTextViewBounds.width / ( gameStateTextText.localBounds.width || 1 );\n        const scaleY = gameStateTextTextViewBounds.height / ( gameStateTextText.localBounds.height || 1 );\n\n        if ( stretch ) {\n          gameStateTextText.setScaleMagnitude(scaleX, scaleY);\n        }\n        else {\n        \n          // Scale by the minimum of the x and y scale factors, preserving the aspect ratio\n          gameStateTextText.setScaleMagnitude( Math.min( scaleX, scaleY ) );\n        }        \n\n        // Now put the component in the center of the bounds\n        gameStateTextText.center = gameStateTextTextViewBounds.center;\n      };\n      \n\n        const setString = ( string ) => {\n          gameStateTextText.string = string;\n        };\n        \n        const setFontSize = ( size ) => {\n        \n          // RichText has no setter for size, so we need to create a new font. Use\n          // state from the old font to maintain the family.\n          const currentFont = gameStateTextText.font;\n          const newFont = new phet.scenery.Font( { size: size, family: currentFont.family } );\n          gameStateTextText.font = newFont;\n        };\n\n        const setTextColor = ( color ) => {\n          gameStateTextText.fill = color;\n        };\n\n        const setFontFamily = ( family ) => {\n        \n          // RichText has no setter for fontFamily, so we need to create a new font. Use\n          // state from the old font to maintain the size.\n          const currentFont = gameStateTextText.font;\n          const newFont = new phet.scenery.Font( { size: currentFont.size, family: family } );\n          gameStateTextText.font = newFont;\n        };\n      \n\n        // the function that the user wrote to update the text      \n        if ( playerWon ) {\n    setString( 'You won!' );\n}\nelse if ( playersTurn ) {\n    setString( 'Your turn!' );\n}\nelse if ( simonATrigger ) {\n    setString( 'Up!' );\n}\nelse if ( simonBTrigger ) {\n    setString( 'Left!' );\n}\nelse if ( simonCTrigger ) {\n    setString( 'Right!' );\n}\nelse if ( simonDTrigger ) {\n    setString( 'Down!');\n}\n\nsetFontSize( 48 );\nsetCenterX( 0.5 );\nsetCenterY( 0.5 );\n      }, {\n        otherProperties: [ phet.paperLand.displaySizeProperty ],\n        otherReferences: [  ]\n      } );\n    \n\n      const yippeeWrappedAudioBuffer = createAndLoadWrappedAudioBuffer( 'media/sounds/uploads/yipee-45360.mp3' );\n      const yippeeSoundClip = new phet.tambo.SoundClip( yippeeWrappedAudioBuffer, {\n        loop: false,\n        initialOutputLevel: 0.5\n       } );\n      phet.tambo.soundManager.addSoundGenerator( yippeeSoundClip );\n      scratchpad.yippeeWrappedAudioBuffer = yippeeWrappedAudioBuffer;\n      \n      let yippeeStopSoundTimeout = null;\n      \n      // as a safety measure, sound can only be played every 0.25 seconds - initial value is very small\n      // so that it can be played immediately\n      let yippeeLastPlayTime = 0;\n      \n      // The listener that will observe the model and play sounds is added as soon as the sounds are loaded, and\n      // added to the scratch pad so that it can be removed later.\n      scratchpad.yippeeWrappedAudioBufferListener = _buffer => {\n        if ( _buffer ) {\n        \n          // Play the sound when any dependencies change value.\n          scratchpad.yippeeSoundMultilinkId = phet.paperLand.addModelPropertyMultilink( [ 'playerWon' ], ( playerWon ) => {\n            \n            // in a local scope, define the functions that the user can use to manipulate the sound\n            const setOutputLevel = ( level ) => {\n            \n              // As a safety measure, don't let the user set a level below zero and above 2.\n              const outputLevel = Math.max( 0, Math.min( 2, level ) );\n              yippeeSoundClip.outputLevel = outputLevel;\n            };\n            const setPlaybackRate = ( rate ) => {\n            \n              // As a safety measure, the playback rate cannot go below zero.\n              const playbackRate = Math.max( 0, rate );\n              yippeeSoundClip.setPlaybackRate( playbackRate );\n            };\n            \n            // a function the user can call to play the sound\n            const play = () => {\n            \n              // Play the sound - if looping, we don't want to start playing again if already playing. The sound\n              // can only be played at a limited interval for safety.\n              if ( ( !yippeeSoundClip.isPlaying || !false ) && phet.paperLand.elapsedTimeProperty.value - yippeeLastPlayTime > 0.25 ) {\n      \n                // only start playing again if it has been stopped - but we still enter this block to update\n                // the last play time and timeouts        \n                if ( !yippeeSoundClip.isPlaying ) {\n                  yippeeSoundClip.play();\n                }\n                yippeeLastPlayTime = phet.paperLand.elapsedTimeProperty.value;\n                \n                // Set a timer to turn off the sound when the value stops changing.\n                if ( yippeeStopSoundTimeout ){\n                  window.clearTimeout( yippeeStopSoundTimeout );\n                }\n                \n                // only stop if not looping\n                if ( !false ) {\n                  yippeeStopSoundTimeout = window.setTimeout( () => {\n                    yippeeSoundClip.stop();\n                  }, 5000 );\n                }  \n              }\n            };\n            \n            const stop = () => {\n              // Set a timer to turn off the sound when the value stops changing.\n              if ( yippeeStopSoundTimeout ){\n                window.clearTimeout( yippeeStopSoundTimeout );\n              }\n              yippeeSoundClip.stop();\n            };\n            \n            if ( true ) {\n              play();\n            }\n            \n            // declare the references so that they can be used in the control function\n            \n          \n            if ( playerWon ) {\n    play();\n}\n          }, {\n            otherReferences: [  ],\n          } );  \n        }\n      };     \n      scratchpad.yippeeWrappedAudioBuffer.audioBufferProperty.link( scratchpad.yippeeWrappedAudioBufferListener );\n      \n      // Assign the sound to the scratchpad so that we can remove it later\n      scratchpad.yippeeSoundClip = yippeeSoundClip;\n    \n\n      scratchpad.playerSequenceControllerMultilinkId = phet.paperLand.addModelPropertyMultilink( [ 'markerIsOnA', 'playersTurn', 'markerIsOnB', 'markerIsOnC', 'markerIsOnD' ], ( markerIsOnA, playersTurn, markerIsOnB, markerIsOnC, markerIsOnD ) => {\n      \n        // We have behavior with components outside of the multilink that may not exist yet, we only do this\n        // work if all are available\n        if ( phet.paperLand.hasAllModelComponents( [ 'playerPlaybackSequence' ] ) ) {\n        \n          // references to the model components that are controlled by this listener AND the model compnoents\n          // that are selected as references\n          const playerPlaybackSequence = phet.paperLand.getModelComponent( 'playerPlaybackSequence' ).value;\n      \n          // the functions that are available to the client from their selected dependencies\n          const setPlayerPlaybackSequence = newValue => {\n        const modelComponent = phet.paperLand.getModelComponent( 'playerPlaybackSequence' );\n        modelComponent.value = newValue;  \n      }\n      \n      \n          // the code block that the user wrote to change controlled Properties\n          if ( playersTurn ) {\n    let nextNote;\n    if ( markerIsOnA ) {\n        nextNote = playerPlaybackSequence.length > 0 ? '-a' : 'a';\n    }\n    else if ( markerIsOnB ) {\n        nextNote = playerPlaybackSequence.length > 0 ? '-b' : 'b';\n    }\n    else if ( markerIsOnC ) {\n        nextNote = playerPlaybackSequence.length > 0 ? '-c' : 'c';\n    }\n    else if ( markerIsOnD ) {\n        nextNote = playerPlaybackSequence.length > 0 ? '-d' : 'd';\n    }\n\n    // Add the next note to the player sequence\n    if ( nextNote ) {\n        setPlayerPlaybackSequence( playerPlaybackSequence + nextNote );\n    }\n}   \n        }\n      } );\n    \n\n      const gameLoopAnimationListener = dt => {\n      \n        // listener only runs if all declared dependencies are available in the model\n        if ( phet.paperLand.hasAllModelComponents( [ 'simonATrigger', 'playersTurn', 'playerWon', 'songPlaybackIndex', 'timeSinceComputerNote', 'gameSequence', 'playerPlaybackSequence', 'simonBTrigger', 'simonCTrigger', 'simonDTrigger', 'sequenceLength' ] ) ) {\n               \n          // A reference to the elapsed time so it is usable in the function\n          const elapsedTime = phet.paperLand.elapsedTimeProperty.value;\n          \n          // references to each model component controlled by this listener\n          const simonATrigger = phet.paperLand.getModelComponent( 'simonATrigger' ).value;\nconst playersTurn = phet.paperLand.getModelComponent( 'playersTurn' ).value;\nconst playerWon = phet.paperLand.getModelComponent( 'playerWon' ).value;\nconst songPlaybackIndex = phet.paperLand.getModelComponent( 'songPlaybackIndex' ).value;\nconst timeSinceComputerNote = phet.paperLand.getModelComponent( 'timeSinceComputerNote' ).value;\nconst gameSequence = phet.paperLand.getModelComponent( 'gameSequence' ).value;\nconst playerPlaybackSequence = phet.paperLand.getModelComponent( 'playerPlaybackSequence' ).value;\nconst simonBTrigger = phet.paperLand.getModelComponent( 'simonBTrigger' ).value;\nconst simonCTrigger = phet.paperLand.getModelComponent( 'simonCTrigger' ).value;\nconst simonDTrigger = phet.paperLand.getModelComponent( 'simonDTrigger' ).value;\nconst sequenceLength = phet.paperLand.getModelComponent( 'sequenceLength' ).value;\n        \n          // the functions create in the local scope to manipulate the controlled components\n          const setSimonATrigger = newValue => {\n        const modelComponent = phet.paperLand.getModelComponent( 'simonATrigger' );\n        modelComponent.value = newValue;  \n      }\n      \nconst setPlayersTurn = newValue => {\n        const modelComponent = phet.paperLand.getModelComponent( 'playersTurn' );\n        modelComponent.value = newValue;  \n      }\n      \nconst setPlayerWon = newValue => {\n        const modelComponent = phet.paperLand.getModelComponent( 'playerWon' );\n        modelComponent.value = newValue;  \n      }\n      \nconst setSongPlaybackIndex = newValue => {\n        const modelComponent = phet.paperLand.getModelComponent( 'songPlaybackIndex' );\n        modelComponent.value = newValue;  \n      }\n      \nconst setTimeSinceComputerNote = newValue => {\n        const modelComponent = phet.paperLand.getModelComponent( 'timeSinceComputerNote' );\n        modelComponent.value = newValue;  \n      }\n      \nconst setGameSequence = newValue => {\n        const modelComponent = phet.paperLand.getModelComponent( 'gameSequence' );\n        modelComponent.value = newValue;  \n      }\n      \nconst setPlayerPlaybackSequence = newValue => {\n        const modelComponent = phet.paperLand.getModelComponent( 'playerPlaybackSequence' );\n        modelComponent.value = newValue;  \n      }\n      \nconst setSimonBTrigger = newValue => {\n        const modelComponent = phet.paperLand.getModelComponent( 'simonBTrigger' );\n        modelComponent.value = newValue;  \n      }\n      \nconst setSimonCTrigger = newValue => {\n        const modelComponent = phet.paperLand.getModelComponent( 'simonCTrigger' );\n        modelComponent.value = newValue;  \n      }\n      \nconst setSimonDTrigger = newValue => {\n        const modelComponent = phet.paperLand.getModelComponent( 'simonDTrigger' );\n        modelComponent.value = newValue;  \n      }\n      \nconst setSequenceLength = newValue => {\n        const modelComponent = phet.paperLand.getModelComponent( 'sequenceLength' );\n        modelComponent.value = newValue;  \n      }\n      \n          \n          // the function that that the user wrote\n          if ( playersTurn ) {\n    const sequenceArray = gameSequence.split( '-' );\n    const playerSequenceArray = playerPlaybackSequence.split( '-' );\n\n    // otherwise, if they are the same, player wins\n    if ( playerPlaybackSequence === gameSequence ) {\n        setPlayerWon( true );\n\n        setSequenceLength( sequenceLength + 1 );\n\n        setPlayersTurn( false );\n        setPlayerPlaybackSequence( '' );\n        setTimeSinceComputerNote( 0 );\n\n        // create a new game sequence with 4 notes\n        const letters = [ 'a', 'b', 'c', 'd' ];\n        let newSequence = letters[ Math.round( Math.random() * 3 ) ];\n        for ( let i = 0; i < sequenceLength; i++ ) {\n            const randomLetter = letters[ Math.round( Math.random() * 3 ) ];\n            newSequence = `${newSequence}-${randomLetter}`;\n        } \n        setGameSequence( newSequence );\n    }\n    else {\n\n      // if any of the player's sequences are wrong, stop and move to computer turn\n      playerSequenceArray.forEach( ( note, index ) => {\n          if ( note && sequenceArray[ index ] !== note ) {\n            setPlayersTurn( false );\n            setPlayerPlaybackSequence( '' );\n            setTimeSinceComputerNote( 0 );\n          }\n      } );\n        \n    }\n}\nelse {\n\n    // Its the computer's turn - play through the song sequence one note at a time\n\n\n    // increment time since the last note\n    setTimeSinceComputerNote( timeSinceComputerNote + dt );\n\n    // if it has been long enough, play the next note\n    const interval = 1;\n\n    if ( timeSinceComputerNote > interval / 2 ) {\n\n        // reset computer note triggers before playing the next tone\n        setSimonATrigger( false );\n        setSimonBTrigger( false );\n        setSimonCTrigger( false );\n        setSimonDTrigger( false );\n    }\n\n    if ( timeSinceComputerNote > interval ) {\n\n        // if the player won last game, reset this state so that we go back to turn text\n        setPlayerWon( false );\n\n        const gameSequenceArray = gameSequence.split( '-' );\n\n        const nextNoteToPlay = gameSequenceArray[ songPlaybackIndex ]\n\n        if ( nextNoteToPlay === 'a' ) {\n            setSimonATrigger( true );\n        }\n        else if ( nextNoteToPlay === 'b' ) {\n            setSimonBTrigger( true );\n        }\n        else if ( nextNoteToPlay === 'c' ) {\n            setSimonCTrigger( true );\n        }\n        else if ( nextNoteToPlay === 'd' ) {\n            setSimonDTrigger( true );\n        }\n\n        // reset interval to play the next note after a delay\n        setTimeSinceComputerNote( 0 );\n\n        setSongPlaybackIndex( songPlaybackIndex + 1 );\n\n        if ( songPlaybackIndex === gameSequenceArray.length ) {\n\n            // We have played through all the notes, switch to player turn\n            setPlayersTurn( true );\n            setSongPlaybackIndex( 0 );\n        }\n    }\n\n} \n        }\n      };\n      scratchpad.gameLoopAnimationListener = gameLoopAnimationListener;\n      \n      // add the listener to the step timer\n      phet.axon.stepTimer.addListener( gameLoopAnimationListener );\n      \n    \n  };\n\n  const onProgramRemoved = ( paperNumber, scratchpad, sharedData ) => {\n    \n      // Remove the component from the model\n      phet.paperLand.removeModelComponent( 'playersTurn' );\n    \n\n      // Remove the component from the model\n      phet.paperLand.removeModelComponent( 'playerWon' );\n    \n\n      // Remove the component from the model\n      phet.paperLand.removeModelComponent( 'songPlaybackIndex' );\n    \n\n      // Remove the component from the model\n      phet.paperLand.removeModelComponent( 'timeSinceComputerNote' );\n    \n\n      // Remove the component from the model\n      phet.paperLand.removeModelComponent( 'gameSequence' );\n    \n\n      // Remove the component from the model\n      phet.paperLand.removeModelComponent( 'playerPlaybackSequence' );\n    \n\n      // Remove the component from the model\n      phet.paperLand.removeModelComponent( 'sequenceLength' );\n    \n\n      // Remove the text from the view.\n      sharedData.scene.removeChild( scratchpad.gameStateTextText );\n      delete scratchpad.gameStateTextText;\n      \n      // Remove the multilink\n      phet.paperLand.removeModelPropertyMultilink( [ 'simonATrigger', 'playersTurn', 'playerWon', 'simonBTrigger', 'simonCTrigger', 'simonDTrigger' ], scratchpad.gameStateTextTextMultilinkId, {\n        otherReferences: [  ]\n      });\n      delete scratchpad.gameStateTextTextMultilinkId;\n    \n\n      phet.tambo.soundManager.removeSoundGenerator( scratchpad.yippeeSoundClip );\n      delete scratchpad.yippeeSoundClip;\n      \n      scratchpad.yippeeWrappedAudioBuffer.audioBufferProperty.unlink( scratchpad.yippeeWrappedAudioBufferListener );\n      delete scratchpad.yippeeWrappedAudioBufferListener;\n      \n      phet.paperLand.removeModelPropertyMultilink( [ 'playerWon' ], scratchpad.yippeeSoundMultilinkId, {\n        otherReferences: [  ]\n       } );\n      delete scratchpad.yippeeSoundMultilinkId;\n    \n\n      phet.paperLand.removeModelPropertyMultilink( [ 'markerIsOnA', 'playersTurn', 'markerIsOnB', 'markerIsOnC', 'markerIsOnD' ], scratchpad.playerSequenceControllerMultilinkId );\n      delete scratchpad.playerSequenceControllerMultilinkId;\n    \n\n      phet.axon.stepTimer.removeListener( scratchpad.gameLoopAnimationListener );\n      delete scratchpad.gameLoopAnimationListener;\n    \n  };\n\n  const onProgramChangedPosition = ( paperNumber, points, scratchpad, sharedData ) => {\n    \n  };\n  \n  const onProgramMarkersAdded = ( paperNumber, points, scratchpad, sharedData, markers ) => {\n    \n  };\n  \n  const onProgramMarkersRemoved = ( paperNumber, points, scratchpad, sharedData, markers ) => {\n    \n  };\n  \n  const onProgramMarkersChangedPosition = ( paperNumber, points, scratchpad, sharedData, markers ) => {\n    \n  };\n  \n  const onProgramAdjacent = ( paperNumber, otherPaperNumber, direction, scratchpad, sharedData ) => {\n    \n  };\n  \n  const onProgramSeparated = ( paperNumber, otherPaperNumber, direction, scratchpad, sharedData ) => {\n    \n  };\n\n  await paper.set( 'data', {\n    paperPlaygroundData: {\n      updateTime: Date.now(),\n      eventHandlers: {\n        onProgramAdded: onProgramAdded.toString(),\n        onProgramRemoved: onProgramRemoved.toString(),\n        onProgramChangedPosition: onProgramChangedPosition.toString(),\n        onProgramMarkersAdded: onProgramMarkersAdded.toString(),\n        onProgramMarkersRemoved: onProgramMarkersRemoved.toString(),\n        onProgramMarkersChangedPosition: onProgramMarkersChangedPosition.toString(),\n        onProgramAdjacent: onProgramAdjacent.toString(),\n        onProgramSeparated: onProgramSeparated.toString(),\n      },\n      customWhiskerLengths: {\n        top: 0.2,\n        right: 0.2,\n        bottom: 0.2,\n        left: 0.2\n      }\n    }\n  } );\n  \n  // PROJECTOR CODE //\n  // Get a canvas object for this paper to draw something to the Projector.\n  const canvas = await paper.get('canvas');\n\n  // Draw the name of the program to the projector\n  const ctx = canvas.getContext('2d');\n  ctx.font = '20px sans-serif';\n  ctx.textAlign = 'center';\n  ctx.fillStyle = 'rgb(255,0,0)';\n  ctx.fillText('', canvas.width / 2, canvas.height / 2 - 10);\n  ctx.fillStyle = 'rgb(0,255,0)';\n  ctx.font = '10px sans-serif';\n  ctx.fillText('Game Logic', canvas.width / 2, canvas.height / 2 + 20);\n})();\n",
  "printed": false,
  "editorInfo": {},
  "currentCodeUrl": "program.my-temp-space.1.js",
  "currentCodeHash": "",
  "debugUrl": "/api/spaces/my-temp-space/programs/1/debugInfo",
  "claimUrl": "/api/spaces/my-temp-space/programs/1/claim",
  "codeHasChanged": false,
  "debugInfo": "{\"logs\":[]}"
}