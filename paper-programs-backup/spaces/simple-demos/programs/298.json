{
  "number": 298,
  "originalCode": "// Radio Group - Markers\n// Keywords: radio, buttons, markers, example, voicing\n// =============================== //\n// Program Dependencies: N/A\n// Recommended Programs:\n// Program Description: Creates a \"radio group\" that lets user select a value from a number of values. The\n//                      number of markers controls the value. 0 markers sets to first value, 1 markers sets\n//                      to second value, and so on.                                \n\nimportScripts('paper.js');\n\n(async () => {\n\n  //----------------------------------------------------------------------\n  // Board code\n  //----------------------------------------------------------------------\n\n  // Get the paper number of this piece of paper (which should not change).\n  const myPaperNumber = await paper.get('number');\n\n  // Called when the program is detected or changed.\n  const onProgramAdded = ( paperProgramNumber, scratchpad, sharedData ) => {\n\n    // Values for the group. This list can have any number of values. The values of \n    // this example are strings, but they can be any kind of type. They must all\n    // be different.\n    const values = [\n      'VALUE_A',\n      'VALUE_B',\n      'VALUE_C',\n      'VALUE_D'\n    ];\n\n    // Create an axon.Property for the model that any program can observe and control.\n    phet.paperLand.addModelComponent( 'radioProperty', new phet.axon.Property( values[ 0 ] ) );\n\n    // This is the function we want to call whenever a marker is added or removed from the program. You\n    // could copy/paste the body of this function right into onProgramMarkersAdded/Removed functions,\n    // but it is created once here and assigned to the scratchpad to avoid code duplication. The function\n    // takes a single argument, the current number of markers contained in the program.\n    scratchpad.handleMarkersChanged = currentMarkers => {\n\n      // If the model doesn't have the Property we created when the program was added,\n      // something went wrong and this function will fail!\n      if ( !sharedData.model.has( 'radioProperty' ) ) {\n        phet.paperLand.console.error( 'radioProperty does not exist in the model!' );\n        return;\n      }\n\n      // get a reference to the Property now that we know it exists\n      const radioProperty = sharedData.model.get( 'radioProperty' );\n\n      // The number of markers control the current value.\n      const numberOfMarkers = currentMarkers.length;\n      if ( numberOfMarkers < values.length ) {\n        radioProperty.value = values[ numberOfMarkers ];\n      }\n      else {\n        \n        // There are more markers in the program than there are values, just set to the last\n        // possible value\n        radioProperty.value = values[ values.length - 1 ];\n      }\n    }\n\n    // Observe the changing Property - this function just prints the new value to the console, but\n    // you could do anything in this function or put this function in a different program. addModelPropertyLink\n    // returns a uniqueID which is saved to the scratchpad so it can be easily unlinked later.\n    scratchpad.linkId = phet.paperLand.addModelPropertyLink( 'radioProperty', value => {\n      phet.paperLand.console.warn( `New radio value: ${value}` );\n\n\n    } );\n  };\n\n  // Called when the program is changed or no longer detected.\n  const onProgramRemoved = ( paperProgramNumber, scratchpad, sharedData ) => {\n\n    // unlink the Property listener that was logging the new value to the console\n    scratchpad.linkId = phet.paperLand.removeModelPropertyLink( 'radioProperty', scratchpad.linkId );\n    delete scratchpad.linkId;\n\n    // remove the Property from the model\n    phet.paperLand.removeModelComponent( 'radioProperty' );\n\n    // we are done with our Property controller function\n    delete scratchpad.handleMarkersChanged;\n  };\n\n  // Called whenever a marker is added to the program\n  const onProgramMarkersAdded = ( programNumber, programPoints, scratchpad, sharedData, currentMarkers ) => {\n    scratchpad.handleMarkersChanged( currentMarkers );\n  };\n\n  // Called whenever a marker is removed from the program\n  const onProgramMarkersRemoved = ( programNumber, programPoints, scratchpad, sharedData, currentMarkers ) => {\n    scratchpad.handleMarkersChanged( currentMarkers );\n  };\n\n  // Add the state change handler defined above as data for this paper.\n  await paper.set('data', {\n    paperPlaygroundData: {\n      updateTime: Date.now(),\n      eventHandlers: {\n        onProgramAdded: onProgramAdded.toString(),\n        onProgramRemoved: onProgramRemoved.toString(),\n        onProgramMarkersAdded: onProgramMarkersAdded.toString(),\n        onProgramMarkersRemoved: onProgramMarkersRemoved.toString()\n      }\n    }\n  } );\n\n  //----------------------------------------------------------------------\n  // Projector code\n  //----------------------------------------------------------------------\n\n  const canvas = await paper.get('canvas');\n\n  // Draw \"Hello world\" on the canvas.\n  const ctx = canvas.getContext('2d');\n  ctx.font = '20px sans-serif';\n  ctx.textAlign = 'center';\n  ctx.fillStyle = 'rgb(255,0,0)';\n  ctx.fillText('Toggle', canvas.width / 2, canvas.height / 2 - 10);\n})();\n\n",
  "currentCode": "// Radio Group - Markers\n// Keywords: radio, buttons, markers, example, voicing\n// =============================== //\n// Program Dependencies: N/A\n// Recommended Programs:\n// Program Description: Creates a \"radio group\" that lets user select a value from a number of values. The\n//                      number of markers controls the value. 0 markers sets to first value, 1 markers sets\n//                      to second value, and so on.                                \n\nimportScripts('paper.js');\n\n(async () => {\n\n  //----------------------------------------------------------------------\n  // Board code\n  //----------------------------------------------------------------------\n\n  // Get the paper number of this piece of paper (which should not change).\n  const myPaperNumber = await paper.get('number');\n\n  // Called when the program is detected or changed.\n  const onProgramAdded = ( paperProgramNumber, scratchpad, sharedData ) => {\n\n    // Values for the group. This list can have any number of values. The values of \n    // this example are strings, but they can be any kind of type. They must all\n    // be different.\n    const values = [\n      'VALUE_A',\n      'VALUE_B',\n      'VALUE_C',\n      'VALUE_D'\n    ];\n\n    // Create an axon.Property for the model that any program can observe and control.\n    phet.paperLand.addModelComponent( 'radioProperty', new phet.axon.Property( values[ 0 ] ) );\n\n    // This is the function we want to call whenever a marker is added or removed from the program. You\n    // could copy/paste the body of this function right into onProgramMarkersAdded/Removed functions,\n    // but it is created once here and assigned to the scratchpad to avoid code duplication. The function\n    // takes a single argument, the current number of markers contained in the program.\n    scratchpad.handleMarkersChanged = currentMarkers => {\n\n      // If the model doesn't have the Property we created when the program was added,\n      // something went wrong and this function will fail!\n      if ( !sharedData.model.has( 'radioProperty' ) ) {\n        phet.paperLand.console.error( 'radioProperty does not exist in the model!' );\n        return;\n      }\n\n      // get a reference to the Property now that we know it exists\n      const radioProperty = sharedData.model.get( 'radioProperty' );\n\n      // The number of markers control the current value.\n      const numberOfMarkers = currentMarkers.length;\n      if ( numberOfMarkers < values.length ) {\n        radioProperty.value = values[ numberOfMarkers ];\n      }\n      else {\n        \n        // There are more markers in the program than there are values, just set to the last\n        // possible value\n        radioProperty.value = values[ values.length - 1 ];\n      }\n    }\n\n    // Observe the changing Property - this function just prints the new value to the console, but\n    // you could do anything in this function or put this function in a different program. addModelPropertyLink\n    // returns a uniqueID which is saved to the scratchpad so it can be easily unlinked later.\n    scratchpad.linkId = phet.paperLand.addModelPropertyLink( 'radioProperty', value => {\n      phet.paperLand.console.warn( `New radio value: ${value}` );\n\n\n    } );\n  };\n\n  // Called when the program is changed or no longer detected.\n  const onProgramRemoved = ( paperProgramNumber, scratchpad, sharedData ) => {\n\n    // unlink the Property listener that was logging the new value to the console\n    scratchpad.linkId = phet.paperLand.removeModelPropertyLink( 'radioProperty', scratchpad.linkId );\n    delete scratchpad.linkId;\n\n    // remove the Property from the model\n    phet.paperLand.removeModelComponent( 'radioProperty' );\n\n    // we are done with our Property controller function\n    delete scratchpad.handleMarkersChanged;\n  };\n\n  // Called whenever a marker is added to the program\n  const onProgramMarkersAdded = ( programNumber, programPoints, scratchpad, sharedData, currentMarkers ) => {\n    scratchpad.handleMarkersChanged( currentMarkers );\n  };\n\n  // Called whenever a marker is removed from the program\n  const onProgramMarkersRemoved = ( programNumber, programPoints, scratchpad, sharedData, currentMarkers ) => {\n    scratchpad.handleMarkersChanged( currentMarkers );\n  };\n\n  // Add the state change handler defined above as data for this paper.\n  await paper.set('data', {\n    paperPlaygroundData: {\n      updateTime: Date.now(),\n      eventHandlers: {\n        onProgramAdded: onProgramAdded.toString(),\n        onProgramRemoved: onProgramRemoved.toString(),\n        onProgramMarkersAdded: onProgramMarkersAdded.toString(),\n        onProgramMarkersRemoved: onProgramMarkersRemoved.toString()\n      }\n    }\n  } );\n\n  //----------------------------------------------------------------------\n  // Projector code\n  //----------------------------------------------------------------------\n\n  const canvas = await paper.get('canvas');\n\n  // Draw \"Hello world\" on the canvas.\n  const ctx = canvas.getContext('2d');\n  ctx.font = '20px sans-serif';\n  ctx.textAlign = 'center';\n  ctx.fillStyle = 'rgb(255,0,0)';\n  ctx.fillText('Toggle', canvas.width / 2, canvas.height / 2 - 10);\n})();\n\n",
  "printed": false,
  "editorInfo": {},
  "currentCodeUrl": "program.simple-demos.298.js",
  "currentCodeHash": "",
  "debugUrl": "/api/spaces/simple-demos/programs/298/debugInfo",
  "claimUrl": "/api/spaces/simple-demos/programs/298/claim",
  "codeHasChanged": false,
  "debugInfo": "{\"logs\":[]}"
}