{
  "number": 1282,
  "originalCode": "// Print Voicing\n// Keywords: simple, view, voicing, text\n// =============================== //\n// Program Dependencies: N/A\n// Recommended Programs: N/A\n// Program Description: Prints any speech from Voicing as it is spoken with phet.scenery.voicingUtteranceQueue.\n\nimportScripts('paper.js');\n\n(async () => {\n\n  //----------------------------------------------------------------------\n  // Board code\n  //----------------------------------------------------------------------\n\n  // Called when the program is detected or changed.\n  const onProgramAdded = ( paperProgramNumber, scratchpad, sharedData ) => {\n\n    //=================================================================================================================\n    // Easily Changed Parameters\n    const textColor = 'rgb(197,76,134)';\n    const fontSize = 20;\n    const lineWrap = 600; // length of each line before wrapping\n    const printCount = 5; // how many responses to print at a time\n    \n    //=================================================================================================================\n\n    // Create a VBox - a vertical scenery layout container for the text\n    const vBox = new phet.scenery.VBox( {\n      align: 'left',\n      spacing: 5\n    } );\n\n    // Add the container to the scene and the scratchpad.\n    sharedData.scene.addChild( vBox );\n    scratchpad.vBox = vBox;\n\n    // add a listener to scenery's voicingManager - whenever it starts speaking something,\n    // that gets printed to the board\n    scratchpad.startSpeakingListener = content => {\n      \n      // create the text to be added\n      const textContent = new phet.scenery.RichText( content, {\n        font: new phet.scenery.Font( {\n          size: fontSize\n        } ),\n        fill: textColor,\n        lineWrap: lineWrap\n      } );\n\n      // add the text to the layout container\n      vBox.addChild( textContent );\n\n      // vBox puts new children at the end of the list. We want the most recent\n      // text at the top. Moving new child to back of graph will put at top of VBox.\n      textContent.moveToBack();\n\n      // remove the oldest text, keeping the desired amount of content\n      while( vBox.children.length > printCount ) {\n        vBox.removeChild( vBox.children[ vBox.children.length - 1 ] );\n      }\n    }\n    phet.scenery.voicingManager.startSpeakingEmitter.addListener( scratchpad.startSpeakingListener );\n  };\n\n  const onProgramChangedPosition = ( paperProgramNumber, positionPoints, scratchpad, sharedData ) => {\n\n    if ( scratchpad.vBox ){\n\n      // Center the layout container based on the position of the paper.\n      const paperCenterX = ( positionPoints[0].x + positionPoints[1].x ) / 2;\n      const paperCenterY = ( positionPoints[0].y + positionPoints[2].y ) / 2;\n      scratchpad.vBox.centerX = paperCenterX * sharedData.displaySize.width;\n      scratchpad.vBox.centerY = paperCenterY * sharedData.displaySize.height;\n    }\n  };\n\n  // Called when the program is changed or no longer detected.\n  const onProgramRemoved = ( paperProgramNumber, scratchpad, sharedData ) => {\n    phet.scenery.voicingManager.startSpeakingEmitter.removeListener( scratchpad.startSpeakingListener );\n\n    sharedData.scene.removeChild( scratchpad.vBox );\n    delete scratchpad.vBox;\n  };\n\n  // Add the state change handler defined above as data for this paper.\n  await paper.set('data', {\n    paperPlaygroundData: {\n      updateTime: Date.now(),\n      eventHandlers: {\n        onProgramAdded: onProgramAdded.toString(),\n        onProgramChangedPosition: onProgramChangedPosition.toString(),\n        onProgramRemoved: onProgramRemoved.toString()\n      }\n    }\n  } );\n\n  //----------------------------------------------------------------------\n  // Projector code\n  //----------------------------------------------------------------------\n\n  const canvas = await paper.get('canvas');\n\n  // Draw a message on the canvas.\n  const ctx = canvas.getContext('2d');\n  ctx.font = '20px sans-serif';\n  ctx.textAlign = 'center';\n  ctx.fillStyle = 'rgb(255,0,0)';\n  ctx.fillText('Show', canvas.width / 2, canvas.height / 2 - 10);\n  ctx.fillStyle = 'rgb(0,255,0)';\n  ctx.fillText('Text', canvas.width / 2, canvas.height / 2 + 20);\n})();\n\n\n",
  "currentCode": "// Print Voicing\n// Keywords: simple, view, voicing, text\n// =============================== //\n// Program Dependencies: N/A\n// Recommended Programs: N/A\n// Program Description: Prints any speech from Voicing as it is spoken with phet.scenery.voicingUtteranceQueue.\n\nimportScripts('paper.js');\n\n(async () => {\n\n  //----------------------------------------------------------------------\n  // Board code\n  //----------------------------------------------------------------------\n\n  // Called when the program is detected or changed.\n  const onProgramAdded = ( paperProgramNumber, scratchpad, sharedData ) => {\n\n    //=================================================================================================================\n    // Easily Changed Parameters\n    const textColor = 'rgb(197,76,134)';\n    const fontSize = 20;\n    const lineWrap = 600; // length of each line before wrapping\n    const printCount = 5; // how many responses to print at a time\n    \n    //=================================================================================================================\n\n    // Create a VBox - a vertical scenery layout container for the text\n    const vBox = new phet.scenery.VBox( {\n      align: 'left',\n      spacing: 5\n    } );\n\n    // Add the container to the scene and the scratchpad.\n    sharedData.scene.addChild( vBox );\n    scratchpad.vBox = vBox;\n\n    // add a listener to scenery's voicingManager - whenever it starts speaking something,\n    // that gets printed to the board\n    scratchpad.startSpeakingListener = content => {\n      \n      // create the text to be added\n      const textContent = new phet.scenery.RichText( content, {\n        font: new phet.scenery.Font( {\n          size: fontSize\n        } ),\n        fill: textColor,\n        lineWrap: lineWrap\n      } );\n\n      // add the text to the layout container\n      vBox.addChild( textContent );\n\n      // vBox puts new children at the end of the list. We want the most recent\n      // text at the top. Moving new child to back of graph will put at top of VBox.\n      textContent.moveToBack();\n\n      // remove the oldest text, keeping the desired amount of content\n      while( vBox.children.length > printCount ) {\n        vBox.removeChild( vBox.children[ vBox.children.length - 1 ] );\n      }\n    }\n    phet.scenery.voicingManager.startSpeakingEmitter.addListener( scratchpad.startSpeakingListener );\n  };\n\n  const onProgramChangedPosition = ( paperProgramNumber, positionPoints, scratchpad, sharedData ) => {\n\n    if ( scratchpad.vBox ){\n\n      // Center the layout container based on the position of the paper.\n      const paperCenterX = ( positionPoints[0].x + positionPoints[1].x ) / 2;\n      const paperCenterY = ( positionPoints[0].y + positionPoints[2].y ) / 2;\n      scratchpad.vBox.centerX = paperCenterX * sharedData.displaySize.width;\n      scratchpad.vBox.centerY = paperCenterY * sharedData.displaySize.height;\n    }\n  };\n\n  // Called when the program is changed or no longer detected.\n  const onProgramRemoved = ( paperProgramNumber, scratchpad, sharedData ) => {\n    phet.scenery.voicingManager.startSpeakingEmitter.removeListener( scratchpad.startSpeakingListener );\n\n    sharedData.scene.removeChild( scratchpad.vBox );\n    delete scratchpad.vBox;\n  };\n\n  // Add the state change handler defined above as data for this paper.\n  await paper.set('data', {\n    paperPlaygroundData: {\n      updateTime: Date.now(),\n      eventHandlers: {\n        onProgramAdded: onProgramAdded.toString(),\n        onProgramChangedPosition: onProgramChangedPosition.toString(),\n        onProgramRemoved: onProgramRemoved.toString()\n      }\n    }\n  } );\n\n  //----------------------------------------------------------------------\n  // Projector code\n  //----------------------------------------------------------------------\n\n  const canvas = await paper.get('canvas');\n\n  // Draw a message on the canvas.\n  const ctx = canvas.getContext('2d');\n  ctx.font = '20px sans-serif';\n  ctx.textAlign = 'center';\n  ctx.fillStyle = 'rgb(255,0,0)';\n  ctx.fillText('Show', canvas.width / 2, canvas.height / 2 - 10);\n  ctx.fillStyle = 'rgb(0,255,0)';\n  ctx.fillText('Text', canvas.width / 2, canvas.height / 2 + 20);\n})();\n\n\n",
  "printed": false,
  "editorInfo": {},
  "currentCodeUrl": "program.simple-demos.1282.js",
  "currentCodeHash": "",
  "debugUrl": "/api/spaces/simple-demos/programs/1282/debugInfo",
  "claimUrl": "/api/spaces/simple-demos/programs/1282/claim",
  "codeHasChanged": false,
  "debugInfo": "{\"logs\":[]}"
}