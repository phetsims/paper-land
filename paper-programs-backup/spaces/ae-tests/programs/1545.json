{
  "number": 1545,
  "originalCode": "// Line Drawing\n// Keywords: simple, view, background, color\n// =============================== //\n// Program Dependencies: N/A\n// Recommended Programs: n/a\n// Program Description: Shape testing\n\nimportScripts('paper.js');\n\n(async () => {\n\n// some notes 06.09.23\n// it would probably make sense for a slider object (parameterized 0 to 1)\n// sitting on top of this program to scale the corresponding shape.\n// initialize the shape to be a set percentage of the display window\n// and then at slider = 1, shape is full size of display window.\n\n\n  const onProgramAdded = ( paperProgramNumber, scratchpad, sharedData ) => {\nscratchpad.lineEndpoint1x = 0;\nscratchpad.lineEndpoint1y = 0;\nscratchpad.lineEndpoint2x = 0;\nscratchpad.lineEndpoint2y = 0;\n\n  // really should put this on scratchpad to remove later but this is a quick test\n //   scene.addChild( new phet.scenery.Line( 8, 8, 56, 56, {\n // stroke: 'red', lineWidth: 5, lineCap: 'round'\n // } ) );\n  };\n\n  const onProgramChangedPosition = ( paperProgramNumber, positionPoints, scratchPad, sharedData ) => {\n          // these values are normalized within the camera window\n      phet.paperLand.console.log( 'test' );\n      \n// Find the initial paper size, and the initial radius of the circle.\n  const initialPaperWidth = positionPoints[ 2 ].x - positionPoints[ 0 ].x;\n  const initialPaperHeight = positionPoints[ 2 ].y - positionPoints[ 0 ].y;\n  const initialPaperArea = initialPaperWidth * initialPaperHeight;\n  phet.paperLand.console.log( 'initialPaperArea: ', initialPaperArea);\n\n      \n      \n      const paperWidth = positionPoints[ 2 ].x - positionPoints[ 0 ].x;\n      const paperHeight = positionPoints[ 2 ].y - positionPoints[ 0 ].y;\n      const area = paperWidth * paperHeight;\n      phet.paperLand.console.log( 'width: ', paperWidth);\n      phet.paperLand.console.log( 'height: ', paperHeight );\n     // if ( scratchpad.backgroundRectangle ){\n      //sharedData.scene.removeChild( scratchpad.backgroundRectangle );\n      //scratchpad.backgroundRectangle = null;\n   // }\n };\n\n  const onProgramMarkersAdded = ( programNumber, programPoints, scratchpad, sharedData, currentMarkers ) => {\n    //scratchpad.printColorCounts( currentMarkers );\n\n  };\n\n  const onProgramMarkersRemoved = ( programNumber, programPoints, scratchpad, sharedData, currentMarkers ) => {\n    //scratchpad.printColorCounts( currentMarkers );\n  };\n\n  const onProgramMarkersChangedPosition = ( programNumber, programPoints, scratchpad, sharedData, currentMarkers ) => {\n    //if there's only a single marker, the line is \"anchored\" at the upper left (0,0)\n\n    phet.paperLand.console.log('inside onProgramMarkersChangedPosition');\n    const firstMarker = currentMarkers[0];\n    if (firstMarker){\n      scratchpad.lineEndpoint1x = sharedData.displaySize.width * firstMarker.positionOnPaper.x;\n      scratchpad.lineEndpoint1y = sharedData.displaySize.height * firstMarker.positionOnPaper.y;\n      phet.paperLand.console.log('lineEndpoint1x is', scratchpad.lineEndpoint1x);\n    };\n\n    const secondMarker = currentMarkers[1];\n    if (secondMarker){\n      scratchpad.lineEndpoint2x = sharedData.displaySize.width * secondMarker.positionOnPaper.x;\n      scratchpad.lineEndpoint2y = sharedData.displaySize.height * secondMarker.positionOnPaper.y;\n      //phet.paperLand.console.log('lineEndpoint1x is', scratchpad.lineEndpoint1x);\n    };\n\n    // get the color of the line\n    const model = sharedData.model;\n    if ( model.has( 'lineColorProperty' ) ) {\n      //phet.paperLand.console.log('inside circleColorProperty in prog 1859');\n      scratchpad.lineColor = model.get( 'lineColorProperty' );\n      //phet.paperLand.console.log('line 118, prog 1859', scratchpad.circleColor);\n      //phet.paperLand.console.log('current circle color is', circleColorProperty.value);\n    }\n\n    if ( scratchpad.testLine ){\n    sharedData.scene.removeChild( scratchpad.testLine );\n    };\n    scratchpad.testLine = new phet.scenery.Line( scratchpad.lineEndpoint1x, scratchpad.lineEndpoint1y, scratchpad.lineEndpoint2x, scratchpad.lineEndpoint2y, {stroke: scratchpad.lineColor, lineWidth:5, lineCap:'round'\n    } );\n    sharedData.scene.addChild(scratchpad.testLine );\n\n  };\n\n  // Called when the program is removed.\n  const onProgramRemoved = ( paperProgramNumber, scratchpad, sharedData ) => {\n    // add cleanup here\n    if ( scratchpad.testLine ){\n    sharedData.scene.removeChild( scratchpad.testLine );\n    };\n  };\n\n  // Add the state change handler defined above as data for this paper.\n  await paper.set('data', {\n    paperPlaygroundData: {\n      updateTime: Date.now(),\n      eventHandlers: {\n        onProgramAdded: onProgramAdded.toString(),\n        onProgramChangedPosition: onProgramChangedPosition.toString(),\n        onProgramRemoved: onProgramRemoved.toString(),\n        onProgramMarkersAdded: onProgramMarkersAdded.toString(),\n        onProgramMarkersRemoved: onProgramMarkersRemoved.toString(),\n        onProgramMarkersChangedPosition: onProgramMarkersChangedPosition.toString(),\n      }\n    }\n  } );\n\n  // Get a canvas object for this paper.\n  const canvas = await paper.get('canvas');\n\n  // Add text to the canvas.\n  const ctx = canvas.getContext('2d');\n  ctx.font = '20px sans-serif';\n  ctx.textAlign = 'center';\n  ctx.fillStyle = 'rgb(255,0,0)';\n  ctx.fillText('Add', canvas.width / 2, canvas.height / 2 - 10);\n  ctx.fillStyle = 'rgb(0,255,0)';\n  ctx.fillText('Background', canvas.width / 2, canvas.height / 2 + 20);\n})();\n\n\n\n\n\n\n",
  "currentCode": "// Line Drawing\n// Keywords: simple, view, background, color\n// =============================== //\n// Program Dependencies: N/A\n// Recommended Programs: n/a\n// Program Description: Shape testing\n\nimportScripts('paper.js');\n\n(async () => {\n\n// some notes 06.09.23\n// it would probably make sense for a slider object (parameterized 0 to 1)\n// sitting on top of this program to scale the corresponding shape.\n// initialize the shape to be a set percentage of the display window\n// and then at slider = 1, shape is full size of display window.\n\n\n  const onProgramAdded = ( paperProgramNumber, scratchpad, sharedData ) => {\nscratchpad.lineEndpoint1x = 0;\nscratchpad.lineEndpoint1y = 0;\nscratchpad.lineEndpoint2x = 0;\nscratchpad.lineEndpoint2y = 0;\n\n  // really should put this on scratchpad to remove later but this is a quick test\n //   scene.addChild( new phet.scenery.Line( 8, 8, 56, 56, {\n // stroke: 'red', lineWidth: 5, lineCap: 'round'\n // } ) );\n  };\n\n  const onProgramChangedPosition = ( paperProgramNumber, positionPoints, scratchPad, sharedData ) => {\n          // these values are normalized within the camera window\n      phet.paperLand.console.log( 'test' );\n      \n// Find the initial paper size, and the initial radius of the circle.\n  const initialPaperWidth = positionPoints[ 2 ].x - positionPoints[ 0 ].x;\n  const initialPaperHeight = positionPoints[ 2 ].y - positionPoints[ 0 ].y;\n  const initialPaperArea = initialPaperWidth * initialPaperHeight;\n  phet.paperLand.console.log( 'initialPaperArea: ', initialPaperArea);\n\n      \n      \n      const paperWidth = positionPoints[ 2 ].x - positionPoints[ 0 ].x;\n      const paperHeight = positionPoints[ 2 ].y - positionPoints[ 0 ].y;\n      const area = paperWidth * paperHeight;\n      phet.paperLand.console.log( 'width: ', paperWidth);\n      phet.paperLand.console.log( 'height: ', paperHeight );\n     // if ( scratchpad.backgroundRectangle ){\n      //sharedData.scene.removeChild( scratchpad.backgroundRectangle );\n      //scratchpad.backgroundRectangle = null;\n   // }\n };\n\n  const onProgramMarkersAdded = ( programNumber, programPoints, scratchpad, sharedData, currentMarkers ) => {\n    //scratchpad.printColorCounts( currentMarkers );\n\n  };\n\n  const onProgramMarkersRemoved = ( programNumber, programPoints, scratchpad, sharedData, currentMarkers ) => {\n    //scratchpad.printColorCounts( currentMarkers );\n  };\n\n  const onProgramMarkersChangedPosition = ( programNumber, programPoints, scratchpad, sharedData, currentMarkers ) => {\n    //if there's only a single marker, the line is \"anchored\" at the upper left (0,0)\n\n    phet.paperLand.console.log('inside onProgramMarkersChangedPosition');\n    const firstMarker = currentMarkers[0];\n    if (firstMarker){\n      scratchpad.lineEndpoint1x = sharedData.displaySize.width * firstMarker.positionOnPaper.x;\n      scratchpad.lineEndpoint1y = sharedData.displaySize.height * firstMarker.positionOnPaper.y;\n      phet.paperLand.console.log('lineEndpoint1x is', scratchpad.lineEndpoint1x);\n    };\n\n    const secondMarker = currentMarkers[1];\n    if (secondMarker){\n      scratchpad.lineEndpoint2x = sharedData.displaySize.width * secondMarker.positionOnPaper.x;\n      scratchpad.lineEndpoint2y = sharedData.displaySize.height * secondMarker.positionOnPaper.y;\n      //phet.paperLand.console.log('lineEndpoint1x is', scratchpad.lineEndpoint1x);\n    };\n\n    // get the color of the line\n    const model = sharedData.model;\n    if ( model.has( 'lineColorProperty' ) ) {\n      //phet.paperLand.console.log('inside circleColorProperty in prog 1859');\n      scratchpad.lineColor = model.get( 'lineColorProperty' );\n      //phet.paperLand.console.log('line 118, prog 1859', scratchpad.circleColor);\n      //phet.paperLand.console.log('current circle color is', circleColorProperty.value);\n    }\n\n    if ( scratchpad.testLine ){\n    sharedData.scene.removeChild( scratchpad.testLine );\n    };\n    scratchpad.testLine = new phet.scenery.Line( scratchpad.lineEndpoint1x, scratchpad.lineEndpoint1y, scratchpad.lineEndpoint2x, scratchpad.lineEndpoint2y, {stroke: scratchpad.lineColor, lineWidth:5, lineCap:'round'\n    } );\n    sharedData.scene.addChild(scratchpad.testLine );\n\n  };\n\n  // Called when the program is removed.\n  const onProgramRemoved = ( paperProgramNumber, scratchpad, sharedData ) => {\n    // add cleanup here\n    if ( scratchpad.testLine ){\n    sharedData.scene.removeChild( scratchpad.testLine );\n    };\n  };\n\n  // Add the state change handler defined above as data for this paper.\n  await paper.set('data', {\n    paperPlaygroundData: {\n      updateTime: Date.now(),\n      eventHandlers: {\n        onProgramAdded: onProgramAdded.toString(),\n        onProgramChangedPosition: onProgramChangedPosition.toString(),\n        onProgramRemoved: onProgramRemoved.toString(),\n        onProgramMarkersAdded: onProgramMarkersAdded.toString(),\n        onProgramMarkersRemoved: onProgramMarkersRemoved.toString(),\n        onProgramMarkersChangedPosition: onProgramMarkersChangedPosition.toString(),\n      }\n    }\n  } );\n\n  // Get a canvas object for this paper.\n  const canvas = await paper.get('canvas');\n\n  // Add text to the canvas.\n  const ctx = canvas.getContext('2d');\n  ctx.font = '20px sans-serif';\n  ctx.textAlign = 'center';\n  ctx.fillStyle = 'rgb(255,0,0)';\n  ctx.fillText('Add', canvas.width / 2, canvas.height / 2 - 10);\n  ctx.fillStyle = 'rgb(0,255,0)';\n  ctx.fillText('Background', canvas.width / 2, canvas.height / 2 + 20);\n})();\n\n\n\n\n\n\n",
  "printed": false,
  "editorInfo": {},
  "currentCodeUrl": "program.ae-tests.1545.js",
  "currentCodeHash": "",
  "debugUrl": "/api/spaces/ae-tests/programs/1545/debugInfo",
  "claimUrl": "/api/spaces/ae-tests/programs/1545/claim",
  "codeHasChanged": false,
  "debugInfo": "{\"logs\":[]}"
}