{
  "number": 9,
  "originalCode": "// Paper Elements Game Model\n// Keywords: \n// Description: \n\nimportScripts('paper.js');\n\n(async () => {\n\n  const onProgramAdded = ( paperNumber, scratchpad, sharedData ) => {\n    \n      const IsP1Winner = new phet.axon.BooleanProperty(false);\n      phet.paperLand.addModelComponent( 'IsP1Winner', IsP1Winner );\n    \n\n      const IsP2Winner = new phet.axon.BooleanProperty(false);\n      phet.paperLand.addModelComponent( 'IsP2Winner', IsP2Winner );\n    \n\n      const playArea = new phet.axon.Property(\n        new phet.dot.Bounds2( 0.3, 0, 0.66, 1 )\n      );\n      phet.paperLand.addModelComponent( 'playArea', playArea );\n    \n\n      const p1CardArrayAddedItem = new phet.axon.Property( null );\n      phet.paperLand.addModelComponent( 'p1CardArrayAddedItem', p1CardArrayAddedItem );\n    \n\n      const p1CardArrayRemovedItem = new phet.axon.Property( null );\n      phet.paperLand.addModelComponent( 'p1CardArrayRemovedItem', p1CardArrayRemovedItem );\n    \n\n      const p2CardArrayAddedItem = new phet.axon.Property( null );\n      phet.paperLand.addModelComponent( 'p2CardArrayAddedItem', p2CardArrayAddedItem );\n    \n\n      const p2CardArrayRemovedItem = new phet.axon.Property( null );\n      phet.paperLand.addModelComponent( 'p2CardArrayRemovedItem', p2CardArrayRemovedItem );\n    \n\n      const p1CardArray = new phet.axon.Property( [] );\n      phet.paperLand.addModelComponent( 'p1CardArray', p1CardArray );\n    \n\n      const p2CardArray = new phet.axon.Property( [] );\n      phet.paperLand.addModelComponent( 'p2CardArray', p2CardArray );\n    \n\n      // DerivedProperties are actually implemented with Multilink for now because paper-land has a nice abstraction\n      // for it.\n      const p1CardArrayLength = new phet.axon.Property( null );\n      scratchpad.p1CardArrayLengthDerivedPropertyObserverId = phet.paperLand.addModelPropertyMultilink( [ 'p1CardArray' ], ( p1CardArray ) => {\n        const derivationFunction = () => {\n        \n          // should return a value based on the dependencies\n          return p1CardArray.length;\n        };\n        p1CardArrayLength.value = derivationFunction();\n      } );\n      phet.paperLand.addModelComponent( 'p1CardArrayLength', p1CardArrayLength );\n    \n\n      // DerivedProperties are actually implemented with Multilink for now because paper-land has a nice abstraction\n      // for it.\n      const p2CardArrayLength = new phet.axon.Property( null );\n      scratchpad.p2CardArrayLengthDerivedPropertyObserverId = phet.paperLand.addModelPropertyMultilink( [ 'p2CardArray' ], ( p2CardArray ) => {\n        const derivationFunction = () => {\n        \n          // should return a value based on the dependencies\n          return p2CardArray.length;\n        };\n        p2CardArrayLength.value = derivationFunction();\n      } );\n      phet.paperLand.addModelComponent( 'p2CardArrayLength', p2CardArrayLength );\n    \n\n      const winningSoundWrappedAudioBuffer = createAndLoadWrappedAudioBuffer( 'media/sounds/short-success.mp3' );\n      const winningSoundSoundClip = new phet.tambo.SoundClip( winningSoundWrappedAudioBuffer, {\n        loop: false,\n        initialOutputLevel: 0.5\n       } );\n      phet.tambo.soundManager.addSoundGenerator( winningSoundSoundClip );\n      scratchpad.winningSoundWrappedAudioBuffer = winningSoundWrappedAudioBuffer;\n      \n      let winningSoundStopSoundTimeout = null;\n      \n      // as a safety measure, sound can only be played every 0.25 seconds - initial value is very small\n      // so that it can be played immediately\n      let winningSoundLastPlayTime = 0;\n      \n      // The listener that will observe the model and play sounds is added as soon as the sounds are loaded, and\n      // added to the scratch pad so that it can be removed later.\n      scratchpad.winningSoundWrappedAudioBufferListener = _buffer => {\n        if ( _buffer ) {\n        \n          // Play the sound when any dependencies change value.\n          scratchpad.winningSoundSoundMultilinkId = phet.paperLand.addModelPropertyMultilink( [ 'IsP1Winner', 'IsP2Winner' ], ( IsP1Winner, IsP2Winner ) => {\n            \n            // in a local scope, define the functions that the user can use to manipulate the sound\n            const setOutputLevel = ( level ) => {\n            \n              // As a safety measure, don't let the user set a level below zero and above 2.\n              const outputLevel = Math.max( 0, Math.min( 2, level ) );\n              winningSoundSoundClip.outputLevel = outputLevel;\n            };\n            const setPlaybackRate = ( rate ) => {\n            \n              // As a safety measure, the playback rate cannot go below zero.\n              const playbackRate = Math.max( 0, rate );\n              winningSoundSoundClip.setPlaybackRate( playbackRate );\n            };\n            \n            // a function the user can call to play the sound\n            const play = () => {\n            \n              // Play the sound - if looping, we don't want to start playing again if already playing. The sound\n              // can only be played at a limited interval for safety.\n              if ( ( !winningSoundSoundClip.isPlaying || !false ) && phet.paperLand.elapsedTimeProperty.value - winningSoundLastPlayTime > 0.25 ) {\n      \n                // only start playing again if it has been stopped - but we still enter this block to update\n                // the last play time and timeouts        \n                if ( !winningSoundSoundClip.isPlaying ) {\n                  winningSoundSoundClip.play();\n                }\n                winningSoundLastPlayTime = phet.paperLand.elapsedTimeProperty.value;\n                \n                // Set a timer to turn off the sound when the value stops changing.\n                if ( winningSoundStopSoundTimeout ){\n                  window.clearTimeout( winningSoundStopSoundTimeout );\n                }\n                \n                // only stop if not looping\n                if ( !false ) {\n                  winningSoundStopSoundTimeout = window.setTimeout( () => {\n                    winningSoundSoundClip.stop();\n                  }, 5000 );\n                }  \n              }\n            };\n            \n            const stop = () => {\n              // Set a timer to turn off the sound when the value stops changing.\n              if ( winningSoundStopSoundTimeout ){\n                window.clearTimeout( winningSoundStopSoundTimeout );\n              }\n              winningSoundSoundClip.stop();\n            };\n            \n            if ( false ) {\n              play();\n            }\n            \n            // declare the references so that they can be used in the control function\n            \n          \n            setOutputLevel(1);\n\nif ( IsP1Winner || IsP2Winner ) {\n    play();\n    phet.paperLand.console.log(\"Someone Won!\");\n}\n          }, {\n            otherReferences: [  ],\n          } );  \n        }\n      };     \n      scratchpad.winningSoundWrappedAudioBuffer.audioBufferProperty.link( scratchpad.winningSoundWrappedAudioBufferListener );\n      \n      // Assign the sound to the scratchpad so that we can remove it later\n      scratchpad.winningSoundSoundClip = winningSoundSoundClip;\n    \n\n      // Create an image and add it to the view.\n      let playAreaImageImageElement = document.createElement( 'img' );\n      playAreaImageImageElement.src = 'media/images/fantasy-card-mat.jpg';\n      const playAreaImageImage = new phet.scenery.Image( playAreaImageImageElement );\n\n      // As soon as the image loads, update a Property added to the multilink so that the control\n      // function is called again to update the positioning.       \n      const playAreaImageImageLoadProperty = new phet.axon.Property( 0 );\n      playAreaImageImageElement.addEventListener( 'load', () => { playAreaImageImageLoadProperty.value = playAreaImageImageLoadProperty.value + 1; } );\n      \n      sharedData.scene.addChild( playAreaImageImage );\n      scratchpad.playAreaImageImage = playAreaImageImage;\n      \n      // Update the image when a dependency changes, and redraw if the board resizes. This is async because\n      // function in the control function might be async to support loading images.\n      scratchpad.playAreaImageImageMultilinkId = phet.paperLand.addModelPropertyMultilink( [ 'playArea' ], async ( playArea ) => {\n        \n        // the functions that are available for this view type\n        \n      const unitBoundsToDisplayBounds = ( bounds ) => {\n        return phet.paperLand.utils.paperToBoardBounds( bounds, sharedData.displaySize.width, sharedData.displaySize.height );\n      };\n      \n      const unitPositionToDisplayPosition = ( position ) => {\n        return phet.paperLand.utils.paperToBoardCoordinates( position, sharedData.displaySize.width, sharedData.displaySize.height );\n      };\n    \n      const setCenterX = ( x ) => {\n        playAreaImageImage.centerX = phet.paperLand.utils.paperToBoardX( x, sharedData.displaySize.width );\n      };\n      \n      const setCenterY = ( y ) => {\n        playAreaImageImage.centerY = phet.paperLand.utils.paperToBoardY( y, sharedData.displaySize.height );\n      };\n      \n      const setLeft = ( left ) => {\n        playAreaImageImage.left = phet.paperLand.utils.paperToBoardX( left, sharedData.displaySize.width );\n      };\n      \n      const setTop = ( top ) => {\n        playAreaImageImage.top = phet.paperLand.utils.paperToBoardY( top, sharedData.displaySize.height );\n      };\n      \n      const setScale = ( scale ) => {\n        playAreaImageImage.setScaleMagnitude( scale );\n      };\n      \n      const setOpacity = ( opacity ) => {\n        playAreaImageImage.opacity = opacity;\n      };\n      \n      const setVisible = ( visible ) => {\n        playAreaImageImage.visible = visible;\n      };\n      \n      const moveToFront = () => {\n        playAreaImageImage.moveToFront();\n      };\n      \n      const moveToBack = () => {\n        playAreaImageImage.moveToBack();\n      };\n      \n      const setRotation = ( rotation ) => {\n        playAreaImageImage.rotation = rotation;\n      };\n\n      // Set the scale in X and Y and the       \n      const matchBounds = ( bounds, stretch ) => {\n      \n        // Find the scale to apply to the x and y dimensions so that the component bounds match the provided bounds\n        const playAreaImageImageViewBounds = phet.paperLand.utils.paperToBoardBounds(bounds, sharedData.displaySize.width, sharedData.displaySize.height);\n\n        // local bounds may be zero as things load\n        // const aspectRatio = ( playAreaImageImage.localBounds.width || 1 ) / ( playAreaImageImage.localBounds.height || 1 );\n\n        const scaleX = playAreaImageImageViewBounds.width / ( playAreaImageImage.localBounds.width || 1 );\n        const scaleY = playAreaImageImageViewBounds.height / ( playAreaImageImage.localBounds.height || 1 );\n\n        if ( stretch ) {\n          playAreaImageImage.setScaleMagnitude(scaleX, scaleY);\n        }\n        else {\n        \n          // Scale by the minimum of the x and y scale factors, preserving the aspect ratio\n          playAreaImageImage.setScaleMagnitude( Math.min( scaleX, scaleY ) );\n        }        \n\n        // Now put the component in the center of the bounds\n        playAreaImageImage.center = playAreaImageImageViewBounds.center;\n      };\n      \n\n      \n        // This is async so that we can wait for the image to load before doing other things\n        const setImage = async imageName => {\n        \n          return new Promise( (resolve, reject) => {\n          \n            // Get the current image name relative to the local paper playground path\n            let currentImageName;\n            if ( playAreaImageImage.image ) {\n              const startIndex = playAreaImageImage.image.src.indexOf( 'media/images/' );\n              currentImageName = playAreaImageImage.image.src.substring( startIndex );\n            }\n            else {\n              currentImageName = '';\n            }\n            \n            const newImageName = 'media/images/' + imageName;\n            \n            // only update the image if there is a change\n            if ( currentImageName !== newImageName ) {\n              const playAreaImageImageImageElement = document.createElement( 'img' );\n              playAreaImageImageImageElement.src = newImageName;\n              playAreaImageImage.image = playAreaImageImageImageElement;\n\n              // Wait for the image to load before resolving              \n              playAreaImageImageImageElement.addEventListener( 'load', () => {\n                resolve();\n              } );\n            }\n            else {\n              \n              // No change, so resolve immediately\n              resolve();\n            }\n          } );\n        };\n      \n        \n        // bring in the reference components so they are available in the control function\n        \n      \n        matchBounds(playArea, true);\nmoveToBack();\n      }, {\n        otherProperties: [ phet.paperLand.displaySizeProperty, playAreaImageImageLoadProperty ],\n        otherReferences: [  ]\n      } );\n    \n\n\n      // Create a shape with kite.\n      const playAreaViewShape = phet.kite.Shape.rectangle( 0, 0, phet.paperLand.utils.paperToBoardX( 0.5, sharedData.displaySize.width ), phet.paperLand.utils.paperToBoardY( 0.5, sharedData.displaySize.height ) )\n      \n      // create a path for the shape\n      const playAreaViewPath = new phet.scenery.Path( playAreaViewShape, {\n        fill: 'transparent',\n        stroke: 'red',\n        lineWidth: 5,\n        \n        // if initial position is zero, do not set that explicitly because it will break shape points \n        centerX: ('model' === 'model' && undefined) ? phet.paperLand.utils.paperToBoardX( undefined, sharedData.displaySize.width ) : undefined,\n        centerY: ('model' === 'model' && undefined) ? phet.paperLand.utils.paperToBoardY( undefined, sharedData.displaySize.height) : undefined,\n        scale: 1,\n        rotation: 0,\n        opacity: 1\n      } );\n      \n      // assign to scratchpad so that we can remove it later\n      sharedData.scene.addChild( playAreaViewPath );\n      scratchpad.playAreaViewPath = playAreaViewPath;\n      \n      // Update the shape when a dependency changes.\n      scratchpad.playAreaViewPathMultilinkId = phet.paperLand.addModelPropertyMultilink( [ 'playArea' ], ( playArea ) => {\n      \n        // We have to recreate the shape every change (especially important for a resize) - this is done first though\n        // because the user control functions might change the shape further.\n        const playAreaViewShape = phet.kite.Shape.rectangle( 0, 0, phet.paperLand.utils.paperToBoardX( 0.5, sharedData.displaySize.width ), phet.paperLand.utils.paperToBoardY( 0.5, sharedData.displaySize.height ) )\n        scratchpad.playAreaViewPath.setShape( playAreaViewShape );\n        \n        // now mutate with options that might depend on the shape or layout changes (again, user might override this \n        // so do before the control function)\n        scratchpad.playAreaViewPath.mutate( {\n          // if initial position is zero, do not set that explicitly because it will break shape points \n          centerX: ('model' === 'model' && undefined) ? phet.paperLand.utils.paperToBoardX( undefined, sharedData.displaySize.width ) : undefined,\n          centerY: ('model' === 'model' && undefined) ? phet.paperLand.utils.paperToBoardY( undefined, sharedData.displaySize.height) : undefined,\n          scale: 1,\n          rotation: 0\n        } );\n      \n        // the functions that are available for this view type\n        \n      const unitBoundsToDisplayBounds = ( bounds ) => {\n        return phet.paperLand.utils.paperToBoardBounds( bounds, sharedData.displaySize.width, sharedData.displaySize.height );\n      };\n      \n      const unitPositionToDisplayPosition = ( position ) => {\n        return phet.paperLand.utils.paperToBoardCoordinates( position, sharedData.displaySize.width, sharedData.displaySize.height );\n      };\n    \n      const setCenterX = ( x ) => {\n        playAreaViewPath.centerX = phet.paperLand.utils.paperToBoardX( x, sharedData.displaySize.width );\n      };\n      \n      const setCenterY = ( y ) => {\n        playAreaViewPath.centerY = phet.paperLand.utils.paperToBoardY( y, sharedData.displaySize.height );\n      };\n      \n      const setLeft = ( left ) => {\n        playAreaViewPath.left = phet.paperLand.utils.paperToBoardX( left, sharedData.displaySize.width );\n      };\n      \n      const setTop = ( top ) => {\n        playAreaViewPath.top = phet.paperLand.utils.paperToBoardY( top, sharedData.displaySize.height );\n      };\n      \n      const setScale = ( scale ) => {\n        playAreaViewPath.setScaleMagnitude( scale );\n      };\n      \n      const setOpacity = ( opacity ) => {\n        playAreaViewPath.opacity = opacity;\n      };\n      \n      const setVisible = ( visible ) => {\n        playAreaViewPath.visible = visible;\n      };\n      \n      const moveToFront = () => {\n        playAreaViewPath.moveToFront();\n      };\n      \n      const moveToBack = () => {\n        playAreaViewPath.moveToBack();\n      };\n      \n      const setRotation = ( rotation ) => {\n        playAreaViewPath.rotation = rotation;\n      };\n\n      // Set the scale in X and Y and the       \n      const matchBounds = ( bounds, stretch ) => {\n      \n        // Find the scale to apply to the x and y dimensions so that the component bounds match the provided bounds\n        const playAreaViewPathViewBounds = phet.paperLand.utils.paperToBoardBounds(bounds, sharedData.displaySize.width, sharedData.displaySize.height);\n\n        // local bounds may be zero as things load\n        // const aspectRatio = ( playAreaViewPath.localBounds.width || 1 ) / ( playAreaViewPath.localBounds.height || 1 );\n\n        const scaleX = playAreaViewPathViewBounds.width / ( playAreaViewPath.localBounds.width || 1 );\n        const scaleY = playAreaViewPathViewBounds.height / ( playAreaViewPath.localBounds.height || 1 );\n\n        if ( stretch ) {\n          playAreaViewPath.setScaleMagnitude(scaleX, scaleY);\n        }\n        else {\n        \n          // Scale by the minimum of the x and y scale factors, preserving the aspect ratio\n          playAreaViewPath.setScaleMagnitude( Math.min( scaleX, scaleY ) );\n        }        \n\n        // Now put the component in the center of the bounds\n        playAreaViewPath.center = playAreaViewPathViewBounds.center;\n      };\n      \n\n        const setStroke = ( color ) => {\n          playAreaViewPath.stroke = color;\n        };\n        \n        const setLineWidth = ( width ) => {\n          playAreaViewPath.lineWidth = width;\n        };\n        \n        const setFill = ( color ) => {\n          playAreaViewPath.fill = color;\n        };\n        \n        // for a line\n        const setX1 = ( newX1 ) => {\n          x1 = phet.paperLand.utils.paperToBoardX( newX1, sharedData.displaySize.width );\n          playAreaViewPath.shape = phet.kite.Shape.lineSegment( x1, y1, x2, y2 );\n        };\n        \n        const setY1 = ( newY1 ) => {\n          y1 = phet.paperLand.utils.paperToBoardY( newY1, sharedData.displaySize.height );\n          playAreaViewPath.shape = phet.kite.Shape.lineSegment( x1, y1, x2, y2 );\n        };\n\n        const setX2 = ( newX2 ) => {\n          x2 = phet.paperLand.utils.paperToBoardX( newX2, sharedData.displaySize.width );\n          playAreaViewPath.shape = phet.kite.Shape.lineSegment( x1, y1, x2, y2 );\n        };\n        \n        const setY2 = ( newY2 ) => {\n          y2 = phet.paperLand.utils.paperToBoardY( newY2, sharedData.displaySize.height );\n          playAreaViewPath.shape = phet.kite.Shape.lineSegment( x1, y1, x2, y2 );\n        };\n        \n        // for a circle\n        const setRadius = ( radius ) => {\n          // since this is a Path and not a Circle, we need to recreate the shape\n          playAreaViewPath.shape = phet.kite.Shape.circle( phet.paperLand.utils.paperToBoardX( radius, sharedData.displaySize.width ) );\n        };\n        \n        // for a rectangle\n        const setRectBounds = ( bounds ) => {\n          const transformedBounds = unitBoundsToDisplayBounds( bounds );\n          playAreaViewPath.shape = phet.kite.Shape.bounds( transformedBounds );\n        };\n        \n        // for a polygon\n        const setPoints = ( points ) => {\n          const transformedPoints = points.map( thisPoint => unitPositionToDisplayPosition( thisPoint ) );\n          playAreaViewPath.shape = phet.kite.Shape.polygon( transformedPoints );\n        };\n        \n        // bring in the reference components so they are available in the control function\n        \n        \n        setRectBounds( playArea );\nmoveToFront();\n      }, {\n        otherProperties: [ phet.paperLand.displaySizeProperty ],\n        otherReferences: [  ]\n      } );\n    \n\n\n      // Create a shape with kite.\n      const isP1WinnerTruthTellerShape = phet.kite.Shape.circle( phet.paperLand.utils.paperToBoardX( 0.005, sharedData.displaySize.width ) )\n      \n      // create a path for the shape\n      const isP1WinnerTruthTellerPath = new phet.scenery.Path( isP1WinnerTruthTellerShape, {\n        fill: 'red',\n        stroke: 'red',\n        lineWidth: 1,\n        \n        // if initial position is zero, do not set that explicitly because it will break shape points \n        centerX: ('model' === 'model' && 0.01) ? phet.paperLand.utils.paperToBoardX( 0.01, sharedData.displaySize.width ) : 0.01,\n        centerY: ('model' === 'model' && 0.01) ? phet.paperLand.utils.paperToBoardY( 0.01, sharedData.displaySize.height) : 0.01,\n        scale: 1,\n        rotation: 0,\n        opacity: 1\n      } );\n      \n      // assign to scratchpad so that we can remove it later\n      sharedData.scene.addChild( isP1WinnerTruthTellerPath );\n      scratchpad.isP1WinnerTruthTellerPath = isP1WinnerTruthTellerPath;\n      \n      // Update the shape when a dependency changes.\n      scratchpad.isP1WinnerTruthTellerPathMultilinkId = phet.paperLand.addModelPropertyMultilink( [ 'IsP1Winner' ], ( IsP1Winner ) => {\n      \n        // We have to recreate the shape every change (especially important for a resize) - this is done first though\n        // because the user control functions might change the shape further.\n        const isP1WinnerTruthTellerShape = phet.kite.Shape.circle( phet.paperLand.utils.paperToBoardX( 0.005, sharedData.displaySize.width ) )\n        scratchpad.isP1WinnerTruthTellerPath.setShape( isP1WinnerTruthTellerShape );\n        \n        // now mutate with options that might depend on the shape or layout changes (again, user might override this \n        // so do before the control function)\n        scratchpad.isP1WinnerTruthTellerPath.mutate( {\n          // if initial position is zero, do not set that explicitly because it will break shape points \n          centerX: ('model' === 'model' && 0.01) ? phet.paperLand.utils.paperToBoardX( 0.01, sharedData.displaySize.width ) : 0.01,\n          centerY: ('model' === 'model' && 0.01) ? phet.paperLand.utils.paperToBoardY( 0.01, sharedData.displaySize.height) : 0.01,\n          scale: 1,\n          rotation: 0\n        } );\n      \n        // the functions that are available for this view type\n        \n      const unitBoundsToDisplayBounds = ( bounds ) => {\n        return phet.paperLand.utils.paperToBoardBounds( bounds, sharedData.displaySize.width, sharedData.displaySize.height );\n      };\n      \n      const unitPositionToDisplayPosition = ( position ) => {\n        return phet.paperLand.utils.paperToBoardCoordinates( position, sharedData.displaySize.width, sharedData.displaySize.height );\n      };\n    \n      const setCenterX = ( x ) => {\n        isP1WinnerTruthTellerPath.centerX = phet.paperLand.utils.paperToBoardX( x, sharedData.displaySize.width );\n      };\n      \n      const setCenterY = ( y ) => {\n        isP1WinnerTruthTellerPath.centerY = phet.paperLand.utils.paperToBoardY( y, sharedData.displaySize.height );\n      };\n      \n      const setLeft = ( left ) => {\n        isP1WinnerTruthTellerPath.left = phet.paperLand.utils.paperToBoardX( left, sharedData.displaySize.width );\n      };\n      \n      const setTop = ( top ) => {\n        isP1WinnerTruthTellerPath.top = phet.paperLand.utils.paperToBoardY( top, sharedData.displaySize.height );\n      };\n      \n      const setScale = ( scale ) => {\n        isP1WinnerTruthTellerPath.setScaleMagnitude( scale );\n      };\n      \n      const setOpacity = ( opacity ) => {\n        isP1WinnerTruthTellerPath.opacity = opacity;\n      };\n      \n      const setVisible = ( visible ) => {\n        isP1WinnerTruthTellerPath.visible = visible;\n      };\n      \n      const moveToFront = () => {\n        isP1WinnerTruthTellerPath.moveToFront();\n      };\n      \n      const moveToBack = () => {\n        isP1WinnerTruthTellerPath.moveToBack();\n      };\n      \n      const setRotation = ( rotation ) => {\n        isP1WinnerTruthTellerPath.rotation = rotation;\n      };\n\n      // Set the scale in X and Y and the       \n      const matchBounds = ( bounds, stretch ) => {\n      \n        // Find the scale to apply to the x and y dimensions so that the component bounds match the provided bounds\n        const isP1WinnerTruthTellerPathViewBounds = phet.paperLand.utils.paperToBoardBounds(bounds, sharedData.displaySize.width, sharedData.displaySize.height);\n\n        // local bounds may be zero as things load\n        // const aspectRatio = ( isP1WinnerTruthTellerPath.localBounds.width || 1 ) / ( isP1WinnerTruthTellerPath.localBounds.height || 1 );\n\n        const scaleX = isP1WinnerTruthTellerPathViewBounds.width / ( isP1WinnerTruthTellerPath.localBounds.width || 1 );\n        const scaleY = isP1WinnerTruthTellerPathViewBounds.height / ( isP1WinnerTruthTellerPath.localBounds.height || 1 );\n\n        if ( stretch ) {\n          isP1WinnerTruthTellerPath.setScaleMagnitude(scaleX, scaleY);\n        }\n        else {\n        \n          // Scale by the minimum of the x and y scale factors, preserving the aspect ratio\n          isP1WinnerTruthTellerPath.setScaleMagnitude( Math.min( scaleX, scaleY ) );\n        }        \n\n        // Now put the component in the center of the bounds\n        isP1WinnerTruthTellerPath.center = isP1WinnerTruthTellerPathViewBounds.center;\n      };\n      \n\n        const setStroke = ( color ) => {\n          isP1WinnerTruthTellerPath.stroke = color;\n        };\n        \n        const setLineWidth = ( width ) => {\n          isP1WinnerTruthTellerPath.lineWidth = width;\n        };\n        \n        const setFill = ( color ) => {\n          isP1WinnerTruthTellerPath.fill = color;\n        };\n        \n        // for a line\n        const setX1 = ( newX1 ) => {\n          x1 = phet.paperLand.utils.paperToBoardX( newX1, sharedData.displaySize.width );\n          isP1WinnerTruthTellerPath.shape = phet.kite.Shape.lineSegment( x1, y1, x2, y2 );\n        };\n        \n        const setY1 = ( newY1 ) => {\n          y1 = phet.paperLand.utils.paperToBoardY( newY1, sharedData.displaySize.height );\n          isP1WinnerTruthTellerPath.shape = phet.kite.Shape.lineSegment( x1, y1, x2, y2 );\n        };\n\n        const setX2 = ( newX2 ) => {\n          x2 = phet.paperLand.utils.paperToBoardX( newX2, sharedData.displaySize.width );\n          isP1WinnerTruthTellerPath.shape = phet.kite.Shape.lineSegment( x1, y1, x2, y2 );\n        };\n        \n        const setY2 = ( newY2 ) => {\n          y2 = phet.paperLand.utils.paperToBoardY( newY2, sharedData.displaySize.height );\n          isP1WinnerTruthTellerPath.shape = phet.kite.Shape.lineSegment( x1, y1, x2, y2 );\n        };\n        \n        // for a circle\n        const setRadius = ( radius ) => {\n          // since this is a Path and not a Circle, we need to recreate the shape\n          isP1WinnerTruthTellerPath.shape = phet.kite.Shape.circle( phet.paperLand.utils.paperToBoardX( radius, sharedData.displaySize.width ) );\n        };\n        \n        // for a rectangle\n        const setRectBounds = ( bounds ) => {\n          const transformedBounds = unitBoundsToDisplayBounds( bounds );\n          isP1WinnerTruthTellerPath.shape = phet.kite.Shape.bounds( transformedBounds );\n        };\n        \n        // for a polygon\n        const setPoints = ( points ) => {\n          const transformedPoints = points.map( thisPoint => unitPositionToDisplayPosition( thisPoint ) );\n          isP1WinnerTruthTellerPath.shape = phet.kite.Shape.polygon( transformedPoints );\n        };\n        \n        // bring in the reference components so they are available in the control function\n        \n        \n        if ( IsP1Winner ) {\n    setFill( 'green' );\n} else {\n    setFill( 'red' );\n}\n      }, {\n        otherProperties: [ phet.paperLand.displaySizeProperty ],\n        otherReferences: [  ]\n      } );\n    \n\n      scratchpad.setActiveCardsControllerMultilinkId = phet.paperLand.addModelPropertyMultilink( [ 'p1FireImgPosition', 'p1IceImgPosition', 'p1TornadoImgPosition', 'playArea', 'p2TornadoImgPosition', 'p2IceImgPosition', 'p2FireImgPosition' ], ( p1FireImgPosition, p1IceImgPosition, p1TornadoImgPosition, playArea, p2TornadoImgPosition, p2IceImgPosition, p2FireImgPosition ) => {\n      \n        // We have behavior with components outside of the multilink that may not exist yet, we only do this\n        // work if all are available\n        if ( phet.paperLand.hasAllModelComponents( [ 'isActiveCardP1Fire', 'isActiveCardP1Ice', 'isActiveCardP1Tornado', 'isActiveCardP2Tornado', 'isActiveCardP2Ice', 'isActiveCardP2Fire' ] ) ) {\n        \n          // references to the model components that are controlled by this listener AND the model compnoents\n          // that are selected as references\n          const isActiveCardP1Fire = phet.paperLand.getModelComponent( 'isActiveCardP1Fire' ).value;\nconst isActiveCardP1Ice = phet.paperLand.getModelComponent( 'isActiveCardP1Ice' ).value;\nconst isActiveCardP1Tornado = phet.paperLand.getModelComponent( 'isActiveCardP1Tornado' ).value;\nconst isActiveCardP2Tornado = phet.paperLand.getModelComponent( 'isActiveCardP2Tornado' ).value;\nconst isActiveCardP2Ice = phet.paperLand.getModelComponent( 'isActiveCardP2Ice' ).value;\nconst isActiveCardP2Fire = phet.paperLand.getModelComponent( 'isActiveCardP2Fire' ).value;\n      \n          // the functions that are available to the client from their selected dependencies\n          const setIsActiveCardP1Fire = newValue => {\n        const modelComponent = phet.paperLand.getModelComponent( 'isActiveCardP1Fire' );\n        modelComponent.value = newValue;  \n      }\n      \nconst setIsActiveCardP1Ice = newValue => {\n        const modelComponent = phet.paperLand.getModelComponent( 'isActiveCardP1Ice' );\n        modelComponent.value = newValue;  \n      }\n      \nconst setIsActiveCardP1Tornado = newValue => {\n        const modelComponent = phet.paperLand.getModelComponent( 'isActiveCardP1Tornado' );\n        modelComponent.value = newValue;  \n      }\n      \nconst setIsActiveCardP2Tornado = newValue => {\n        const modelComponent = phet.paperLand.getModelComponent( 'isActiveCardP2Tornado' );\n        modelComponent.value = newValue;  \n      }\n      \nconst setIsActiveCardP2Ice = newValue => {\n        const modelComponent = phet.paperLand.getModelComponent( 'isActiveCardP2Ice' );\n        modelComponent.value = newValue;  \n      }\n      \nconst setIsActiveCardP2Fire = newValue => {\n        const modelComponent = phet.paperLand.getModelComponent( 'isActiveCardP2Fire' );\n        modelComponent.value = newValue;  \n      }\n      \n      \n          // the code block that the user wrote to change controlled Properties\n          if (playArea.containsPoint(p1FireImgPosition)) {\n    setIsActiveCardP1Fire(true);\n    setIsActiveCardP1Ice(false);\n    setIsActiveCardP1Tornado(false);\n\n    phet.paperLand.console.log(isActiveCardP1Fire);\n    phet.paperLand.console.log(isActiveCardP1Tornado);\n    phet.paperLand.console.log(isActiveCardP1Ice);\n\n} else if (playArea.containsPoint(p1IceImgPosition)) {\n    setIsActiveCardP1Fire(false);\n    setIsActiveCardP1Ice(true);\n    setIsActiveCardP1Tornado(false);\n\n    phet.paperLand.console.log(isActiveCardP1Fire);\n    phet.paperLand.console.log(isActiveCardP1Tornado);\n    phet.paperLand.console.log(isActiveCardP1Ice);\n\n} else if (playArea.containsPoint(p1TornadoImgPosition)) {\n    setIsActiveCardP1Fire(false);\n    setIsActiveCardP1Ice(false);\n    setIsActiveCardP1Tornado(true);\n\n    phet.paperLand.console.log(isActiveCardP1Fire);\n    phet.paperLand.console.log(isActiveCardP1Tornado);\n    phet.paperLand.console.log(isActiveCardP1Ice);\n\n} else {\n    setIsActiveCardP1Fire(false);\n    setIsActiveCardP1Ice(false);\n    setIsActiveCardP1Tornado(false);\n\n    phet.paperLand.console.log(isActiveCardP1Fire);\n    phet.paperLand.console.log(isActiveCardP1Tornado);\n    phet.paperLand.console.log(isActiveCardP1Ice);\n}\n\nif (playArea.containsPoint(p2TornadoImgPosition)) {\n    setIsActiveCardP2Tornado(true);\n    setIsActiveCardP2Ice(false);\n    setIsActiveCardP2Fire(false);\n} else if (playArea.containsPoint(p2IceImgPosition)) {\n    setIsActiveCardP2Tornado(false);\n    setIsActiveCardP2Ice(true);\n    setIsActiveCardP2Fire(false);\n} else if (playArea.containsPoint(p2FireImgPosition)) {\n    setIsActiveCardP2Tornado(false);\n    setIsActiveCardP2Ice(false);\n    setIsActiveCardP2Fire(true);\n} else {\n    setIsActiveCardP2Tornado(false);\n    setIsActiveCardP2Ice(false);\n    setIsActiveCardP2Fire(false);\n}\n\n// if (playArea.containsPoint(p1FireImgPosition)) {\n//     setIsActiveCardP1Fire(true);\n//     setIsActiveCardP1Ice(false);\n//     setIsActiveCardP1Tornado(false);\n// } else if (playArea.containsPoint(p1IceImgPosition) && !isActiveCardP1Fire) {\n//     setIsActiveCardP1Fire(false);\n//     setIsActiveCardP1Ice(true);\n//     setIsActiveCardP1Tornado(false);\n// } else if (playArea.containsPoint(p1TornadoImgPosition) && !isActiveCardP1Fire && !isActiveCardP1Ice) {\n//     setIsActiveCardP1Fire(false);\n//     setIsActiveCardP1Ice(false);\n//     setIsActiveCardP1Tornado(true);\n// } else {\n//     setIsActiveCardP1Fire(false);\n//     setIsActiveCardP1Ice(false);\n//     setIsActiveCardP1Tornado(false);\n// }\n\n// if (playArea.containsPoint(p2TornadoImgPosition)) {\n//     setIsActiveCardP2Tornado(true);\n//     setIsActiveCardP2Ice(false);\n//     setIsActiveCardP2Fire(false);\n// } else if (playArea.containsPoint(p2IceImgPosition) && !isActiveCardP2Tornado) {\n//     setIsActiveCardP2Tornado(false);\n//     setIsActiveCardP2Ice(true);\n//     setIsActiveCardP2Fire(false);\n// } else if (playArea.containsPoint(p2FireImgPosition) && !isActiveCardP2Tornado && !isActiveCardP2Ice) {\n//     setIsActiveCardP2Tornado(false);\n//     setIsActiveCardP2Ice(false);\n//     setIsActiveCardP2Fire(true);\n// } else {\n//     setIsActiveCardP2Tornado(false);\n//     setIsActiveCardP2Ice(false);\n//     setIsActiveCardP2Fire(false);\n// }   \n        }\n      } );\n    \n\n      scratchpad.DetermineWinnerMultilinkId = phet.paperLand.addModelPropertyMultilink( [ 'isActiveCardP1Fire', 'isActiveCardP1Ice', 'isActiveCardP1Tornado', 'isActiveCardP2Tornado', 'isActiveCardP2Ice', 'isActiveCardP2Fire' ], ( isActiveCardP1Fire, isActiveCardP1Ice, isActiveCardP1Tornado, isActiveCardP2Tornado, isActiveCardP2Ice, isActiveCardP2Fire ) => {\n      \n        // We have behavior with components outside of the multilink that may not exist yet, we only do this\n        // work if all are available\n        if ( phet.paperLand.hasAllModelComponents( [ 'IsP1Winner', 'IsP2Winner' ] ) ) {\n        \n          // references to the model components that are controlled by this listener AND the model compnoents\n          // that are selected as references\n          const IsP1Winner = phet.paperLand.getModelComponent( 'IsP1Winner' ).value;\nconst IsP2Winner = phet.paperLand.getModelComponent( 'IsP2Winner' ).value;\n      \n          // the functions that are available to the client from their selected dependencies\n          const setIsP1Winner = newValue => {\n        const modelComponent = phet.paperLand.getModelComponent( 'IsP1Winner' );\n        modelComponent.value = newValue;  \n      }\n      \nconst setIsP2Winner = newValue => {\n        const modelComponent = phet.paperLand.getModelComponent( 'IsP2Winner' );\n        modelComponent.value = newValue;  \n      }\n      \n      \n          // the code block that the user wrote to change controlled Properties\n          \n// Fire beats Ice\nif (isActiveCardP1Fire && isActiveCardP2Ice) {\n    setIsP1Winner(true);\n    setIsP2Winner(false);\n} else if (isActiveCardP1Ice && isActiveCardP2Fire) {\n    setIsP1Winner(false);\n    setIsP2Winner(true);\n}\n// Ice beats Tornado\nelse if (isActiveCardP1Ice && isActiveCardP2Tornado) {\n    setIsP1Winner(true);\n    setIsP2Winner(false);\n} else if (isActiveCardP1Tornado && isActiveCardP2Ice) {\n    setIsP1Winner(false);\n    setIsP2Winner(true);\n}\n// Tornado beats Fire\nelse if (isActiveCardP1Tornado && isActiveCardP2Fire) {\n    setIsP1Winner(true);\n    setIsP2Winner(false);\n} else if (isActiveCardP1Fire && isActiveCardP2Tornado) {\n    setIsP1Winner(false);\n    setIsP2Winner(true);\n}\n// Handles the case where both players choose the same card\nelse if ((isActiveCardP1Fire && isActiveCardP2Fire) || (isActiveCardP1Ice && isActiveCardP2Ice) || (isActiveCardP1Tornado && isActiveCardP2Tornado)) {\n    setIsP1Winner(false);\n    setIsP2Winner(false);\n} else {\n    // Fallback for any unhandled cases\n    setIsP1Winner(false);\n    setIsP2Winner(false);\n}\n   \n        }\n      } );\n    \n  };\n\n  const onProgramRemoved = ( paperNumber, scratchpad, sharedData ) => {\n    \n      // Remove the component from the model\n      phet.paperLand.removeModelComponent( 'IsP1Winner' );\n    \n\n      // Remove the component from the model\n      phet.paperLand.removeModelComponent( 'IsP2Winner' );\n    \n\n      // Remove the component from the model\n      phet.paperLand.removeModelComponent( 'playArea' );\n    \n\n     // Remove the component from the model\n      phet.paperLand.removeModelComponent( 'p1CardArrayAddedItem' );\n    \n\n     // Remove the component from the model\n      phet.paperLand.removeModelComponent( 'p1CardArrayRemovedItem' );\n    \n\n     // Remove the component from the model\n      phet.paperLand.removeModelComponent( 'p2CardArrayAddedItem' );\n    \n\n     // Remove the component from the model\n      phet.paperLand.removeModelComponent( 'p2CardArrayRemovedItem' );\n    \n\n      // Remove the component from the model\n      phet.paperLand.removeModelComponent( 'p1CardArray' );\n    \n\n      // Remove the component from the model\n      phet.paperLand.removeModelComponent( 'p2CardArray' );\n    \n\n\n      // remove the multilink updating the value    \n      phet.paperLand.removeModelPropertyMultilink( [ 'p1CardArray' ], scratchpad.p1CardArrayLengthDerivedPropertyObserverId );\n      delete scratchpad.p1CardArrayLengthDerivedPropertyObserverId;\n      \n      // remove the derived Property from the model\n      phet.paperLand.removeModelComponent( 'p1CardArrayLength' );\n    \n\n\n      // remove the multilink updating the value    \n      phet.paperLand.removeModelPropertyMultilink( [ 'p2CardArray' ], scratchpad.p2CardArrayLengthDerivedPropertyObserverId );\n      delete scratchpad.p2CardArrayLengthDerivedPropertyObserverId;\n      \n      // remove the derived Property from the model\n      phet.paperLand.removeModelComponent( 'p2CardArrayLength' );\n    \n\n      phet.tambo.soundManager.removeSoundGenerator( scratchpad.winningSoundSoundClip );\n      delete scratchpad.winningSoundSoundClip;\n      \n      scratchpad.winningSoundWrappedAudioBuffer.audioBufferProperty.unlink( scratchpad.winningSoundWrappedAudioBufferListener );\n      delete scratchpad.winningSoundWrappedAudioBufferListener;\n      \n      phet.paperLand.removeModelPropertyMultilink( [ 'IsP1Winner', 'IsP2Winner' ], scratchpad.winningSoundSoundMultilinkId, {\n        otherReferences: [  ]\n       } );\n      delete scratchpad.winningSoundSoundMultilinkId;\n    \n\n      // Remove the image from the view.\n      sharedData.scene.removeChild( scratchpad.playAreaImageImage );\n      delete scratchpad.playAreaImageImage;\n      \n      // Remove the multilink\n      phet.paperLand.removeModelPropertyMultilink( [ 'playArea' ], scratchpad.playAreaImageImageMultilinkId, {\n        otherReferences: [  ]\n      } );\n      delete scratchpad.playAreaImageImageMultilinkId;\n    \n\n    \n      // Remove the Path from the view\n      sharedData.scene.removeChild( scratchpad.playAreaViewPath );\n      delete scratchpad.playAreaViewPath;\n      \n      // Remove the multilink\n      phet.paperLand.removeModelPropertyMultilink( [ 'playArea' ], scratchpad.playAreaViewPathMultilinkId, {\n        otherReferences: [  ]\n      } );\n      delete scratchpad.playAreaViewPathMultilinkId;\n    \n\n    \n      // Remove the Path from the view\n      sharedData.scene.removeChild( scratchpad.isP1WinnerTruthTellerPath );\n      delete scratchpad.isP1WinnerTruthTellerPath;\n      \n      // Remove the multilink\n      phet.paperLand.removeModelPropertyMultilink( [ 'IsP1Winner' ], scratchpad.isP1WinnerTruthTellerPathMultilinkId, {\n        otherReferences: [  ]\n      } );\n      delete scratchpad.isP1WinnerTruthTellerPathMultilinkId;\n    \n\n      phet.paperLand.removeModelPropertyMultilink( [ 'p1FireImgPosition', 'p1IceImgPosition', 'p1TornadoImgPosition', 'playArea', 'p2TornadoImgPosition', 'p2IceImgPosition', 'p2FireImgPosition' ], scratchpad.setActiveCardsControllerMultilinkId );\n      delete scratchpad.setActiveCardsControllerMultilinkId;\n    \n\n      phet.paperLand.removeModelPropertyMultilink( [ 'isActiveCardP1Fire', 'isActiveCardP1Ice', 'isActiveCardP1Tornado', 'isActiveCardP2Tornado', 'isActiveCardP2Ice', 'isActiveCardP2Fire' ], scratchpad.DetermineWinnerMultilinkId );\n      delete scratchpad.DetermineWinnerMultilinkId;\n    \n  };\n\n  const onProgramChangedPosition = ( paperNumber, points, scratchpad, sharedData ) => {\n    \n  };\n  \n  const onProgramMarkersAdded = ( paperNumber, points, scratchpad, sharedData, markers ) => {\n    \n  };\n  \n  const onProgramMarkersRemoved = ( paperNumber, points, scratchpad, sharedData, markers ) => {\n    \n  };\n  \n  const onProgramMarkersChangedPosition = ( paperNumber, points, scratchpad, sharedData, markers ) => {\n    \n  };\n  \n  const onProgramAdjacent = ( paperNumber, otherPaperNumber, direction, scratchpad, sharedData ) => {\n    \n  };\n  \n  const onProgramSeparated = ( paperNumber, otherPaperNumber, direction, scratchpad, sharedData ) => {\n    \n  };\n\n  await paper.set( 'data', {\n    paperPlaygroundData: {\n      updateTime: Date.now(),\n      eventHandlers: {\n        onProgramAdded: onProgramAdded.toString(),\n        onProgramRemoved: onProgramRemoved.toString(),\n        onProgramChangedPosition: onProgramChangedPosition.toString(),\n        onProgramMarkersAdded: onProgramMarkersAdded.toString(),\n        onProgramMarkersRemoved: onProgramMarkersRemoved.toString(),\n        onProgramMarkersChangedPosition: onProgramMarkersChangedPosition.toString(),\n        onProgramAdjacent: onProgramAdjacent.toString(),\n        onProgramSeparated: onProgramSeparated.toString(),\n      },\n      customWhiskerLengths: {\n        top: 0.2,\n        right: 0.2,\n        bottom: 0.2,\n        left: 0.2\n      }\n    }\n  } );\n  \n  // PROJECTOR CODE //\n  // Get a canvas object for this paper to draw something to the Projector.\n  const canvas = await paper.get('canvas');\n\n  // Draw the name of the program to the projector\n  const ctx = canvas.getContext('2d');\n  ctx.font = '20px sans-serif';\n  ctx.textAlign = 'center';\n  ctx.fillStyle = 'rgb(255,0,0)';\n  ctx.fillText('', canvas.width / 2, canvas.height / 2 - 10);\n  ctx.fillStyle = 'rgb(0,255,0)';\n  ctx.font = '10px sans-serif';\n  ctx.fillText('Paper Elements Game Model', canvas.width / 2, canvas.height / 2 + 20);\n})();\n",
  "currentCode": "// Paper Elements Game Model\n// Keywords: \n// Description: \n\nimportScripts('paper.js');\n\n(async () => {\n\n  const onProgramAdded = ( paperNumber, scratchpad, sharedData ) => {\n    \n      const IsP1Winner = new phet.axon.BooleanProperty(false);\n      phet.paperLand.addModelComponent( 'IsP1Winner', IsP1Winner );\n    \n\n      const IsP2Winner = new phet.axon.BooleanProperty(false);\n      phet.paperLand.addModelComponent( 'IsP2Winner', IsP2Winner );\n    \n\n      const playArea = new phet.axon.Property(\n        new phet.dot.Bounds2( 0.3, 0, 0.66, 1 )\n      );\n      phet.paperLand.addModelComponent( 'playArea', playArea );\n    \n\n      const p1CardArrayAddedItem = new phet.axon.Property( null );\n      phet.paperLand.addModelComponent( 'p1CardArrayAddedItem', p1CardArrayAddedItem );\n    \n\n      const p1CardArrayRemovedItem = new phet.axon.Property( null );\n      phet.paperLand.addModelComponent( 'p1CardArrayRemovedItem', p1CardArrayRemovedItem );\n    \n\n      const p2CardArrayAddedItem = new phet.axon.Property( null );\n      phet.paperLand.addModelComponent( 'p2CardArrayAddedItem', p2CardArrayAddedItem );\n    \n\n      const p2CardArrayRemovedItem = new phet.axon.Property( null );\n      phet.paperLand.addModelComponent( 'p2CardArrayRemovedItem', p2CardArrayRemovedItem );\n    \n\n      const p1CardArray = new phet.axon.Property( [] );\n      phet.paperLand.addModelComponent( 'p1CardArray', p1CardArray );\n    \n\n      const p2CardArray = new phet.axon.Property( [] );\n      phet.paperLand.addModelComponent( 'p2CardArray', p2CardArray );\n    \n\n      // DerivedProperties are actually implemented with Multilink for now because paper-land has a nice abstraction\n      // for it.\n      const p1CardArrayLength = new phet.axon.Property( null );\n      scratchpad.p1CardArrayLengthDerivedPropertyObserverId = phet.paperLand.addModelPropertyMultilink( [ 'p1CardArray' ], ( p1CardArray ) => {\n        const derivationFunction = () => {\n        \n          // should return a value based on the dependencies\n          return p1CardArray.length;\n        };\n        p1CardArrayLength.value = derivationFunction();\n      } );\n      phet.paperLand.addModelComponent( 'p1CardArrayLength', p1CardArrayLength );\n    \n\n      // DerivedProperties are actually implemented with Multilink for now because paper-land has a nice abstraction\n      // for it.\n      const p2CardArrayLength = new phet.axon.Property( null );\n      scratchpad.p2CardArrayLengthDerivedPropertyObserverId = phet.paperLand.addModelPropertyMultilink( [ 'p2CardArray' ], ( p2CardArray ) => {\n        const derivationFunction = () => {\n        \n          // should return a value based on the dependencies\n          return p2CardArray.length;\n        };\n        p2CardArrayLength.value = derivationFunction();\n      } );\n      phet.paperLand.addModelComponent( 'p2CardArrayLength', p2CardArrayLength );\n    \n\n      const winningSoundWrappedAudioBuffer = createAndLoadWrappedAudioBuffer( 'media/sounds/short-success.mp3' );\n      const winningSoundSoundClip = new phet.tambo.SoundClip( winningSoundWrappedAudioBuffer, {\n        loop: false,\n        initialOutputLevel: 0.5\n       } );\n      phet.tambo.soundManager.addSoundGenerator( winningSoundSoundClip );\n      scratchpad.winningSoundWrappedAudioBuffer = winningSoundWrappedAudioBuffer;\n      \n      let winningSoundStopSoundTimeout = null;\n      \n      // as a safety measure, sound can only be played every 0.25 seconds - initial value is very small\n      // so that it can be played immediately\n      let winningSoundLastPlayTime = 0;\n      \n      // The listener that will observe the model and play sounds is added as soon as the sounds are loaded, and\n      // added to the scratch pad so that it can be removed later.\n      scratchpad.winningSoundWrappedAudioBufferListener = _buffer => {\n        if ( _buffer ) {\n        \n          // Play the sound when any dependencies change value.\n          scratchpad.winningSoundSoundMultilinkId = phet.paperLand.addModelPropertyMultilink( [ 'IsP1Winner', 'IsP2Winner' ], ( IsP1Winner, IsP2Winner ) => {\n            \n            // in a local scope, define the functions that the user can use to manipulate the sound\n            const setOutputLevel = ( level ) => {\n            \n              // As a safety measure, don't let the user set a level below zero and above 2.\n              const outputLevel = Math.max( 0, Math.min( 2, level ) );\n              winningSoundSoundClip.outputLevel = outputLevel;\n            };\n            const setPlaybackRate = ( rate ) => {\n            \n              // As a safety measure, the playback rate cannot go below zero.\n              const playbackRate = Math.max( 0, rate );\n              winningSoundSoundClip.setPlaybackRate( playbackRate );\n            };\n            \n            // a function the user can call to play the sound\n            const play = () => {\n            \n              // Play the sound - if looping, we don't want to start playing again if already playing. The sound\n              // can only be played at a limited interval for safety.\n              if ( ( !winningSoundSoundClip.isPlaying || !false ) && phet.paperLand.elapsedTimeProperty.value - winningSoundLastPlayTime > 0.25 ) {\n      \n                // only start playing again if it has been stopped - but we still enter this block to update\n                // the last play time and timeouts        \n                if ( !winningSoundSoundClip.isPlaying ) {\n                  winningSoundSoundClip.play();\n                }\n                winningSoundLastPlayTime = phet.paperLand.elapsedTimeProperty.value;\n                \n                // Set a timer to turn off the sound when the value stops changing.\n                if ( winningSoundStopSoundTimeout ){\n                  window.clearTimeout( winningSoundStopSoundTimeout );\n                }\n                \n                // only stop if not looping\n                if ( !false ) {\n                  winningSoundStopSoundTimeout = window.setTimeout( () => {\n                    winningSoundSoundClip.stop();\n                  }, 5000 );\n                }  \n              }\n            };\n            \n            const stop = () => {\n              // Set a timer to turn off the sound when the value stops changing.\n              if ( winningSoundStopSoundTimeout ){\n                window.clearTimeout( winningSoundStopSoundTimeout );\n              }\n              winningSoundSoundClip.stop();\n            };\n            \n            if ( false ) {\n              play();\n            }\n            \n            // declare the references so that they can be used in the control function\n            \n          \n            setOutputLevel(1);\n\nif ( IsP1Winner || IsP2Winner ) {\n    play();\n    phet.paperLand.console.log(\"Someone Won!\");\n}\n          }, {\n            otherReferences: [  ],\n          } );  \n        }\n      };     \n      scratchpad.winningSoundWrappedAudioBuffer.audioBufferProperty.link( scratchpad.winningSoundWrappedAudioBufferListener );\n      \n      // Assign the sound to the scratchpad so that we can remove it later\n      scratchpad.winningSoundSoundClip = winningSoundSoundClip;\n    \n\n      // Create an image and add it to the view.\n      let playAreaImageImageElement = document.createElement( 'img' );\n      playAreaImageImageElement.src = 'media/images/fantasy-card-mat.jpg';\n      const playAreaImageImage = new phet.scenery.Image( playAreaImageImageElement );\n\n      // As soon as the image loads, update a Property added to the multilink so that the control\n      // function is called again to update the positioning.       \n      const playAreaImageImageLoadProperty = new phet.axon.Property( 0 );\n      playAreaImageImageElement.addEventListener( 'load', () => { playAreaImageImageLoadProperty.value = playAreaImageImageLoadProperty.value + 1; } );\n      \n      sharedData.scene.addChild( playAreaImageImage );\n      scratchpad.playAreaImageImage = playAreaImageImage;\n      \n      // Update the image when a dependency changes, and redraw if the board resizes. This is async because\n      // function in the control function might be async to support loading images.\n      scratchpad.playAreaImageImageMultilinkId = phet.paperLand.addModelPropertyMultilink( [ 'playArea' ], async ( playArea ) => {\n        \n        // the functions that are available for this view type\n        \n      const unitBoundsToDisplayBounds = ( bounds ) => {\n        return phet.paperLand.utils.paperToBoardBounds( bounds, sharedData.displaySize.width, sharedData.displaySize.height );\n      };\n      \n      const unitPositionToDisplayPosition = ( position ) => {\n        return phet.paperLand.utils.paperToBoardCoordinates( position, sharedData.displaySize.width, sharedData.displaySize.height );\n      };\n    \n      const setCenterX = ( x ) => {\n        playAreaImageImage.centerX = phet.paperLand.utils.paperToBoardX( x, sharedData.displaySize.width );\n      };\n      \n      const setCenterY = ( y ) => {\n        playAreaImageImage.centerY = phet.paperLand.utils.paperToBoardY( y, sharedData.displaySize.height );\n      };\n      \n      const setLeft = ( left ) => {\n        playAreaImageImage.left = phet.paperLand.utils.paperToBoardX( left, sharedData.displaySize.width );\n      };\n      \n      const setTop = ( top ) => {\n        playAreaImageImage.top = phet.paperLand.utils.paperToBoardY( top, sharedData.displaySize.height );\n      };\n      \n      const setScale = ( scale ) => {\n        playAreaImageImage.setScaleMagnitude( scale );\n      };\n      \n      const setOpacity = ( opacity ) => {\n        playAreaImageImage.opacity = opacity;\n      };\n      \n      const setVisible = ( visible ) => {\n        playAreaImageImage.visible = visible;\n      };\n      \n      const moveToFront = () => {\n        playAreaImageImage.moveToFront();\n      };\n      \n      const moveToBack = () => {\n        playAreaImageImage.moveToBack();\n      };\n      \n      const setRotation = ( rotation ) => {\n        playAreaImageImage.rotation = rotation;\n      };\n\n      // Set the scale in X and Y and the       \n      const matchBounds = ( bounds, stretch ) => {\n      \n        // Find the scale to apply to the x and y dimensions so that the component bounds match the provided bounds\n        const playAreaImageImageViewBounds = phet.paperLand.utils.paperToBoardBounds(bounds, sharedData.displaySize.width, sharedData.displaySize.height);\n\n        // local bounds may be zero as things load\n        // const aspectRatio = ( playAreaImageImage.localBounds.width || 1 ) / ( playAreaImageImage.localBounds.height || 1 );\n\n        const scaleX = playAreaImageImageViewBounds.width / ( playAreaImageImage.localBounds.width || 1 );\n        const scaleY = playAreaImageImageViewBounds.height / ( playAreaImageImage.localBounds.height || 1 );\n\n        if ( stretch ) {\n          playAreaImageImage.setScaleMagnitude(scaleX, scaleY);\n        }\n        else {\n        \n          // Scale by the minimum of the x and y scale factors, preserving the aspect ratio\n          playAreaImageImage.setScaleMagnitude( Math.min( scaleX, scaleY ) );\n        }        \n\n        // Now put the component in the center of the bounds\n        playAreaImageImage.center = playAreaImageImageViewBounds.center;\n      };\n      \n\n      \n        // This is async so that we can wait for the image to load before doing other things\n        const setImage = async imageName => {\n        \n          return new Promise( (resolve, reject) => {\n          \n            // Get the current image name relative to the local paper playground path\n            let currentImageName;\n            if ( playAreaImageImage.image ) {\n              const startIndex = playAreaImageImage.image.src.indexOf( 'media/images/' );\n              currentImageName = playAreaImageImage.image.src.substring( startIndex );\n            }\n            else {\n              currentImageName = '';\n            }\n            \n            const newImageName = 'media/images/' + imageName;\n            \n            // only update the image if there is a change\n            if ( currentImageName !== newImageName ) {\n              const playAreaImageImageImageElement = document.createElement( 'img' );\n              playAreaImageImageImageElement.src = newImageName;\n              playAreaImageImage.image = playAreaImageImageImageElement;\n\n              // Wait for the image to load before resolving              \n              playAreaImageImageImageElement.addEventListener( 'load', () => {\n                resolve();\n              } );\n            }\n            else {\n              \n              // No change, so resolve immediately\n              resolve();\n            }\n          } );\n        };\n      \n        \n        // bring in the reference components so they are available in the control function\n        \n      \n        matchBounds(playArea, true);\nmoveToBack();\n      }, {\n        otherProperties: [ phet.paperLand.displaySizeProperty, playAreaImageImageLoadProperty ],\n        otherReferences: [  ]\n      } );\n    \n\n\n      // Create a shape with kite.\n      const playAreaViewShape = phet.kite.Shape.rectangle( 0, 0, phet.paperLand.utils.paperToBoardX( 0.5, sharedData.displaySize.width ), phet.paperLand.utils.paperToBoardY( 0.5, sharedData.displaySize.height ) )\n      \n      // create a path for the shape\n      const playAreaViewPath = new phet.scenery.Path( playAreaViewShape, {\n        fill: 'transparent',\n        stroke: 'red',\n        lineWidth: 5,\n        \n        // if initial position is zero, do not set that explicitly because it will break shape points \n        centerX: ('model' === 'model' && undefined) ? phet.paperLand.utils.paperToBoardX( undefined, sharedData.displaySize.width ) : undefined,\n        centerY: ('model' === 'model' && undefined) ? phet.paperLand.utils.paperToBoardY( undefined, sharedData.displaySize.height) : undefined,\n        scale: 1,\n        rotation: 0,\n        opacity: 1\n      } );\n      \n      // assign to scratchpad so that we can remove it later\n      sharedData.scene.addChild( playAreaViewPath );\n      scratchpad.playAreaViewPath = playAreaViewPath;\n      \n      // Update the shape when a dependency changes.\n      scratchpad.playAreaViewPathMultilinkId = phet.paperLand.addModelPropertyMultilink( [ 'playArea' ], ( playArea ) => {\n      \n        // We have to recreate the shape every change (especially important for a resize) - this is done first though\n        // because the user control functions might change the shape further.\n        const playAreaViewShape = phet.kite.Shape.rectangle( 0, 0, phet.paperLand.utils.paperToBoardX( 0.5, sharedData.displaySize.width ), phet.paperLand.utils.paperToBoardY( 0.5, sharedData.displaySize.height ) )\n        scratchpad.playAreaViewPath.setShape( playAreaViewShape );\n        \n        // now mutate with options that might depend on the shape or layout changes (again, user might override this \n        // so do before the control function)\n        scratchpad.playAreaViewPath.mutate( {\n          // if initial position is zero, do not set that explicitly because it will break shape points \n          centerX: ('model' === 'model' && undefined) ? phet.paperLand.utils.paperToBoardX( undefined, sharedData.displaySize.width ) : undefined,\n          centerY: ('model' === 'model' && undefined) ? phet.paperLand.utils.paperToBoardY( undefined, sharedData.displaySize.height) : undefined,\n          scale: 1,\n          rotation: 0\n        } );\n      \n        // the functions that are available for this view type\n        \n      const unitBoundsToDisplayBounds = ( bounds ) => {\n        return phet.paperLand.utils.paperToBoardBounds( bounds, sharedData.displaySize.width, sharedData.displaySize.height );\n      };\n      \n      const unitPositionToDisplayPosition = ( position ) => {\n        return phet.paperLand.utils.paperToBoardCoordinates( position, sharedData.displaySize.width, sharedData.displaySize.height );\n      };\n    \n      const setCenterX = ( x ) => {\n        playAreaViewPath.centerX = phet.paperLand.utils.paperToBoardX( x, sharedData.displaySize.width );\n      };\n      \n      const setCenterY = ( y ) => {\n        playAreaViewPath.centerY = phet.paperLand.utils.paperToBoardY( y, sharedData.displaySize.height );\n      };\n      \n      const setLeft = ( left ) => {\n        playAreaViewPath.left = phet.paperLand.utils.paperToBoardX( left, sharedData.displaySize.width );\n      };\n      \n      const setTop = ( top ) => {\n        playAreaViewPath.top = phet.paperLand.utils.paperToBoardY( top, sharedData.displaySize.height );\n      };\n      \n      const setScale = ( scale ) => {\n        playAreaViewPath.setScaleMagnitude( scale );\n      };\n      \n      const setOpacity = ( opacity ) => {\n        playAreaViewPath.opacity = opacity;\n      };\n      \n      const setVisible = ( visible ) => {\n        playAreaViewPath.visible = visible;\n      };\n      \n      const moveToFront = () => {\n        playAreaViewPath.moveToFront();\n      };\n      \n      const moveToBack = () => {\n        playAreaViewPath.moveToBack();\n      };\n      \n      const setRotation = ( rotation ) => {\n        playAreaViewPath.rotation = rotation;\n      };\n\n      // Set the scale in X and Y and the       \n      const matchBounds = ( bounds, stretch ) => {\n      \n        // Find the scale to apply to the x and y dimensions so that the component bounds match the provided bounds\n        const playAreaViewPathViewBounds = phet.paperLand.utils.paperToBoardBounds(bounds, sharedData.displaySize.width, sharedData.displaySize.height);\n\n        // local bounds may be zero as things load\n        // const aspectRatio = ( playAreaViewPath.localBounds.width || 1 ) / ( playAreaViewPath.localBounds.height || 1 );\n\n        const scaleX = playAreaViewPathViewBounds.width / ( playAreaViewPath.localBounds.width || 1 );\n        const scaleY = playAreaViewPathViewBounds.height / ( playAreaViewPath.localBounds.height || 1 );\n\n        if ( stretch ) {\n          playAreaViewPath.setScaleMagnitude(scaleX, scaleY);\n        }\n        else {\n        \n          // Scale by the minimum of the x and y scale factors, preserving the aspect ratio\n          playAreaViewPath.setScaleMagnitude( Math.min( scaleX, scaleY ) );\n        }        \n\n        // Now put the component in the center of the bounds\n        playAreaViewPath.center = playAreaViewPathViewBounds.center;\n      };\n      \n\n        const setStroke = ( color ) => {\n          playAreaViewPath.stroke = color;\n        };\n        \n        const setLineWidth = ( width ) => {\n          playAreaViewPath.lineWidth = width;\n        };\n        \n        const setFill = ( color ) => {\n          playAreaViewPath.fill = color;\n        };\n        \n        // for a line\n        const setX1 = ( newX1 ) => {\n          x1 = phet.paperLand.utils.paperToBoardX( newX1, sharedData.displaySize.width );\n          playAreaViewPath.shape = phet.kite.Shape.lineSegment( x1, y1, x2, y2 );\n        };\n        \n        const setY1 = ( newY1 ) => {\n          y1 = phet.paperLand.utils.paperToBoardY( newY1, sharedData.displaySize.height );\n          playAreaViewPath.shape = phet.kite.Shape.lineSegment( x1, y1, x2, y2 );\n        };\n\n        const setX2 = ( newX2 ) => {\n          x2 = phet.paperLand.utils.paperToBoardX( newX2, sharedData.displaySize.width );\n          playAreaViewPath.shape = phet.kite.Shape.lineSegment( x1, y1, x2, y2 );\n        };\n        \n        const setY2 = ( newY2 ) => {\n          y2 = phet.paperLand.utils.paperToBoardY( newY2, sharedData.displaySize.height );\n          playAreaViewPath.shape = phet.kite.Shape.lineSegment( x1, y1, x2, y2 );\n        };\n        \n        // for a circle\n        const setRadius = ( radius ) => {\n          // since this is a Path and not a Circle, we need to recreate the shape\n          playAreaViewPath.shape = phet.kite.Shape.circle( phet.paperLand.utils.paperToBoardX( radius, sharedData.displaySize.width ) );\n        };\n        \n        // for a rectangle\n        const setRectBounds = ( bounds ) => {\n          const transformedBounds = unitBoundsToDisplayBounds( bounds );\n          playAreaViewPath.shape = phet.kite.Shape.bounds( transformedBounds );\n        };\n        \n        // for a polygon\n        const setPoints = ( points ) => {\n          const transformedPoints = points.map( thisPoint => unitPositionToDisplayPosition( thisPoint ) );\n          playAreaViewPath.shape = phet.kite.Shape.polygon( transformedPoints );\n        };\n        \n        // bring in the reference components so they are available in the control function\n        \n        \n        setRectBounds( playArea );\nmoveToFront();\n      }, {\n        otherProperties: [ phet.paperLand.displaySizeProperty ],\n        otherReferences: [  ]\n      } );\n    \n\n\n      // Create a shape with kite.\n      const isP1WinnerTruthTellerShape = phet.kite.Shape.circle( phet.paperLand.utils.paperToBoardX( 0.005, sharedData.displaySize.width ) )\n      \n      // create a path for the shape\n      const isP1WinnerTruthTellerPath = new phet.scenery.Path( isP1WinnerTruthTellerShape, {\n        fill: 'red',\n        stroke: 'red',\n        lineWidth: 1,\n        \n        // if initial position is zero, do not set that explicitly because it will break shape points \n        centerX: ('model' === 'model' && 0.01) ? phet.paperLand.utils.paperToBoardX( 0.01, sharedData.displaySize.width ) : 0.01,\n        centerY: ('model' === 'model' && 0.01) ? phet.paperLand.utils.paperToBoardY( 0.01, sharedData.displaySize.height) : 0.01,\n        scale: 1,\n        rotation: 0,\n        opacity: 1\n      } );\n      \n      // assign to scratchpad so that we can remove it later\n      sharedData.scene.addChild( isP1WinnerTruthTellerPath );\n      scratchpad.isP1WinnerTruthTellerPath = isP1WinnerTruthTellerPath;\n      \n      // Update the shape when a dependency changes.\n      scratchpad.isP1WinnerTruthTellerPathMultilinkId = phet.paperLand.addModelPropertyMultilink( [ 'IsP1Winner' ], ( IsP1Winner ) => {\n      \n        // We have to recreate the shape every change (especially important for a resize) - this is done first though\n        // because the user control functions might change the shape further.\n        const isP1WinnerTruthTellerShape = phet.kite.Shape.circle( phet.paperLand.utils.paperToBoardX( 0.005, sharedData.displaySize.width ) )\n        scratchpad.isP1WinnerTruthTellerPath.setShape( isP1WinnerTruthTellerShape );\n        \n        // now mutate with options that might depend on the shape or layout changes (again, user might override this \n        // so do before the control function)\n        scratchpad.isP1WinnerTruthTellerPath.mutate( {\n          // if initial position is zero, do not set that explicitly because it will break shape points \n          centerX: ('model' === 'model' && 0.01) ? phet.paperLand.utils.paperToBoardX( 0.01, sharedData.displaySize.width ) : 0.01,\n          centerY: ('model' === 'model' && 0.01) ? phet.paperLand.utils.paperToBoardY( 0.01, sharedData.displaySize.height) : 0.01,\n          scale: 1,\n          rotation: 0\n        } );\n      \n        // the functions that are available for this view type\n        \n      const unitBoundsToDisplayBounds = ( bounds ) => {\n        return phet.paperLand.utils.paperToBoardBounds( bounds, sharedData.displaySize.width, sharedData.displaySize.height );\n      };\n      \n      const unitPositionToDisplayPosition = ( position ) => {\n        return phet.paperLand.utils.paperToBoardCoordinates( position, sharedData.displaySize.width, sharedData.displaySize.height );\n      };\n    \n      const setCenterX = ( x ) => {\n        isP1WinnerTruthTellerPath.centerX = phet.paperLand.utils.paperToBoardX( x, sharedData.displaySize.width );\n      };\n      \n      const setCenterY = ( y ) => {\n        isP1WinnerTruthTellerPath.centerY = phet.paperLand.utils.paperToBoardY( y, sharedData.displaySize.height );\n      };\n      \n      const setLeft = ( left ) => {\n        isP1WinnerTruthTellerPath.left = phet.paperLand.utils.paperToBoardX( left, sharedData.displaySize.width );\n      };\n      \n      const setTop = ( top ) => {\n        isP1WinnerTruthTellerPath.top = phet.paperLand.utils.paperToBoardY( top, sharedData.displaySize.height );\n      };\n      \n      const setScale = ( scale ) => {\n        isP1WinnerTruthTellerPath.setScaleMagnitude( scale );\n      };\n      \n      const setOpacity = ( opacity ) => {\n        isP1WinnerTruthTellerPath.opacity = opacity;\n      };\n      \n      const setVisible = ( visible ) => {\n        isP1WinnerTruthTellerPath.visible = visible;\n      };\n      \n      const moveToFront = () => {\n        isP1WinnerTruthTellerPath.moveToFront();\n      };\n      \n      const moveToBack = () => {\n        isP1WinnerTruthTellerPath.moveToBack();\n      };\n      \n      const setRotation = ( rotation ) => {\n        isP1WinnerTruthTellerPath.rotation = rotation;\n      };\n\n      // Set the scale in X and Y and the       \n      const matchBounds = ( bounds, stretch ) => {\n      \n        // Find the scale to apply to the x and y dimensions so that the component bounds match the provided bounds\n        const isP1WinnerTruthTellerPathViewBounds = phet.paperLand.utils.paperToBoardBounds(bounds, sharedData.displaySize.width, sharedData.displaySize.height);\n\n        // local bounds may be zero as things load\n        // const aspectRatio = ( isP1WinnerTruthTellerPath.localBounds.width || 1 ) / ( isP1WinnerTruthTellerPath.localBounds.height || 1 );\n\n        const scaleX = isP1WinnerTruthTellerPathViewBounds.width / ( isP1WinnerTruthTellerPath.localBounds.width || 1 );\n        const scaleY = isP1WinnerTruthTellerPathViewBounds.height / ( isP1WinnerTruthTellerPath.localBounds.height || 1 );\n\n        if ( stretch ) {\n          isP1WinnerTruthTellerPath.setScaleMagnitude(scaleX, scaleY);\n        }\n        else {\n        \n          // Scale by the minimum of the x and y scale factors, preserving the aspect ratio\n          isP1WinnerTruthTellerPath.setScaleMagnitude( Math.min( scaleX, scaleY ) );\n        }        \n\n        // Now put the component in the center of the bounds\n        isP1WinnerTruthTellerPath.center = isP1WinnerTruthTellerPathViewBounds.center;\n      };\n      \n\n        const setStroke = ( color ) => {\n          isP1WinnerTruthTellerPath.stroke = color;\n        };\n        \n        const setLineWidth = ( width ) => {\n          isP1WinnerTruthTellerPath.lineWidth = width;\n        };\n        \n        const setFill = ( color ) => {\n          isP1WinnerTruthTellerPath.fill = color;\n        };\n        \n        // for a line\n        const setX1 = ( newX1 ) => {\n          x1 = phet.paperLand.utils.paperToBoardX( newX1, sharedData.displaySize.width );\n          isP1WinnerTruthTellerPath.shape = phet.kite.Shape.lineSegment( x1, y1, x2, y2 );\n        };\n        \n        const setY1 = ( newY1 ) => {\n          y1 = phet.paperLand.utils.paperToBoardY( newY1, sharedData.displaySize.height );\n          isP1WinnerTruthTellerPath.shape = phet.kite.Shape.lineSegment( x1, y1, x2, y2 );\n        };\n\n        const setX2 = ( newX2 ) => {\n          x2 = phet.paperLand.utils.paperToBoardX( newX2, sharedData.displaySize.width );\n          isP1WinnerTruthTellerPath.shape = phet.kite.Shape.lineSegment( x1, y1, x2, y2 );\n        };\n        \n        const setY2 = ( newY2 ) => {\n          y2 = phet.paperLand.utils.paperToBoardY( newY2, sharedData.displaySize.height );\n          isP1WinnerTruthTellerPath.shape = phet.kite.Shape.lineSegment( x1, y1, x2, y2 );\n        };\n        \n        // for a circle\n        const setRadius = ( radius ) => {\n          // since this is a Path and not a Circle, we need to recreate the shape\n          isP1WinnerTruthTellerPath.shape = phet.kite.Shape.circle( phet.paperLand.utils.paperToBoardX( radius, sharedData.displaySize.width ) );\n        };\n        \n        // for a rectangle\n        const setRectBounds = ( bounds ) => {\n          const transformedBounds = unitBoundsToDisplayBounds( bounds );\n          isP1WinnerTruthTellerPath.shape = phet.kite.Shape.bounds( transformedBounds );\n        };\n        \n        // for a polygon\n        const setPoints = ( points ) => {\n          const transformedPoints = points.map( thisPoint => unitPositionToDisplayPosition( thisPoint ) );\n          isP1WinnerTruthTellerPath.shape = phet.kite.Shape.polygon( transformedPoints );\n        };\n        \n        // bring in the reference components so they are available in the control function\n        \n        \n        if ( IsP1Winner ) {\n    setFill( 'green' );\n} else {\n    setFill( 'red' );\n}\n      }, {\n        otherProperties: [ phet.paperLand.displaySizeProperty ],\n        otherReferences: [  ]\n      } );\n    \n\n      scratchpad.setActiveCardsControllerMultilinkId = phet.paperLand.addModelPropertyMultilink( [ 'p1FireImgPosition', 'p1IceImgPosition', 'p1TornadoImgPosition', 'playArea', 'p2TornadoImgPosition', 'p2IceImgPosition', 'p2FireImgPosition' ], ( p1FireImgPosition, p1IceImgPosition, p1TornadoImgPosition, playArea, p2TornadoImgPosition, p2IceImgPosition, p2FireImgPosition ) => {\n      \n        // We have behavior with components outside of the multilink that may not exist yet, we only do this\n        // work if all are available\n        if ( phet.paperLand.hasAllModelComponents( [ 'isActiveCardP1Fire', 'isActiveCardP1Ice', 'isActiveCardP1Tornado', 'isActiveCardP2Tornado', 'isActiveCardP2Ice', 'isActiveCardP2Fire' ] ) ) {\n        \n          // references to the model components that are controlled by this listener AND the model compnoents\n          // that are selected as references\n          const isActiveCardP1Fire = phet.paperLand.getModelComponent( 'isActiveCardP1Fire' ).value;\nconst isActiveCardP1Ice = phet.paperLand.getModelComponent( 'isActiveCardP1Ice' ).value;\nconst isActiveCardP1Tornado = phet.paperLand.getModelComponent( 'isActiveCardP1Tornado' ).value;\nconst isActiveCardP2Tornado = phet.paperLand.getModelComponent( 'isActiveCardP2Tornado' ).value;\nconst isActiveCardP2Ice = phet.paperLand.getModelComponent( 'isActiveCardP2Ice' ).value;\nconst isActiveCardP2Fire = phet.paperLand.getModelComponent( 'isActiveCardP2Fire' ).value;\n      \n          // the functions that are available to the client from their selected dependencies\n          const setIsActiveCardP1Fire = newValue => {\n        const modelComponent = phet.paperLand.getModelComponent( 'isActiveCardP1Fire' );\n        modelComponent.value = newValue;  \n      }\n      \nconst setIsActiveCardP1Ice = newValue => {\n        const modelComponent = phet.paperLand.getModelComponent( 'isActiveCardP1Ice' );\n        modelComponent.value = newValue;  \n      }\n      \nconst setIsActiveCardP1Tornado = newValue => {\n        const modelComponent = phet.paperLand.getModelComponent( 'isActiveCardP1Tornado' );\n        modelComponent.value = newValue;  \n      }\n      \nconst setIsActiveCardP2Tornado = newValue => {\n        const modelComponent = phet.paperLand.getModelComponent( 'isActiveCardP2Tornado' );\n        modelComponent.value = newValue;  \n      }\n      \nconst setIsActiveCardP2Ice = newValue => {\n        const modelComponent = phet.paperLand.getModelComponent( 'isActiveCardP2Ice' );\n        modelComponent.value = newValue;  \n      }\n      \nconst setIsActiveCardP2Fire = newValue => {\n        const modelComponent = phet.paperLand.getModelComponent( 'isActiveCardP2Fire' );\n        modelComponent.value = newValue;  \n      }\n      \n      \n          // the code block that the user wrote to change controlled Properties\n          if (playArea.containsPoint(p1FireImgPosition)) {\n    setIsActiveCardP1Fire(true);\n    setIsActiveCardP1Ice(false);\n    setIsActiveCardP1Tornado(false);\n\n    phet.paperLand.console.log(isActiveCardP1Fire);\n    phet.paperLand.console.log(isActiveCardP1Tornado);\n    phet.paperLand.console.log(isActiveCardP1Ice);\n\n} else if (playArea.containsPoint(p1IceImgPosition)) {\n    setIsActiveCardP1Fire(false);\n    setIsActiveCardP1Ice(true);\n    setIsActiveCardP1Tornado(false);\n\n    phet.paperLand.console.log(isActiveCardP1Fire);\n    phet.paperLand.console.log(isActiveCardP1Tornado);\n    phet.paperLand.console.log(isActiveCardP1Ice);\n\n} else if (playArea.containsPoint(p1TornadoImgPosition)) {\n    setIsActiveCardP1Fire(false);\n    setIsActiveCardP1Ice(false);\n    setIsActiveCardP1Tornado(true);\n\n    phet.paperLand.console.log(isActiveCardP1Fire);\n    phet.paperLand.console.log(isActiveCardP1Tornado);\n    phet.paperLand.console.log(isActiveCardP1Ice);\n\n} else {\n    setIsActiveCardP1Fire(false);\n    setIsActiveCardP1Ice(false);\n    setIsActiveCardP1Tornado(false);\n\n    phet.paperLand.console.log(isActiveCardP1Fire);\n    phet.paperLand.console.log(isActiveCardP1Tornado);\n    phet.paperLand.console.log(isActiveCardP1Ice);\n}\n\nif (playArea.containsPoint(p2TornadoImgPosition)) {\n    setIsActiveCardP2Tornado(true);\n    setIsActiveCardP2Ice(false);\n    setIsActiveCardP2Fire(false);\n} else if (playArea.containsPoint(p2IceImgPosition)) {\n    setIsActiveCardP2Tornado(false);\n    setIsActiveCardP2Ice(true);\n    setIsActiveCardP2Fire(false);\n} else if (playArea.containsPoint(p2FireImgPosition)) {\n    setIsActiveCardP2Tornado(false);\n    setIsActiveCardP2Ice(false);\n    setIsActiveCardP2Fire(true);\n} else {\n    setIsActiveCardP2Tornado(false);\n    setIsActiveCardP2Ice(false);\n    setIsActiveCardP2Fire(false);\n}\n\n// if (playArea.containsPoint(p1FireImgPosition)) {\n//     setIsActiveCardP1Fire(true);\n//     setIsActiveCardP1Ice(false);\n//     setIsActiveCardP1Tornado(false);\n// } else if (playArea.containsPoint(p1IceImgPosition) && !isActiveCardP1Fire) {\n//     setIsActiveCardP1Fire(false);\n//     setIsActiveCardP1Ice(true);\n//     setIsActiveCardP1Tornado(false);\n// } else if (playArea.containsPoint(p1TornadoImgPosition) && !isActiveCardP1Fire && !isActiveCardP1Ice) {\n//     setIsActiveCardP1Fire(false);\n//     setIsActiveCardP1Ice(false);\n//     setIsActiveCardP1Tornado(true);\n// } else {\n//     setIsActiveCardP1Fire(false);\n//     setIsActiveCardP1Ice(false);\n//     setIsActiveCardP1Tornado(false);\n// }\n\n// if (playArea.containsPoint(p2TornadoImgPosition)) {\n//     setIsActiveCardP2Tornado(true);\n//     setIsActiveCardP2Ice(false);\n//     setIsActiveCardP2Fire(false);\n// } else if (playArea.containsPoint(p2IceImgPosition) && !isActiveCardP2Tornado) {\n//     setIsActiveCardP2Tornado(false);\n//     setIsActiveCardP2Ice(true);\n//     setIsActiveCardP2Fire(false);\n// } else if (playArea.containsPoint(p2FireImgPosition) && !isActiveCardP2Tornado && !isActiveCardP2Ice) {\n//     setIsActiveCardP2Tornado(false);\n//     setIsActiveCardP2Ice(false);\n//     setIsActiveCardP2Fire(true);\n// } else {\n//     setIsActiveCardP2Tornado(false);\n//     setIsActiveCardP2Ice(false);\n//     setIsActiveCardP2Fire(false);\n// }   \n        }\n      } );\n    \n\n      scratchpad.DetermineWinnerMultilinkId = phet.paperLand.addModelPropertyMultilink( [ 'isActiveCardP1Fire', 'isActiveCardP1Ice', 'isActiveCardP1Tornado', 'isActiveCardP2Tornado', 'isActiveCardP2Ice', 'isActiveCardP2Fire' ], ( isActiveCardP1Fire, isActiveCardP1Ice, isActiveCardP1Tornado, isActiveCardP2Tornado, isActiveCardP2Ice, isActiveCardP2Fire ) => {\n      \n        // We have behavior with components outside of the multilink that may not exist yet, we only do this\n        // work if all are available\n        if ( phet.paperLand.hasAllModelComponents( [ 'IsP1Winner', 'IsP2Winner' ] ) ) {\n        \n          // references to the model components that are controlled by this listener AND the model compnoents\n          // that are selected as references\n          const IsP1Winner = phet.paperLand.getModelComponent( 'IsP1Winner' ).value;\nconst IsP2Winner = phet.paperLand.getModelComponent( 'IsP2Winner' ).value;\n      \n          // the functions that are available to the client from their selected dependencies\n          const setIsP1Winner = newValue => {\n        const modelComponent = phet.paperLand.getModelComponent( 'IsP1Winner' );\n        modelComponent.value = newValue;  \n      }\n      \nconst setIsP2Winner = newValue => {\n        const modelComponent = phet.paperLand.getModelComponent( 'IsP2Winner' );\n        modelComponent.value = newValue;  \n      }\n      \n      \n          // the code block that the user wrote to change controlled Properties\n          \n// Fire beats Ice\nif (isActiveCardP1Fire && isActiveCardP2Ice) {\n    setIsP1Winner(true);\n    setIsP2Winner(false);\n} else if (isActiveCardP1Ice && isActiveCardP2Fire) {\n    setIsP1Winner(false);\n    setIsP2Winner(true);\n}\n// Ice beats Tornado\nelse if (isActiveCardP1Ice && isActiveCardP2Tornado) {\n    setIsP1Winner(true);\n    setIsP2Winner(false);\n} else if (isActiveCardP1Tornado && isActiveCardP2Ice) {\n    setIsP1Winner(false);\n    setIsP2Winner(true);\n}\n// Tornado beats Fire\nelse if (isActiveCardP1Tornado && isActiveCardP2Fire) {\n    setIsP1Winner(true);\n    setIsP2Winner(false);\n} else if (isActiveCardP1Fire && isActiveCardP2Tornado) {\n    setIsP1Winner(false);\n    setIsP2Winner(true);\n}\n// Handles the case where both players choose the same card\nelse if ((isActiveCardP1Fire && isActiveCardP2Fire) || (isActiveCardP1Ice && isActiveCardP2Ice) || (isActiveCardP1Tornado && isActiveCardP2Tornado)) {\n    setIsP1Winner(false);\n    setIsP2Winner(false);\n} else {\n    // Fallback for any unhandled cases\n    setIsP1Winner(false);\n    setIsP2Winner(false);\n}\n   \n        }\n      } );\n    \n  };\n\n  const onProgramRemoved = ( paperNumber, scratchpad, sharedData ) => {\n    \n      // Remove the component from the model\n      phet.paperLand.removeModelComponent( 'IsP1Winner' );\n    \n\n      // Remove the component from the model\n      phet.paperLand.removeModelComponent( 'IsP2Winner' );\n    \n\n      // Remove the component from the model\n      phet.paperLand.removeModelComponent( 'playArea' );\n    \n\n     // Remove the component from the model\n      phet.paperLand.removeModelComponent( 'p1CardArrayAddedItem' );\n    \n\n     // Remove the component from the model\n      phet.paperLand.removeModelComponent( 'p1CardArrayRemovedItem' );\n    \n\n     // Remove the component from the model\n      phet.paperLand.removeModelComponent( 'p2CardArrayAddedItem' );\n    \n\n     // Remove the component from the model\n      phet.paperLand.removeModelComponent( 'p2CardArrayRemovedItem' );\n    \n\n      // Remove the component from the model\n      phet.paperLand.removeModelComponent( 'p1CardArray' );\n    \n\n      // Remove the component from the model\n      phet.paperLand.removeModelComponent( 'p2CardArray' );\n    \n\n\n      // remove the multilink updating the value    \n      phet.paperLand.removeModelPropertyMultilink( [ 'p1CardArray' ], scratchpad.p1CardArrayLengthDerivedPropertyObserverId );\n      delete scratchpad.p1CardArrayLengthDerivedPropertyObserverId;\n      \n      // remove the derived Property from the model\n      phet.paperLand.removeModelComponent( 'p1CardArrayLength' );\n    \n\n\n      // remove the multilink updating the value    \n      phet.paperLand.removeModelPropertyMultilink( [ 'p2CardArray' ], scratchpad.p2CardArrayLengthDerivedPropertyObserverId );\n      delete scratchpad.p2CardArrayLengthDerivedPropertyObserverId;\n      \n      // remove the derived Property from the model\n      phet.paperLand.removeModelComponent( 'p2CardArrayLength' );\n    \n\n      phet.tambo.soundManager.removeSoundGenerator( scratchpad.winningSoundSoundClip );\n      delete scratchpad.winningSoundSoundClip;\n      \n      scratchpad.winningSoundWrappedAudioBuffer.audioBufferProperty.unlink( scratchpad.winningSoundWrappedAudioBufferListener );\n      delete scratchpad.winningSoundWrappedAudioBufferListener;\n      \n      phet.paperLand.removeModelPropertyMultilink( [ 'IsP1Winner', 'IsP2Winner' ], scratchpad.winningSoundSoundMultilinkId, {\n        otherReferences: [  ]\n       } );\n      delete scratchpad.winningSoundSoundMultilinkId;\n    \n\n      // Remove the image from the view.\n      sharedData.scene.removeChild( scratchpad.playAreaImageImage );\n      delete scratchpad.playAreaImageImage;\n      \n      // Remove the multilink\n      phet.paperLand.removeModelPropertyMultilink( [ 'playArea' ], scratchpad.playAreaImageImageMultilinkId, {\n        otherReferences: [  ]\n      } );\n      delete scratchpad.playAreaImageImageMultilinkId;\n    \n\n    \n      // Remove the Path from the view\n      sharedData.scene.removeChild( scratchpad.playAreaViewPath );\n      delete scratchpad.playAreaViewPath;\n      \n      // Remove the multilink\n      phet.paperLand.removeModelPropertyMultilink( [ 'playArea' ], scratchpad.playAreaViewPathMultilinkId, {\n        otherReferences: [  ]\n      } );\n      delete scratchpad.playAreaViewPathMultilinkId;\n    \n\n    \n      // Remove the Path from the view\n      sharedData.scene.removeChild( scratchpad.isP1WinnerTruthTellerPath );\n      delete scratchpad.isP1WinnerTruthTellerPath;\n      \n      // Remove the multilink\n      phet.paperLand.removeModelPropertyMultilink( [ 'IsP1Winner' ], scratchpad.isP1WinnerTruthTellerPathMultilinkId, {\n        otherReferences: [  ]\n      } );\n      delete scratchpad.isP1WinnerTruthTellerPathMultilinkId;\n    \n\n      phet.paperLand.removeModelPropertyMultilink( [ 'p1FireImgPosition', 'p1IceImgPosition', 'p1TornadoImgPosition', 'playArea', 'p2TornadoImgPosition', 'p2IceImgPosition', 'p2FireImgPosition' ], scratchpad.setActiveCardsControllerMultilinkId );\n      delete scratchpad.setActiveCardsControllerMultilinkId;\n    \n\n      phet.paperLand.removeModelPropertyMultilink( [ 'isActiveCardP1Fire', 'isActiveCardP1Ice', 'isActiveCardP1Tornado', 'isActiveCardP2Tornado', 'isActiveCardP2Ice', 'isActiveCardP2Fire' ], scratchpad.DetermineWinnerMultilinkId );\n      delete scratchpad.DetermineWinnerMultilinkId;\n    \n  };\n\n  const onProgramChangedPosition = ( paperNumber, points, scratchpad, sharedData ) => {\n    \n  };\n  \n  const onProgramMarkersAdded = ( paperNumber, points, scratchpad, sharedData, markers ) => {\n    \n  };\n  \n  const onProgramMarkersRemoved = ( paperNumber, points, scratchpad, sharedData, markers ) => {\n    \n  };\n  \n  const onProgramMarkersChangedPosition = ( paperNumber, points, scratchpad, sharedData, markers ) => {\n    \n  };\n  \n  const onProgramAdjacent = ( paperNumber, otherPaperNumber, direction, scratchpad, sharedData ) => {\n    \n  };\n  \n  const onProgramSeparated = ( paperNumber, otherPaperNumber, direction, scratchpad, sharedData ) => {\n    \n  };\n\n  await paper.set( 'data', {\n    paperPlaygroundData: {\n      updateTime: Date.now(),\n      eventHandlers: {\n        onProgramAdded: onProgramAdded.toString(),\n        onProgramRemoved: onProgramRemoved.toString(),\n        onProgramChangedPosition: onProgramChangedPosition.toString(),\n        onProgramMarkersAdded: onProgramMarkersAdded.toString(),\n        onProgramMarkersRemoved: onProgramMarkersRemoved.toString(),\n        onProgramMarkersChangedPosition: onProgramMarkersChangedPosition.toString(),\n        onProgramAdjacent: onProgramAdjacent.toString(),\n        onProgramSeparated: onProgramSeparated.toString(),\n      },\n      customWhiskerLengths: {\n        top: 0.2,\n        right: 0.2,\n        bottom: 0.2,\n        left: 0.2\n      }\n    }\n  } );\n  \n  // PROJECTOR CODE //\n  // Get a canvas object for this paper to draw something to the Projector.\n  const canvas = await paper.get('canvas');\n\n  // Draw the name of the program to the projector\n  const ctx = canvas.getContext('2d');\n  ctx.font = '20px sans-serif';\n  ctx.textAlign = 'center';\n  ctx.fillStyle = 'rgb(255,0,0)';\n  ctx.fillText('', canvas.width / 2, canvas.height / 2 - 10);\n  ctx.fillStyle = 'rgb(0,255,0)';\n  ctx.font = '10px sans-serif';\n  ctx.fillText('Paper Elements Game Model', canvas.width / 2, canvas.height / 2 + 20);\n})();\n",
  "printed": false,
  "editorInfo": {},
  "currentCodeUrl": "program.creator-card-games.9.js",
  "currentCodeHash": "",
  "debugUrl": "/api/spaces/creator-card-games/programs/9/debugInfo",
  "claimUrl": "/api/spaces/creator-card-games/programs/9/claim",
  "codeHasChanged": false,
  "debugInfo": "{\"logs\":[]}"
}