{
  "number": 725,
  "originalCode": "// Light Source\n// Keywords: \n// =============================== //\n// Program Dependencies: N/A\n// Recommended Programs: \n// Program Description: This is the source of light. All programs touching this one\n// or connected to other light programs in the chain will light up themselves.\n\nimportScripts('paper.js');\n\n(async () => {\n\n  const onProgramAdded = ( paperProgramNumber, scratchpad, sharedData ) => {\n\n    // black background so it is easier to see light\n    scratchpad.backgroundRectangle = new phet.scenery.Rectangle( 0, 0, sharedData.displaySize.width, sharedData.displaySize.height, {\n      fill: 'black'\n    } );\n    sharedData.scene.addChild( scratchpad.backgroundRectangle );\n    scratchpad.backgroundRectangle.moveToBack();\n\n    // Create a Scenery image node for a light and add it to the scene\n    const onImageElement = document.createElement( 'img' );\n    onImageElement.setAttribute( 'src', 'media/images/on-bulb.png' );\n    const onImageNode = new phet.scenery.Image( onImageElement, {\n      maxWidth: 120\n    } );\n    sharedData.scene.addChild( onImageNode );\n    scratchpad.onImageNode = onImageNode;\n\n    // A data structure to help represent a connected tree of elements\n    class ConnectionElement {\n\n      // @param {boolean} - is this the root element?\n      constructor( isRoot ) {\n        this.children = [];\n        this.parent = null;\n\n        // A flag to indicate this is the root of the tree\n        this.isRoot = isRoot;\n\n        // This will change with connection to the root, but root element is always lit\n        this.isLitProperty = new phet.axon.BooleanProperty( isRoot );\n      }\n\n      // Add a child (and its subtree) to this ConnectionElement\n      addChild( element ) {\n\n        // only add as a child if the other element has not been added and if it this element \n        // is not already a child (easy to happen with whisker connections)\n        if ( element.parent === null && !element.children.includes( this ) ) {\n          this.children.push( element );\n          element.parent = this;\n\n          // update lit status for entire subtree on this connection\n          element.setLit( this.isLitProperty.value );\n        }\n      }\n\n      // Remove a child (and its subtree) from this connectionElement\n      removeChild( element ) {\n        const indexOfElement = this.children.indexOf( element );\n        if ( indexOfElement > -1 ) {\n          this.children.splice( indexOfElement, 1 );\n\n          element.parent = null;\n\n          // The child is removed from a parent - it is only lit if it is somehow still \n          // connected to the root\n          element.setLit( element.isConnectedToSource() );\n        }\n      }\n\n      // Detach from the graph entirely, removing self from parents and removing any children\n      dispose() {\n\n        // remove self from any parents\n        if ( this.parent ) {\n          this.parent.removeChild( this );\n        }\n\n        // remove any children\n        this.children.forEach( child => {\n          this.removeChild( child );\n        } );\n      }\n\n      // Set the lit status for this element and all its descendants.\n      setLit( lit ) {\n        this.isLitProperty.value = lit;\n\n        // recursively update all children.\n        this.children.forEach( child => {\n           child.setLit( lit );\n        } );\n      }\n\n      // Returns true if this element is connected through parents to a light source\n      isConnectedToSource() {\n        if ( this.parent === null ) {\n          return this.isRoot;\n        }\n        else {\n\n          // recursively look up the tree\n          return this.parent.isConnectedToSource();\n        }\n      }\n    }\n\n    // Add the ConnectionElement constructor to the model so it can be used when available\n    phet.paperLand.addModelComponent( 'connectionElementConstructor', ConnectionElement );\n\n    const rootElement = new ConnectionElement( true );\n    phet.paperLand.addModelComponent( 'rootElement', rootElement );\n\n    // Add this element to the program data itself so that adjacent programs can find it\n    phet.paperLand.setProgramData( paperProgramNumber, 'connectionElement', rootElement );\n  };\n\n  const onProgramRemoved = ( paperProgramNumber, scratchpad, sharedData ) => {\n    sharedData.scene.removeChild( scratchpad.onImageNode );\n    delete scratchpad.onImageNode;\n\n    sharedData.scene.removeChild( scratchpad.backgroundRectangle );\n    delete scratchpad.backgroundRectangle;\n\n    phet.paperLand.removeModelComponent( 'rootElement' );\n\n    phet.paperLand.removeModelComponent( 'connectionElementConstructor' );\n  };\n\n  const onProgramAdjacent = ( programNumber, otherProgramNumber, direction, scratchpad, sharedData ) => {\n    phet.paperLand.console.log( `${otherProgramNumber} ${direction} of ${programNumber}` );\n  };\n\n  const onProgramSeparated = ( programNumber, otherProgramNumber, direction, scratchpad, sharedData ) => {\n    phet.paperLand.console.log( `${otherProgramNumber} detached from ${programNumber} ${direction}` );\n  };\n\n  // Called when the program moves.\n  const onProgramChangedPosition = ( paperProgramNumber, positionPoints, scratchpad, sharedData ) => {\n\n    // Center the image based on the position of the paper.\n    const paperCenterX = ( positionPoints[0].x + positionPoints[1].x ) / 2;\n    const paperCenterY = ( positionPoints[0].y + positionPoints[2].y ) / 2;\n    scratchpad.onImageNode.centerX = paperCenterX * sharedData.displaySize.width;\n    scratchpad.onImageNode.centerY = paperCenterY * sharedData.displaySize.height;\n  };\n\n  // Add the state change handler defined above as data for this paper.\n  await paper.set('data', {\n    paperPlaygroundData: {\n      updateTime: Date.now(),\n      eventHandlers: {\n        onProgramAdded: onProgramAdded.toString(),\n        onProgramRemoved: onProgramRemoved.toString(),\n        onProgramChangedPosition: onProgramChangedPosition.toString(),\n        onProgramAdjacent: onProgramAdjacent.toString(),\n        onProgramSeparated: onProgramSeparated.toString()\n      }\n    }\n  } );\n\n  //----------------------------------------------------------------------\n  // Projector code\n  //----------------------------------------------------------------------\n\n  const canvas = await paper.get('canvas');\n\n  // Draw \"Hello world\" on the canvas.\n  const ctx = canvas.getContext('2d');\n  ctx.font = '20px sans-serif';\n  ctx.textAlign = 'center';\n  ctx.fillStyle = 'rgb(255,0,0)';\n  ctx.fillText('Whisker A', canvas.width / 2, canvas.height / 2 - 10);\n\n  // Get a \"supporter canvas\", which is a canvas for the entire\n  // projection surface.\n  const supporterCanvas = await paper.get('supporterCanvas');\n  const supporterCtx = supporterCanvas.getContext('2d');\n})();\n\n",
  "currentCode": "// Light Source\n// Keywords: \n// =============================== //\n// Program Dependencies: N/A\n// Recommended Programs: \n// Program Description: This is the source of light. All programs touching this one\n// or connected to other light programs in the chain will light up themselves.\n\nimportScripts('paper.js');\n\n(async () => {\n\n  const onProgramAdded = ( paperProgramNumber, scratchpad, sharedData ) => {\n\n    // black background so it is easier to see light\n    scratchpad.backgroundRectangle = new phet.scenery.Rectangle( 0, 0, sharedData.displaySize.width, sharedData.displaySize.height, {\n      fill: 'black'\n    } );\n    sharedData.scene.addChild( scratchpad.backgroundRectangle );\n    scratchpad.backgroundRectangle.moveToBack();\n\n    // Create a Scenery image node for a light and add it to the scene\n    const onImageElement = document.createElement( 'img' );\n    onImageElement.setAttribute( 'src', 'media/images/on-bulb.png' );\n    const onImageNode = new phet.scenery.Image( onImageElement, {\n      maxWidth: 120\n    } );\n    sharedData.scene.addChild( onImageNode );\n    scratchpad.onImageNode = onImageNode;\n\n    // A data structure to help represent a connected tree of elements\n    class ConnectionElement {\n\n      // @param {boolean} - is this the root element?\n      constructor( isRoot ) {\n        this.children = [];\n        this.parent = null;\n\n        // A flag to indicate this is the root of the tree\n        this.isRoot = isRoot;\n\n        // This will change with connection to the root, but root element is always lit\n        this.isLitProperty = new phet.axon.BooleanProperty( isRoot );\n      }\n\n      // Add a child (and its subtree) to this ConnectionElement\n      addChild( element ) {\n\n        // only add as a child if the other element has not been added and if it this element \n        // is not already a child (easy to happen with whisker connections)\n        if ( element.parent === null && !element.children.includes( this ) ) {\n          this.children.push( element );\n          element.parent = this;\n\n          // update lit status for entire subtree on this connection\n          element.setLit( this.isLitProperty.value );\n        }\n      }\n\n      // Remove a child (and its subtree) from this connectionElement\n      removeChild( element ) {\n        const indexOfElement = this.children.indexOf( element );\n        if ( indexOfElement > -1 ) {\n          this.children.splice( indexOfElement, 1 );\n\n          element.parent = null;\n\n          // The child is removed from a parent - it is only lit if it is somehow still \n          // connected to the root\n          element.setLit( element.isConnectedToSource() );\n        }\n      }\n\n      // Detach from the graph entirely, removing self from parents and removing any children\n      dispose() {\n\n        // remove self from any parents\n        if ( this.parent ) {\n          this.parent.removeChild( this );\n        }\n\n        // remove any children\n        this.children.forEach( child => {\n          this.removeChild( child );\n        } );\n      }\n\n      // Set the lit status for this element and all its descendants.\n      setLit( lit ) {\n        this.isLitProperty.value = lit;\n\n        // recursively update all children.\n        this.children.forEach( child => {\n           child.setLit( lit );\n        } );\n      }\n\n      // Returns true if this element is connected through parents to a light source\n      isConnectedToSource() {\n        if ( this.parent === null ) {\n          return this.isRoot;\n        }\n        else {\n\n          // recursively look up the tree\n          return this.parent.isConnectedToSource();\n        }\n      }\n    }\n\n    // Add the ConnectionElement constructor to the model so it can be used when available\n    phet.paperLand.addModelComponent( 'connectionElementConstructor', ConnectionElement );\n\n    const rootElement = new ConnectionElement( true );\n    phet.paperLand.addModelComponent( 'rootElement', rootElement );\n\n    // Add this element to the program data itself so that adjacent programs can find it\n    phet.paperLand.setProgramData( paperProgramNumber, 'connectionElement', rootElement );\n  };\n\n  const onProgramRemoved = ( paperProgramNumber, scratchpad, sharedData ) => {\n    sharedData.scene.removeChild( scratchpad.onImageNode );\n    delete scratchpad.onImageNode;\n\n    sharedData.scene.removeChild( scratchpad.backgroundRectangle );\n    delete scratchpad.backgroundRectangle;\n\n    phet.paperLand.removeModelComponent( 'rootElement' );\n\n    phet.paperLand.removeModelComponent( 'connectionElementConstructor' );\n  };\n\n  const onProgramAdjacent = ( programNumber, otherProgramNumber, direction, scratchpad, sharedData ) => {\n    phet.paperLand.console.log( `${otherProgramNumber} ${direction} of ${programNumber}` );\n  };\n\n  const onProgramSeparated = ( programNumber, otherProgramNumber, direction, scratchpad, sharedData ) => {\n    phet.paperLand.console.log( `${otherProgramNumber} detached from ${programNumber} ${direction}` );\n  };\n\n  // Called when the program moves.\n  const onProgramChangedPosition = ( paperProgramNumber, positionPoints, scratchpad, sharedData ) => {\n\n    // Center the image based on the position of the paper.\n    const paperCenterX = ( positionPoints[0].x + positionPoints[1].x ) / 2;\n    const paperCenterY = ( positionPoints[0].y + positionPoints[2].y ) / 2;\n    scratchpad.onImageNode.centerX = paperCenterX * sharedData.displaySize.width;\n    scratchpad.onImageNode.centerY = paperCenterY * sharedData.displaySize.height;\n  };\n\n  // Add the state change handler defined above as data for this paper.\n  await paper.set('data', {\n    paperPlaygroundData: {\n      updateTime: Date.now(),\n      eventHandlers: {\n        onProgramAdded: onProgramAdded.toString(),\n        onProgramRemoved: onProgramRemoved.toString(),\n        onProgramChangedPosition: onProgramChangedPosition.toString(),\n        onProgramAdjacent: onProgramAdjacent.toString(),\n        onProgramSeparated: onProgramSeparated.toString()\n      }\n    }\n  } );\n\n  //----------------------------------------------------------------------\n  // Projector code\n  //----------------------------------------------------------------------\n\n  const canvas = await paper.get('canvas');\n\n  // Draw \"Hello world\" on the canvas.\n  const ctx = canvas.getContext('2d');\n  ctx.font = '20px sans-serif';\n  ctx.textAlign = 'center';\n  ctx.fillStyle = 'rgb(255,0,0)';\n  ctx.fillText('Whisker A', canvas.width / 2, canvas.height / 2 - 10);\n\n  // Get a \"supporter canvas\", which is a canvas for the entire\n  // projection surface.\n  const supporterCanvas = await paper.get('supporterCanvas');\n  const supporterCtx = supporterCanvas.getContext('2d');\n})();\n\n",
  "printed": false,
  "editorInfo": {},
  "currentCodeUrl": "program.whisker-demo-1.725.js",
  "currentCodeHash": "",
  "debugUrl": "/api/spaces/whisker-demo-1/programs/725/debugInfo",
  "claimUrl": "/api/spaces/whisker-demo-1/programs/725/claim",
  "codeHasChanged": false,
  "debugInfo": "{\"logs\":[]}"
}