{
  "number": 1244,
  "originalCode": "// Lander\r\n// Keywords: body, physics, p2, model\r\n// ------------------------------- //\r\n// Required Programs (dependencies): World\r\n// Recommended Programs:\r\n// Program Description:\r\n\r\nimportScripts('paper.js');\r\n\r\n(async () => {\r\n\r\n  //----------------------------------------------------------------------\r\n  // Board code\r\n  //----------------------------------------------------------------------\r\n\r\n  // Called when the program is detected or changed.\r\n  const onProgramAdded = ( paperProgramNumber, scratchpad, sharedData ) => {\r\n\r\n    // create a body with p2\r\n    const shipShape = new p2.Box( { width: 75, height: 45 } );\r\n    scratchpad.shipBody = new p2.Body( {\r\n      mass: 1, // initial mass, to be updated\r\n      position: [ 0, 200 ], // initial position\r\n      ccdSpeedThreshold: 100, // when moving fast, enable more expensive collision detection\r\n      fixedRotation: true // don't let this physical body rotate\r\n    } );\r\n    scratchpad.shipBody.addShape( shipShape );\r\n\r\n    // add the body to the paper land model\r\n    phet.paperLand.addModelComponent( 'lander', scratchpad.shipBody );\r\n\r\n    // create an axon Property for each physical attribute of the lander you care about - all to be updated\r\n    // by the p2 physics engine\r\n    const landerPositionProperty = new phet.axon.Property( new phet.dot.Vector2( 0, 0 ) );\r\n    const landerVelocityProperty = new phet.axon.Property( new phet.dot.Vector2( 0, 0 ) );\r\n    const landerAccelerationProperty = new phet.axon.Property( new phet.dot.Vector2( 0, 0 ) );\r\n    const landerForceProperty = new phet.axon.Property( new phet.dot.Vector2( 0, 0 ) );\r\n    const landerThrustProperty = new phet.axon.Property( new phet.dot.Vector2( 0, 0 ) );\r\n    const landerMassProperty = new phet.axon.Property( 1 );\r\n    phet.paperLand.addModelComponent( 'landerThrustProperty', landerThrustProperty );\r\n    phet.paperLand.addModelComponent( 'landerPositionProperty', landerPositionProperty );\r\n    phet.paperLand.addModelComponent( 'landerVelocityProperty', landerVelocityProperty );\r\n    phet.paperLand.addModelComponent( 'landerAccelerationProperty', landerAccelerationProperty );\r\n    phet.paperLand.addModelComponent( 'landerForceProperty', landerForceProperty );\r\n    phet.paperLand.addModelComponent( 'landerMassProperty', landerMassProperty );\r\n\r\n    // Create a visualization for the lander itself\r\n    // Create a Scenery image node.\r\n    const imageElement = document.createElement( 'img' );\r\n    imageElement.setAttribute( 'src', 'media/images/lunarLander.png' );\r\n    // imageElement.setAttribute( 'src', 'media/images/hotairballoon.png' );    \r\n    scratchpad.imageNode = new phet.scenery.Image( imageElement, {\r\n      minWidth: 150,\r\n      maxWidth: 150\r\n    } );\r\n    sharedData.scene.addChild( scratchpad.imageNode );\r\n\r\n    // when the world is available, add the lander to it and listeners that will update model\r\n    // from the p2 physics\r\n    const handleWorldExists = world => {\r\n      world.addBody( scratchpad.shipBody );\r\n\r\n      // TODO: This component needs many model other components to work (world, worldStepEmitter, modeltoViewPosition).\r\n      // It would be better if we could observer many model components with a `handleComponentsExist` type function.\r\n      // Instead, we have to nest these 'handleComponentExists' calls.\r\n      const handleWorldStepEmitterExists = worldStepEmitter => {\r\n        scratchpad.worldStepListener = () => {\r\n\r\n          // after p2 physics updated the body, update Properties for the lander\r\n          const positionArray = scratchpad.shipBody.position;\r\n          landerPositionProperty.set( new phet.dot.Vector2( positionArray[ 0 ], positionArray[ 1 ] ) );\r\n\r\n          const velocityArray = scratchpad.shipBody.velocity;\r\n          landerVelocityProperty.set( new phet.dot.Vector2( velocityArray[ 0 ], velocityArray[ 1 ] ) );\r\n\r\n          const forceArray = scratchpad.shipBody.force;\r\n          landerForceProperty.set( new phet.dot.Vector2( forceArray[ 0 ], forceArray[ 1 ] ) );\r\n\r\n          // because F = mA (acceleration is not a field in p2)\r\n          const mass = landerMassProperty.value;\r\n          landerAccelerationProperty.set( new phet.dot.Vector2( forceArray[ 0 ] / mass, forceArray[ 1 ] / mass ) );\r\n\r\n          // re-position the view rectangle\r\n          const viewPosition = sharedData.model.get( 'modelToViewPosition' )( landerPositionProperty.value );\r\n          scratchpad.imageNode.center = viewPosition;\r\n        };\r\n\r\n        worldStepEmitter.addListener( scratchpad.worldStepListener );\r\n      };\r\n\r\n      const handleWorldStepEmitterRemoved = worldStepEmitter => {\r\n        worldStepEmitter.removeListener( scratchpad.worldStepListener );\r\n        delete scratchpad.worldStepListener;\r\n      };\r\n\r\n      // When the step emitter is available from the model, use it\r\n      scratchpad.stepObserverId = phet.paperLand.addModelObserver(\r\n        'worldStepEmitter',\r\n        handleWorldStepEmitterExists,\r\n        handleWorldStepEmitterRemoved\r\n      );\r\n    }\r\n\r\n    // when the world is removed, remove the lander from it\r\n    const handleWorldRemoved = world => {\r\n      world.removeBody( scratchpad.shipBody );\r\n\r\n      phet.paperLand.removeModelObserver( 'worldStepEmitter', scratchpad.stepObserverId );\r\n      delete scratchpad.stepObserverId;\r\n    };\r\n\r\n    // Attach/detach the lander when the world is available in the model\r\n    scratchpad.observerId = phet.paperLand.addModelObserver(\r\n      'world',\r\n      handleWorldExists,\r\n      handleWorldRemoved\r\n    );\r\n\r\n    // update the mass for the p2 lander body when the model Property changes\r\n    scratchpad.massObserverId = phet.paperLand.addModelPropertyLink( 'landerMassProperty', mass => {\r\n      scratchpad.shipBody.mass = mass;\r\n    } );\r\n\r\n    // Apply thrust over time\r\n    scratchpad.timerListener = dt => {\r\n      if ( sharedData.model.has( 'landerThrustProperty' ) ) {\r\n        const thrust = sharedData.model.get( 'landerThrustProperty' ).value;\r\n        scratchpad.shipBody.applyForceLocal( [ thrust.x, thrust.y ], [ 0, 0 ] );\r\n      }\r\n    }\r\n    phet.axon.stepTimer.addListener( scratchpad.timerListener );\r\n  };\r\n\r\n  // Called when the paper positions change.\r\n  const onProgramChangedPosition = ( paperProgramNumber, positionPoints, scratchpad, sharedData ) => {\r\n\r\n    if ( sharedData.model.has( 'viewToModelPosition' ) ) {\r\n      \r\n      // whenever the program is moved, set that as the new lander position and reset all kinematic values\r\n      const paperCenterX = ( positionPoints[ 0 ].x + positionPoints[ 2 ].x ) / 2;\r\n      const paperCenterY = ( positionPoints[ 0 ].y + positionPoints[ 2 ].y ) / 2;\r\n\r\n      const centerX = paperCenterX * sharedData.displaySize.width;\r\n      const centerY = paperCenterY * sharedData.displaySize.height;\r\n      const viewCenter = new phet.dot.Vector2( centerX, centerY );\r\n\r\n      // The model has a utility function to convert from view to model coordinates (since papers\r\n      // are in view coordinates).\r\n      const modelPosition = sharedData.model.get( 'viewToModelPosition' )( viewCenter );\r\n\r\n      scratchpad.shipBody.position = [ modelPosition.x, modelPosition.y ];\r\n      scratchpad.shipBody.velocity = [ 0, 0 ];\r\n      scratchpad.shipBody.force = [ 0, 0 ]; \r\n    }\r\n  };\r\n\r\n  // Called when the program is changed or no longer detected.\r\n  const onProgramRemoved = ( paperProgramNumber, scratchpad, sharedData ) => {\r\n    phet.paperLand.removeModelObserver( 'world', scratchpad.observerId );\r\n    delete scratchpad.observerId;\r\n\r\n    phet.paperLand.removeModelPropertyLink( 'landerMassProperty', scratchpad.massObserverId );\r\n    delete scratchpad.massObserverId;\r\n\r\n    phet.paperLand.removeModelComponent( 'lander' );\r\n\r\n    phet.paperLand.removeModelComponent( 'landerPositionProperty' );\r\n    phet.paperLand.removeModelComponent( 'landerVelocityProperty' );\r\n    phet.paperLand.removeModelComponent( 'landerAccelerationProperty' );\r\n    phet.paperLand.removeModelComponent( 'landerForceProperty' );\r\n    phet.paperLand.removeModelComponent( 'landerThrustProperty' );\r\n    phet.paperLand.removeModelComponent( 'landerMassProperty' );\r\n\r\n    phet.axon.stepTimer.removeListener( scratchpad.timerListener );\r\n    delete scratchpad.timerListener;\r\n\r\n    sharedData.scene.removeChild( scratchpad.imageNode );\r\n    delete scratchpad.imageNode;\r\n\r\n    delete scratchpad.shipBody;\r\n  };\r\n\r\n  // Add the state change handler defined above as data for this paper.\r\n  await paper.set('data', {\r\n    paperPlaygroundData: {\r\n      updateTime: Date.now(),\r\n      eventHandlers: {\r\n        onProgramAdded: onProgramAdded.toString(),\r\n        onProgramChangedPosition: onProgramChangedPosition.toString(),\r\n        onProgramRemoved: onProgramRemoved.toString()\r\n      }\r\n    }\r\n  } );\r\n\r\n  //----------------------------------------------------------------------\r\n  // Projector code\r\n  //----------------------------------------------------------------------\r\n\r\n  // Get a canvas object for this paper.\r\n  const canvas = await paper.get('canvas');\r\n\r\n  // Draw the name of the program on the canvas\r\n  const ctx = canvas.getContext('2d');\r\n  ctx.font = '20px sans-serif';\r\n  ctx.textAlign = 'center';\r\n  ctx.fillStyle = 'rgb(255,0,0)';\r\n  ctx.fillText('Lander', canvas.width / 2, canvas.height / 2 - 10);\r\n  ctx.fillStyle = 'rgb(0,255,0)';\r\n  ctx.fillText('Model', canvas.width / 2, canvas.height / 2 + 20);\r\n})();\r\n",
  "currentCode": "// Lander\r\n// Keywords: body, physics, p2, model\r\n// ------------------------------- //\r\n// Required Programs (dependencies): World\r\n// Recommended Programs:\r\n// Program Description:\r\n\r\nimportScripts('paper.js');\r\n\r\n(async () => {\r\n\r\n  //----------------------------------------------------------------------\r\n  // Board code\r\n  //----------------------------------------------------------------------\r\n\r\n  // Called when the program is detected or changed.\r\n  const onProgramAdded = ( paperProgramNumber, scratchpad, sharedData ) => {\r\n\r\n    // create a body with p2\r\n    const shipShape = new p2.Box( { width: 75, height: 45 } );\r\n    scratchpad.shipBody = new p2.Body( {\r\n      mass: 1, // initial mass, to be updated\r\n      position: [ 0, 200 ], // initial position\r\n      ccdSpeedThreshold: 100, // when moving fast, enable more expensive collision detection\r\n      fixedRotation: true // don't let this physical body rotate\r\n    } );\r\n    scratchpad.shipBody.addShape( shipShape );\r\n\r\n    // add the body to the paper land model\r\n    phet.paperLand.addModelComponent( 'lander', scratchpad.shipBody );\r\n\r\n    // create an axon Property for each physical attribute of the lander you care about - all to be updated\r\n    // by the p2 physics engine\r\n    const landerPositionProperty = new phet.axon.Property( new phet.dot.Vector2( 0, 0 ) );\r\n    const landerVelocityProperty = new phet.axon.Property( new phet.dot.Vector2( 0, 0 ) );\r\n    const landerAccelerationProperty = new phet.axon.Property( new phet.dot.Vector2( 0, 0 ) );\r\n    const landerForceProperty = new phet.axon.Property( new phet.dot.Vector2( 0, 0 ) );\r\n    const landerThrustProperty = new phet.axon.Property( new phet.dot.Vector2( 0, 0 ) );\r\n    const landerMassProperty = new phet.axon.Property( 1 );\r\n    phet.paperLand.addModelComponent( 'landerThrustProperty', landerThrustProperty );\r\n    phet.paperLand.addModelComponent( 'landerPositionProperty', landerPositionProperty );\r\n    phet.paperLand.addModelComponent( 'landerVelocityProperty', landerVelocityProperty );\r\n    phet.paperLand.addModelComponent( 'landerAccelerationProperty', landerAccelerationProperty );\r\n    phet.paperLand.addModelComponent( 'landerForceProperty', landerForceProperty );\r\n    phet.paperLand.addModelComponent( 'landerMassProperty', landerMassProperty );\r\n\r\n    // Create a visualization for the lander itself\r\n    // Create a Scenery image node.\r\n    const imageElement = document.createElement( 'img' );\r\n    imageElement.setAttribute( 'src', 'media/images/lunarLander.png' );\r\n    // imageElement.setAttribute( 'src', 'media/images/hotairballoon.png' );    \r\n    scratchpad.imageNode = new phet.scenery.Image( imageElement, {\r\n      minWidth: 150,\r\n      maxWidth: 150\r\n    } );\r\n    sharedData.scene.addChild( scratchpad.imageNode );\r\n\r\n    // when the world is available, add the lander to it and listeners that will update model\r\n    // from the p2 physics\r\n    const handleWorldExists = world => {\r\n      world.addBody( scratchpad.shipBody );\r\n\r\n      // TODO: This component needs many model other components to work (world, worldStepEmitter, modeltoViewPosition).\r\n      // It would be better if we could observer many model components with a `handleComponentsExist` type function.\r\n      // Instead, we have to nest these 'handleComponentExists' calls.\r\n      const handleWorldStepEmitterExists = worldStepEmitter => {\r\n        scratchpad.worldStepListener = () => {\r\n\r\n          // after p2 physics updated the body, update Properties for the lander\r\n          const positionArray = scratchpad.shipBody.position;\r\n          landerPositionProperty.set( new phet.dot.Vector2( positionArray[ 0 ], positionArray[ 1 ] ) );\r\n\r\n          const velocityArray = scratchpad.shipBody.velocity;\r\n          landerVelocityProperty.set( new phet.dot.Vector2( velocityArray[ 0 ], velocityArray[ 1 ] ) );\r\n\r\n          const forceArray = scratchpad.shipBody.force;\r\n          landerForceProperty.set( new phet.dot.Vector2( forceArray[ 0 ], forceArray[ 1 ] ) );\r\n\r\n          // because F = mA (acceleration is not a field in p2)\r\n          const mass = landerMassProperty.value;\r\n          landerAccelerationProperty.set( new phet.dot.Vector2( forceArray[ 0 ] / mass, forceArray[ 1 ] / mass ) );\r\n\r\n          // re-position the view rectangle\r\n          const viewPosition = sharedData.model.get( 'modelToViewPosition' )( landerPositionProperty.value );\r\n          scratchpad.imageNode.center = viewPosition;\r\n        };\r\n\r\n        worldStepEmitter.addListener( scratchpad.worldStepListener );\r\n      };\r\n\r\n      const handleWorldStepEmitterRemoved = worldStepEmitter => {\r\n        worldStepEmitter.removeListener( scratchpad.worldStepListener );\r\n        delete scratchpad.worldStepListener;\r\n      };\r\n\r\n      // When the step emitter is available from the model, use it\r\n      scratchpad.stepObserverId = phet.paperLand.addModelObserver(\r\n        'worldStepEmitter',\r\n        handleWorldStepEmitterExists,\r\n        handleWorldStepEmitterRemoved\r\n      );\r\n    }\r\n\r\n    // when the world is removed, remove the lander from it\r\n    const handleWorldRemoved = world => {\r\n      world.removeBody( scratchpad.shipBody );\r\n\r\n      phet.paperLand.removeModelObserver( 'worldStepEmitter', scratchpad.stepObserverId );\r\n      delete scratchpad.stepObserverId;\r\n    };\r\n\r\n    // Attach/detach the lander when the world is available in the model\r\n    scratchpad.observerId = phet.paperLand.addModelObserver(\r\n      'world',\r\n      handleWorldExists,\r\n      handleWorldRemoved\r\n    );\r\n\r\n    // update the mass for the p2 lander body when the model Property changes\r\n    scratchpad.massObserverId = phet.paperLand.addModelPropertyLink( 'landerMassProperty', mass => {\r\n      scratchpad.shipBody.mass = mass;\r\n    } );\r\n\r\n    // Apply thrust over time\r\n    scratchpad.timerListener = dt => {\r\n      if ( sharedData.model.has( 'landerThrustProperty' ) ) {\r\n        const thrust = sharedData.model.get( 'landerThrustProperty' ).value;\r\n        scratchpad.shipBody.applyForceLocal( [ thrust.x, thrust.y ], [ 0, 0 ] );\r\n      }\r\n    }\r\n    phet.axon.stepTimer.addListener( scratchpad.timerListener );\r\n  };\r\n\r\n  // Called when the paper positions change.\r\n  const onProgramChangedPosition = ( paperProgramNumber, positionPoints, scratchpad, sharedData ) => {\r\n\r\n    if ( sharedData.model.has( 'viewToModelPosition' ) ) {\r\n      \r\n      // whenever the program is moved, set that as the new lander position and reset all kinematic values\r\n      const paperCenterX = ( positionPoints[ 0 ].x + positionPoints[ 2 ].x ) / 2;\r\n      const paperCenterY = ( positionPoints[ 0 ].y + positionPoints[ 2 ].y ) / 2;\r\n\r\n      const centerX = paperCenterX * sharedData.displaySize.width;\r\n      const centerY = paperCenterY * sharedData.displaySize.height;\r\n      const viewCenter = new phet.dot.Vector2( centerX, centerY );\r\n\r\n      // The model has a utility function to convert from view to model coordinates (since papers\r\n      // are in view coordinates).\r\n      const modelPosition = sharedData.model.get( 'viewToModelPosition' )( viewCenter );\r\n\r\n      scratchpad.shipBody.position = [ modelPosition.x, modelPosition.y ];\r\n      scratchpad.shipBody.velocity = [ 0, 0 ];\r\n      scratchpad.shipBody.force = [ 0, 0 ]; \r\n    }\r\n  };\r\n\r\n  // Called when the program is changed or no longer detected.\r\n  const onProgramRemoved = ( paperProgramNumber, scratchpad, sharedData ) => {\r\n    phet.paperLand.removeModelObserver( 'world', scratchpad.observerId );\r\n    delete scratchpad.observerId;\r\n\r\n    phet.paperLand.removeModelPropertyLink( 'landerMassProperty', scratchpad.massObserverId );\r\n    delete scratchpad.massObserverId;\r\n\r\n    phet.paperLand.removeModelComponent( 'lander' );\r\n\r\n    phet.paperLand.removeModelComponent( 'landerPositionProperty' );\r\n    phet.paperLand.removeModelComponent( 'landerVelocityProperty' );\r\n    phet.paperLand.removeModelComponent( 'landerAccelerationProperty' );\r\n    phet.paperLand.removeModelComponent( 'landerForceProperty' );\r\n    phet.paperLand.removeModelComponent( 'landerThrustProperty' );\r\n    phet.paperLand.removeModelComponent( 'landerMassProperty' );\r\n\r\n    phet.axon.stepTimer.removeListener( scratchpad.timerListener );\r\n    delete scratchpad.timerListener;\r\n\r\n    sharedData.scene.removeChild( scratchpad.imageNode );\r\n    delete scratchpad.imageNode;\r\n\r\n    delete scratchpad.shipBody;\r\n  };\r\n\r\n  // Add the state change handler defined above as data for this paper.\r\n  await paper.set('data', {\r\n    paperPlaygroundData: {\r\n      updateTime: Date.now(),\r\n      eventHandlers: {\r\n        onProgramAdded: onProgramAdded.toString(),\r\n        onProgramChangedPosition: onProgramChangedPosition.toString(),\r\n        onProgramRemoved: onProgramRemoved.toString()\r\n      }\r\n    }\r\n  } );\r\n\r\n  //----------------------------------------------------------------------\r\n  // Projector code\r\n  //----------------------------------------------------------------------\r\n\r\n  // Get a canvas object for this paper.\r\n  const canvas = await paper.get('canvas');\r\n\r\n  // Draw the name of the program on the canvas\r\n  const ctx = canvas.getContext('2d');\r\n  ctx.font = '20px sans-serif';\r\n  ctx.textAlign = 'center';\r\n  ctx.fillStyle = 'rgb(255,0,0)';\r\n  ctx.fillText('Lander', canvas.width / 2, canvas.height / 2 - 10);\r\n  ctx.fillStyle = 'rgb(0,255,0)';\r\n  ctx.fillText('Model', canvas.width / 2, canvas.height / 2 + 20);\r\n})();\r\n",
  "printed": false,
  "editorInfo": {},
  "currentCodeUrl": "program.lunar-lander.1244.js",
  "currentCodeHash": "",
  "debugUrl": "/api/spaces/lunar-lander/programs/1244/debugInfo",
  "claimUrl": "/api/spaces/lunar-lander/programs/1244/claim",
  "codeHasChanged": false,
  "debugInfo": "{\"logs\":[]}"
}