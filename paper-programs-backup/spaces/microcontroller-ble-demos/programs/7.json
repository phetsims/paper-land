{
  "number": 7,
  "originalCode": "// UART to IO Pins (LEDs) with Markers\n// Keywords: \n// Description: This program sends a string over UART RX to set p0 to up (red marker) or p1 to up (green marker), which will light up an LED in circuit with those pins.\n\nimportScripts('paper.js');\n\n(async () => {\n\n  const onProgramAdded = ( paperNumber, scratchpad, sharedData ) => {\n    \n      const led1p0UpBoolean = new phet.axon.BooleanProperty(false);\n      phet.paperLand.addModelComponent( 'led1p0UpBoolean', led1p0UpBoolean );\n    \n\n      const led2p1UpBoolean = new phet.axon.BooleanProperty(false);\n      phet.paperLand.addModelComponent( 'led2p1UpBoolean', led2p1UpBoolean );\n    \n\n      const receivedUARTString = new phet.axon.StringProperty( '' );\n      phet.paperLand.addModelComponent( 'receivedUARTString', receivedUARTString );\n    \n\n      // Create the text and add it to the view - using RichText for nice markup support.\n      const receivedUARTTextText = new phet.scenery.RichText( '', { fill: 'white' } );\n      \n      sharedData.scene.addChild( receivedUARTTextText );\n      scratchpad.receivedUARTTextText = receivedUARTTextText;\n      \n      // Update the text when a dependency changes.\n      scratchpad.receivedUARTTextTextMultilinkId = phet.paperLand.addModelPropertyMultilink( [ 'receivedUARTString' ], ( receivedUARTString ) => {\n      \n        // the additional reference constants\n        \n      \n        // in a local scope, define the functions that the user can use to manipulate the text\n        \n      const unitBoundsToDisplayBounds = ( bounds ) => {\n        return phet.paperLand.utils.paperToBoardBounds( bounds, sharedData.displaySize.width, sharedData.displaySize.height );\n      };\n      \n      const unitPositionToDisplayPosition = ( position ) => {\n        return phet.paperLand.utils.paperToBoardCoordinates( position, sharedData.displaySize.width, sharedData.displaySize.height );\n      };\n    \n      const setCenterX = ( x ) => {\n        receivedUARTTextText.centerX = phet.paperLand.utils.paperToBoardX( x, sharedData.displaySize.width );\n      };\n      \n      const setCenterY = ( y ) => {\n        receivedUARTTextText.centerY = phet.paperLand.utils.paperToBoardY( y, sharedData.displaySize.height );\n      };\n      \n      const setLeft = ( left ) => {\n        receivedUARTTextText.left = phet.paperLand.utils.paperToBoardX( left, sharedData.displaySize.width );\n      };\n      \n      const setTop = ( top ) => {\n        receivedUARTTextText.top = phet.paperLand.utils.paperToBoardY( top, sharedData.displaySize.height );\n      };\n      \n      const setScale = ( scale ) => {\n        receivedUARTTextText.setScaleMagnitude( scale );\n      };\n      \n      const setOpacity = ( opacity ) => {\n        receivedUARTTextText.opacity = opacity;\n      };\n      \n      const setVisible = ( visible ) => {\n        receivedUARTTextText.visible = visible;\n      };\n      \n      const moveToFront = () => {\n        receivedUARTTextText.moveToFront();\n      };\n      \n      const moveToBack = () => {\n        receivedUARTTextText.moveToBack();\n      };\n      \n      const setRotation = ( rotation ) => {\n        receivedUARTTextText.rotation = rotation;\n      };\n\n      // Set the scale in X and Y and the       \n      const matchBounds = ( bounds, stretch ) => {\n      \n        // Find the scale to apply to the x and y dimensions so that the component bounds match the provided bounds\n        const receivedUARTTextTextViewBounds = phet.paperLand.utils.paperToBoardBounds(bounds, sharedData.displaySize.width, sharedData.displaySize.height);\n\n        // local bounds may be zero as things load\n        // const aspectRatio = ( receivedUARTTextText.localBounds.width || 1 ) / ( receivedUARTTextText.localBounds.height || 1 );\n\n        const scaleX = receivedUARTTextTextViewBounds.width / ( receivedUARTTextText.localBounds.width || 1 );\n        const scaleY = receivedUARTTextTextViewBounds.height / ( receivedUARTTextText.localBounds.height || 1 );\n\n        if ( stretch ) {\n          receivedUARTTextText.setScaleMagnitude(scaleX, scaleY);\n        }\n        else {\n        \n          // Scale by the minimum of the x and y scale factors, preserving the aspect ratio\n          receivedUARTTextText.setScaleMagnitude( Math.min( scaleX, scaleY ) );\n        }        \n\n        // Now put the component in the center of the bounds\n        receivedUARTTextText.center = receivedUARTTextTextViewBounds.center;\n      };\n      \n\n        const setString = ( string ) => {\n          receivedUARTTextText.string = string;\n        };\n        \n        const setFontSize = ( size ) => {\n        \n          // RichText has no setter for size, so we need to create a new font. Use\n          // state from the old font to maintain the family.\n          const currentFont = receivedUARTTextText.font;\n          const newFont = new phet.scenery.Font( { size: size, family: currentFont.family } );\n          receivedUARTTextText.font = newFont;\n        };\n\n        const setTextColor = ( color ) => {\n          receivedUARTTextText.fill = color;\n        };\n\n        const setFontFamily = ( family ) => {\n        \n          // RichText has no setter for fontFamily, so we need to create a new font. Use\n          // state from the old font to maintain the size.\n          const currentFont = receivedUARTTextText.font;\n          const newFont = new phet.scenery.Font( { size: currentFont.size, family: family } );\n          receivedUARTTextText.font = newFont;\n        };\n      \n\n        // the function that the user wrote to update the text      \n        setTop(0.5);\nsetLeft(0.5);\nsetFontSize(32);\nsetString( \"micro:bit confirms:\" + receivedUARTString );\n      }, {\n        otherProperties: [ phet.paperLand.displaySizeProperty ],\n        otherReferences: [  ]\n      } );\n    \n\n    \n      if ( true ) {\n        \n        // Writing to a characteristic, in this case we are controlling the device from the paper playground model.\n        // We can set up a mulilink that will write to the characteristic when the dependency properties change.\n        scratchpad.p0BLEWriterMultilinkId = phet.paperLand.addModelPropertyMultilink( [ 'led1p0UpBoolean' ], ( led1p0UpBoolean ) => {\n        \n          // references to each model components that will just be read from (not part of the multilink) - since\n          // they are not part of the multilink, they may not exist yet\n          if ( phet.paperLand.hasAllModelComponents( [  ] ) ) {\n            \n            \n            const writeToCharacteristic = _newCharacteristicValue => {\n              phet.paperLand.boardBluetoothServers.writeToCharacteristic( '6e400001-b5a3-f393-e0a9-e50e24dcca9e', '6e400003-b5a3-f393-e0a9-e50e24dcca9e', _newCharacteristicValue );\n            };\n            \n            const writeStringToCharacteristic = ( _newCharacteristicValueString, _startDelim = '$', _endDelim = '|' ) => {\n            \n              // wrap the string in delimiters for the device\n              const _wrappedString = _startDelim + _newCharacteristicValueString + _endDelim;\n              \n              // encode as UTF-8 Uint8Array\n              const _encodedValue = new TextEncoder().encode( _wrappedString );\n            \n              phet.paperLand.boardBluetoothServers.writeToCharacteristic( '6e400001-b5a3-f393-e0a9-e50e24dcca9e', '6e400003-b5a3-f393-e0a9-e50e24dcca9e', _encodedValue );\n            };\n            \n            // _matrix is a 5x5 2D array of 1s and 0s, corresponding to the LED matrix\n            const writeMatrixToCharacteristic = ( _matrix ) => {\n              const _ledMatrix = new Int8Array(5);\n              const _buffer = [\n                ['0', '0', '0', '0', '0', '0', '0', '0'],\n                ['0', '0', '0', '0', '0', '0', '0', '0'],\n                ['0', '0', '0', '0', '0', '0', '0', '0'],\n                ['0', '0', '0', '0', '0', '0', '0', '0'],\n                ['0', '0', '0', '0', '0', '0', '0', '0']\n              ]\n              for (var i = 0; i < 5; i++) {\n                for (var j = 0; j < 5; j++) {\n                  _buffer[i][7-j] = _matrix[i][4 - j]\n                }\n              }\n              for (var i = 0; i < 5; i++) {\n                const _string = _buffer[i].join(\"\");\n                _ledMatrix[i]=parseInt(_string,2)\n              }\n              phet.paperLand.boardBluetoothServers.writeToCharacteristic( '6e400001-b5a3-f393-e0a9-e50e24dcca9e', '6e400003-b5a3-f393-e0a9-e50e24dcca9e', _ledMatrix );\n            };\n            \n            // the code block that the user wrote to change controlled Properties\n            let str = \"\";\n\nif (led1p0UpBoolean) {\n    str = \"p0U\";\n} else {\n    str = \"p0D\";\n}\n\nwriteStringToCharacteristic(str);\n\nconsole.log(`pin 0 being set to ${str}`);\n\n          }\n        } );\n      }\n      else {\n      \n        // Reading from the characteristic, in this case we are controlling other model components\n        phet.paperLand.boardBluetoothServers.addCharacteristicListener(\n          '6e400001-b5a3-f393-e0a9-e50e24dcca9e',\n          '6e400003-b5a3-f393-e0a9-e50e24dcca9e',\n          deviceValue => {\n          \n            if ( phet.paperLand.hasAllModelComponents( [  ] ) ) {\n            \n              // Make available as a string for easy reading\n              const _textDecoder = new TextDecoder('utf-8'); // Default is utf-8, which is typical for UART text data\n              const deviceValueString = _textDecoder.decode(deviceValue);\n            \n              // references to each model component controlled by this listener\n              \n            \n              // the functions create in the local scope to manipulate the controlled components\n              \n              \n              // the function that that the user wrote\n              let str = \"\";\n\nif (led1p0UpBoolean) {\n    str = \"p0U\";\n} else {\n    str = \"p0D\";\n}\n\nwriteStringToCharacteristic(str);\n\nconsole.log(`pin 0 being set to ${str}`);\n \n            }\n         \n          }\n        )\n        .then( addedListener => {\n          scratchpad.characteristicListener = addedListener;\n        } )\n        .catch( error => {\n          phet.paperLand.console.error( error );\n        } );\n      }\n    \n\n    \n      if ( true ) {\n        \n        // Writing to a characteristic, in this case we are controlling the device from the paper playground model.\n        // We can set up a mulilink that will write to the characteristic when the dependency properties change.\n        scratchpad.p1BLEWriterMultilinkId = phet.paperLand.addModelPropertyMultilink( [ 'led2p1UpBoolean' ], ( led2p1UpBoolean ) => {\n        \n          // references to each model components that will just be read from (not part of the multilink) - since\n          // they are not part of the multilink, they may not exist yet\n          if ( phet.paperLand.hasAllModelComponents( [  ] ) ) {\n            \n            \n            const writeToCharacteristic = _newCharacteristicValue => {\n              phet.paperLand.boardBluetoothServers.writeToCharacteristic( '6e400001-b5a3-f393-e0a9-e50e24dcca9e', '6e400003-b5a3-f393-e0a9-e50e24dcca9e', _newCharacteristicValue );\n            };\n            \n            const writeStringToCharacteristic = ( _newCharacteristicValueString, _startDelim = '$', _endDelim = '|' ) => {\n            \n              // wrap the string in delimiters for the device\n              const _wrappedString = _startDelim + _newCharacteristicValueString + _endDelim;\n              \n              // encode as UTF-8 Uint8Array\n              const _encodedValue = new TextEncoder().encode( _wrappedString );\n            \n              phet.paperLand.boardBluetoothServers.writeToCharacteristic( '6e400001-b5a3-f393-e0a9-e50e24dcca9e', '6e400003-b5a3-f393-e0a9-e50e24dcca9e', _encodedValue );\n            };\n            \n            // _matrix is a 5x5 2D array of 1s and 0s, corresponding to the LED matrix\n            const writeMatrixToCharacteristic = ( _matrix ) => {\n              const _ledMatrix = new Int8Array(5);\n              const _buffer = [\n                ['0', '0', '0', '0', '0', '0', '0', '0'],\n                ['0', '0', '0', '0', '0', '0', '0', '0'],\n                ['0', '0', '0', '0', '0', '0', '0', '0'],\n                ['0', '0', '0', '0', '0', '0', '0', '0'],\n                ['0', '0', '0', '0', '0', '0', '0', '0']\n              ]\n              for (var i = 0; i < 5; i++) {\n                for (var j = 0; j < 5; j++) {\n                  _buffer[i][7-j] = _matrix[i][4 - j]\n                }\n              }\n              for (var i = 0; i < 5; i++) {\n                const _string = _buffer[i].join(\"\");\n                _ledMatrix[i]=parseInt(_string,2)\n              }\n              phet.paperLand.boardBluetoothServers.writeToCharacteristic( '6e400001-b5a3-f393-e0a9-e50e24dcca9e', '6e400003-b5a3-f393-e0a9-e50e24dcca9e', _ledMatrix );\n            };\n            \n            // the code block that the user wrote to change controlled Properties\n            let str = \"\";\n\nif (led2p1UpBoolean) {\n    str = \"p1U\";\n} else {\n    str = \"p1D\";\n}\n\nwriteStringToCharacteristic(str);\n\nconsole.log(`pin 1 being set to ${str}`);\n          }\n        } );\n      }\n      else {\n      \n        // Reading from the characteristic, in this case we are controlling other model components\n        phet.paperLand.boardBluetoothServers.addCharacteristicListener(\n          '6e400001-b5a3-f393-e0a9-e50e24dcca9e',\n          '6e400003-b5a3-f393-e0a9-e50e24dcca9e',\n          deviceValue => {\n          \n            if ( phet.paperLand.hasAllModelComponents( [  ] ) ) {\n            \n              // Make available as a string for easy reading\n              const _textDecoder = new TextDecoder('utf-8'); // Default is utf-8, which is typical for UART text data\n              const deviceValueString = _textDecoder.decode(deviceValue);\n            \n              // references to each model component controlled by this listener\n              \n            \n              // the functions create in the local scope to manipulate the controlled components\n              \n              \n              // the function that that the user wrote\n              let str = \"\";\n\nif (led2p1UpBoolean) {\n    str = \"p1U\";\n} else {\n    str = \"p1D\";\n}\n\nwriteStringToCharacteristic(str);\n\nconsole.log(`pin 1 being set to ${str}`); \n            }\n         \n          }\n        )\n        .then( addedListener => {\n          scratchpad.characteristicListener = addedListener;\n        } )\n        .catch( error => {\n          phet.paperLand.console.error( error );\n        } );\n      }\n    \n\n    \n      if ( false ) {\n        \n        // Writing to a characteristic, in this case we are controlling the device from the paper playground model.\n        // We can set up a mulilink that will write to the characteristic when the dependency properties change.\n        scratchpad.readMicrobitUARTStringsMultilinkId = phet.paperLand.addModelPropertyMultilink( [  ], (  ) => {\n        \n          // references to each model components that will just be read from (not part of the multilink) - since\n          // they are not part of the multilink, they may not exist yet\n          if ( phet.paperLand.hasAllModelComponents( [ 'receivedUARTString' ] ) ) {\n            const receivedUARTString = phet.paperLand.getModelComponent( 'receivedUARTString' ).value;\n            \n            const writeToCharacteristic = _newCharacteristicValue => {\n              phet.paperLand.boardBluetoothServers.writeToCharacteristic( '6e400001-b5a3-f393-e0a9-e50e24dcca9e', '6e400002-b5a3-f393-e0a9-e50e24dcca9e', _newCharacteristicValue );\n            };\n            \n            const writeStringToCharacteristic = ( _newCharacteristicValueString, _startDelim = '$', _endDelim = '|' ) => {\n            \n              // wrap the string in delimiters for the device\n              const _wrappedString = _startDelim + _newCharacteristicValueString + _endDelim;\n              \n              // encode as UTF-8 Uint8Array\n              const _encodedValue = new TextEncoder().encode( _wrappedString );\n            \n              phet.paperLand.boardBluetoothServers.writeToCharacteristic( '6e400001-b5a3-f393-e0a9-e50e24dcca9e', '6e400002-b5a3-f393-e0a9-e50e24dcca9e', _encodedValue );\n            };\n            \n            // _matrix is a 5x5 2D array of 1s and 0s, corresponding to the LED matrix\n            const writeMatrixToCharacteristic = ( _matrix ) => {\n              const _ledMatrix = new Int8Array(5);\n              const _buffer = [\n                ['0', '0', '0', '0', '0', '0', '0', '0'],\n                ['0', '0', '0', '0', '0', '0', '0', '0'],\n                ['0', '0', '0', '0', '0', '0', '0', '0'],\n                ['0', '0', '0', '0', '0', '0', '0', '0'],\n                ['0', '0', '0', '0', '0', '0', '0', '0']\n              ]\n              for (var i = 0; i < 5; i++) {\n                for (var j = 0; j < 5; j++) {\n                  _buffer[i][7-j] = _matrix[i][4 - j]\n                }\n              }\n              for (var i = 0; i < 5; i++) {\n                const _string = _buffer[i].join(\"\");\n                _ledMatrix[i]=parseInt(_string,2)\n              }\n              phet.paperLand.boardBluetoothServers.writeToCharacteristic( '6e400001-b5a3-f393-e0a9-e50e24dcca9e', '6e400002-b5a3-f393-e0a9-e50e24dcca9e', _ledMatrix );\n            };\n            \n            // the code block that the user wrote to change controlled Properties\n            setReceivedUARTString( deviceValueString );\n\nconsole.log( `received ${deviceValueString}` );\n          }\n        } );\n      }\n      else {\n      \n        // Reading from the characteristic, in this case we are controlling other model components\n        phet.paperLand.boardBluetoothServers.addCharacteristicListener(\n          '6e400001-b5a3-f393-e0a9-e50e24dcca9e',\n          '6e400002-b5a3-f393-e0a9-e50e24dcca9e',\n          deviceValue => {\n          \n            if ( phet.paperLand.hasAllModelComponents( [ 'receivedUARTString' ] ) ) {\n            \n              // Make available as a string for easy reading\n              const _textDecoder = new TextDecoder('utf-8'); // Default is utf-8, which is typical for UART text data\n              const deviceValueString = _textDecoder.decode(deviceValue);\n            \n              // references to each model component controlled by this listener\n              const receivedUARTString = phet.paperLand.getModelComponent( 'receivedUARTString' ).value;\n            \n              // the functions create in the local scope to manipulate the controlled components\n              const setReceivedUARTString = newValue => {\n        const modelComponent = phet.paperLand.getModelComponent( 'receivedUARTString' );\n        modelComponent.value = newValue;  \n      }\n      \n              \n              // the function that that the user wrote\n              setReceivedUARTString( deviceValueString );\n\nconsole.log( `received ${deviceValueString}` ); \n            }\n         \n          }\n        )\n        .then( addedListener => {\n          scratchpad.characteristicListener = addedListener;\n        } )\n        .catch( error => {\n          phet.paperLand.console.error( error );\n        } );\n      }\n    \n  };\n\n  const onProgramRemoved = ( paperNumber, scratchpad, sharedData ) => {\n    \n      // Remove the component from the model\n      phet.paperLand.removeModelComponent( 'led1p0UpBoolean' );\n    \n\n      // Remove the component from the model\n      phet.paperLand.removeModelComponent( 'led2p1UpBoolean' );\n    \n\n      // Remove the component from the model\n      phet.paperLand.removeModelComponent( 'receivedUARTString' );\n    \n\n      // Remove the text from the view.\n      sharedData.scene.removeChild( scratchpad.receivedUARTTextText );\n      delete scratchpad.receivedUARTTextText;\n      \n      // Remove the multilink\n      phet.paperLand.removeModelPropertyMultilink( [ 'receivedUARTString' ], scratchpad.receivedUARTTextTextMultilinkId, {\n        otherReferences: [  ]\n      });\n      delete scratchpad.receivedUARTTextTextMultilinkId;\n    \n\n     phet.paperLand.console.log( 'Removing a BLE component' );\n     phet.paperLand.boardBluetoothServers.removeCharacteristicListener(\n       '6e400001-b5a3-f393-e0a9-e50e24dcca9e',\n       '6e400003-b5a3-f393-e0a9-e50e24dcca9e',\n       scratchpad.characteristicListener\n     ).catch( error => {\n       phet.paperLand.console.error( error );\n     } );\n     \n     if ( scratchpad.p0BLEWriterMultilinkId ) {\n       phet.paperLand.removeModelPropertyMultilink( [ 'led1p0UpBoolean' ], scratchpad.p0BLEWriterMultilinkId );\n       delete scratchpad.p0BLEWriterMultilinkId;\n     }\n    \n\n     phet.paperLand.console.log( 'Removing a BLE component' );\n     phet.paperLand.boardBluetoothServers.removeCharacteristicListener(\n       '6e400001-b5a3-f393-e0a9-e50e24dcca9e',\n       '6e400003-b5a3-f393-e0a9-e50e24dcca9e',\n       scratchpad.characteristicListener\n     ).catch( error => {\n       phet.paperLand.console.error( error );\n     } );\n     \n     if ( scratchpad.p1BLEWriterMultilinkId ) {\n       phet.paperLand.removeModelPropertyMultilink( [ 'led2p1UpBoolean' ], scratchpad.p1BLEWriterMultilinkId );\n       delete scratchpad.p1BLEWriterMultilinkId;\n     }\n    \n\n     phet.paperLand.console.log( 'Removing a BLE component' );\n     phet.paperLand.boardBluetoothServers.removeCharacteristicListener(\n       '6e400001-b5a3-f393-e0a9-e50e24dcca9e',\n       '6e400002-b5a3-f393-e0a9-e50e24dcca9e',\n       scratchpad.characteristicListener\n     ).catch( error => {\n       phet.paperLand.console.error( error );\n     } );\n     \n     if ( scratchpad.readMicrobitUARTStringsMultilinkId ) {\n       phet.paperLand.removeModelPropertyMultilink( [  ], scratchpad.readMicrobitUARTStringsMultilinkId );\n       delete scratchpad.readMicrobitUARTStringsMultilinkId;\n     }\n    \n  };\n\n  const onProgramChangedPosition = ( paperNumber, points, scratchpad, sharedData ) => {\n    \n  };\n  \n  const onProgramMarkersAdded = ( paperNumber, points, scratchpad, sharedData, markers ) => {\n    \n    const modelProperty159 = phet.paperLand.getModelComponent( 'led1p0UpBoolean' );\n    if ( modelProperty159 ) {\n      modelProperty159.value = _.filter(markers, { colorName: 'red' }).length > 0;\n    }\n\n    const modelProperty161 = phet.paperLand.getModelComponent( 'led2p1UpBoolean' );\n    if ( modelProperty161 ) {\n      modelProperty161.value = _.filter(markers, { colorName: 'green' }).length > 0;\n    }\n  };\n  \n  const onProgramMarkersRemoved = ( paperNumber, points, scratchpad, sharedData, markers ) => {\n    \n    const modelProperty164 = phet.paperLand.getModelComponent( 'led1p0UpBoolean' );\n    if ( modelProperty164 ) {\n      modelProperty164.value = _.filter(markers, { colorName: 'red' }).length > 0;\n    }\n\n    const modelProperty166 = phet.paperLand.getModelComponent( 'led2p1UpBoolean' );\n    if ( modelProperty166 ) {\n      modelProperty166.value = _.filter(markers, { colorName: 'green' }).length > 0;\n    }\n  };\n  \n  const onProgramMarkersChangedPosition = ( paperNumber, points, scratchpad, sharedData, markers ) => {\n    \n  };\n  \n  const onProgramAdjacent = ( paperNumber, otherPaperNumber, direction, scratchpad, sharedData ) => {\n    \n  };\n  \n  const onProgramSeparated = ( paperNumber, otherPaperNumber, direction, scratchpad, sharedData ) => {\n    \n  };\n\n  await paper.set( 'data', {\n    paperPlaygroundData: {\n      updateTime: Date.now(),\n      eventHandlers: {\n        onProgramAdded: onProgramAdded.toString(),\n        onProgramRemoved: onProgramRemoved.toString(),\n        onProgramChangedPosition: onProgramChangedPosition.toString(),\n        onProgramMarkersAdded: onProgramMarkersAdded.toString(),\n        onProgramMarkersRemoved: onProgramMarkersRemoved.toString(),\n        onProgramMarkersChangedPosition: onProgramMarkersChangedPosition.toString(),\n        onProgramAdjacent: onProgramAdjacent.toString(),\n        onProgramSeparated: onProgramSeparated.toString(),\n      },\n      customWhiskerLengths: {\n        top: 0.2,\n        right: 0.2,\n        bottom: 0.2,\n        left: 0.2\n      }\n    }\n  } );\n  \n  // PROJECTOR CODE //\n  // Get a canvas object for this paper to draw something to the Projector.\n  const canvas = await paper.get('canvas');\n\n  // Draw the name of the program to the projector\n  const ctx = canvas.getContext('2d');\n  ctx.font = '20px sans-serif';\n  ctx.textAlign = 'center';\n  ctx.fillStyle = 'rgb(255,0,0)';\n  ctx.fillText('', canvas.width / 2, canvas.height / 2 - 10);\n  ctx.fillStyle = 'rgb(0,255,0)';\n  ctx.font = '10px sans-serif';\n  ctx.fillText('UART to IO Pins (LEDs) with Markers', canvas.width / 2, canvas.height / 2 + 20);\n})();\n",
  "currentCode": "// UART to IO Pins (LEDs) with Markers\n// Keywords: \n// Description: This program sends a string over UART RX to set p0 to up (red marker) or p1 to up (green marker), which will light up an LED in circuit with those pins.\n\nimportScripts('paper.js');\n\n(async () => {\n\n  const onProgramAdded = ( paperNumber, scratchpad, sharedData ) => {\n    \n      const led1p0UpBoolean = new phet.axon.BooleanProperty(false);\n      phet.paperLand.addModelComponent( 'led1p0UpBoolean', led1p0UpBoolean );\n    \n\n      const led2p1UpBoolean = new phet.axon.BooleanProperty(false);\n      phet.paperLand.addModelComponent( 'led2p1UpBoolean', led2p1UpBoolean );\n    \n\n      const receivedUARTString = new phet.axon.StringProperty( '' );\n      phet.paperLand.addModelComponent( 'receivedUARTString', receivedUARTString );\n    \n\n      // Create the text and add it to the view - using RichText for nice markup support.\n      const receivedUARTTextText = new phet.scenery.RichText( '', { fill: 'white' } );\n      \n      sharedData.scene.addChild( receivedUARTTextText );\n      scratchpad.receivedUARTTextText = receivedUARTTextText;\n      \n      // Update the text when a dependency changes.\n      scratchpad.receivedUARTTextTextMultilinkId = phet.paperLand.addModelPropertyMultilink( [ 'receivedUARTString' ], ( receivedUARTString ) => {\n      \n        // the additional reference constants\n        \n      \n        // in a local scope, define the functions that the user can use to manipulate the text\n        \n      const unitBoundsToDisplayBounds = ( bounds ) => {\n        return phet.paperLand.utils.paperToBoardBounds( bounds, sharedData.displaySize.width, sharedData.displaySize.height );\n      };\n      \n      const unitPositionToDisplayPosition = ( position ) => {\n        return phet.paperLand.utils.paperToBoardCoordinates( position, sharedData.displaySize.width, sharedData.displaySize.height );\n      };\n    \n      const setCenterX = ( x ) => {\n        receivedUARTTextText.centerX = phet.paperLand.utils.paperToBoardX( x, sharedData.displaySize.width );\n      };\n      \n      const setCenterY = ( y ) => {\n        receivedUARTTextText.centerY = phet.paperLand.utils.paperToBoardY( y, sharedData.displaySize.height );\n      };\n      \n      const setLeft = ( left ) => {\n        receivedUARTTextText.left = phet.paperLand.utils.paperToBoardX( left, sharedData.displaySize.width );\n      };\n      \n      const setTop = ( top ) => {\n        receivedUARTTextText.top = phet.paperLand.utils.paperToBoardY( top, sharedData.displaySize.height );\n      };\n      \n      const setScale = ( scale ) => {\n        receivedUARTTextText.setScaleMagnitude( scale );\n      };\n      \n      const setOpacity = ( opacity ) => {\n        receivedUARTTextText.opacity = opacity;\n      };\n      \n      const setVisible = ( visible ) => {\n        receivedUARTTextText.visible = visible;\n      };\n      \n      const moveToFront = () => {\n        receivedUARTTextText.moveToFront();\n      };\n      \n      const moveToBack = () => {\n        receivedUARTTextText.moveToBack();\n      };\n      \n      const setRotation = ( rotation ) => {\n        receivedUARTTextText.rotation = rotation;\n      };\n\n      // Set the scale in X and Y and the       \n      const matchBounds = ( bounds, stretch ) => {\n      \n        // Find the scale to apply to the x and y dimensions so that the component bounds match the provided bounds\n        const receivedUARTTextTextViewBounds = phet.paperLand.utils.paperToBoardBounds(bounds, sharedData.displaySize.width, sharedData.displaySize.height);\n\n        // local bounds may be zero as things load\n        // const aspectRatio = ( receivedUARTTextText.localBounds.width || 1 ) / ( receivedUARTTextText.localBounds.height || 1 );\n\n        const scaleX = receivedUARTTextTextViewBounds.width / ( receivedUARTTextText.localBounds.width || 1 );\n        const scaleY = receivedUARTTextTextViewBounds.height / ( receivedUARTTextText.localBounds.height || 1 );\n\n        if ( stretch ) {\n          receivedUARTTextText.setScaleMagnitude(scaleX, scaleY);\n        }\n        else {\n        \n          // Scale by the minimum of the x and y scale factors, preserving the aspect ratio\n          receivedUARTTextText.setScaleMagnitude( Math.min( scaleX, scaleY ) );\n        }        \n\n        // Now put the component in the center of the bounds\n        receivedUARTTextText.center = receivedUARTTextTextViewBounds.center;\n      };\n      \n\n        const setString = ( string ) => {\n          receivedUARTTextText.string = string;\n        };\n        \n        const setFontSize = ( size ) => {\n        \n          // RichText has no setter for size, so we need to create a new font. Use\n          // state from the old font to maintain the family.\n          const currentFont = receivedUARTTextText.font;\n          const newFont = new phet.scenery.Font( { size: size, family: currentFont.family } );\n          receivedUARTTextText.font = newFont;\n        };\n\n        const setTextColor = ( color ) => {\n          receivedUARTTextText.fill = color;\n        };\n\n        const setFontFamily = ( family ) => {\n        \n          // RichText has no setter for fontFamily, so we need to create a new font. Use\n          // state from the old font to maintain the size.\n          const currentFont = receivedUARTTextText.font;\n          const newFont = new phet.scenery.Font( { size: currentFont.size, family: family } );\n          receivedUARTTextText.font = newFont;\n        };\n      \n\n        // the function that the user wrote to update the text      \n        setTop(0.5);\nsetLeft(0.5);\nsetFontSize(32);\nsetString( \"micro:bit confirms:\" + receivedUARTString );\n      }, {\n        otherProperties: [ phet.paperLand.displaySizeProperty ],\n        otherReferences: [  ]\n      } );\n    \n\n    \n      if ( true ) {\n        \n        // Writing to a characteristic, in this case we are controlling the device from the paper playground model.\n        // We can set up a mulilink that will write to the characteristic when the dependency properties change.\n        scratchpad.p0BLEWriterMultilinkId = phet.paperLand.addModelPropertyMultilink( [ 'led1p0UpBoolean' ], ( led1p0UpBoolean ) => {\n        \n          // references to each model components that will just be read from (not part of the multilink) - since\n          // they are not part of the multilink, they may not exist yet\n          if ( phet.paperLand.hasAllModelComponents( [  ] ) ) {\n            \n            \n            const writeToCharacteristic = _newCharacteristicValue => {\n              phet.paperLand.boardBluetoothServers.writeToCharacteristic( '6e400001-b5a3-f393-e0a9-e50e24dcca9e', '6e400003-b5a3-f393-e0a9-e50e24dcca9e', _newCharacteristicValue );\n            };\n            \n            const writeStringToCharacteristic = ( _newCharacteristicValueString, _startDelim = '$', _endDelim = '|' ) => {\n            \n              // wrap the string in delimiters for the device\n              const _wrappedString = _startDelim + _newCharacteristicValueString + _endDelim;\n              \n              // encode as UTF-8 Uint8Array\n              const _encodedValue = new TextEncoder().encode( _wrappedString );\n            \n              phet.paperLand.boardBluetoothServers.writeToCharacteristic( '6e400001-b5a3-f393-e0a9-e50e24dcca9e', '6e400003-b5a3-f393-e0a9-e50e24dcca9e', _encodedValue );\n            };\n            \n            // _matrix is a 5x5 2D array of 1s and 0s, corresponding to the LED matrix\n            const writeMatrixToCharacteristic = ( _matrix ) => {\n              const _ledMatrix = new Int8Array(5);\n              const _buffer = [\n                ['0', '0', '0', '0', '0', '0', '0', '0'],\n                ['0', '0', '0', '0', '0', '0', '0', '0'],\n                ['0', '0', '0', '0', '0', '0', '0', '0'],\n                ['0', '0', '0', '0', '0', '0', '0', '0'],\n                ['0', '0', '0', '0', '0', '0', '0', '0']\n              ]\n              for (var i = 0; i < 5; i++) {\n                for (var j = 0; j < 5; j++) {\n                  _buffer[i][7-j] = _matrix[i][4 - j]\n                }\n              }\n              for (var i = 0; i < 5; i++) {\n                const _string = _buffer[i].join(\"\");\n                _ledMatrix[i]=parseInt(_string,2)\n              }\n              phet.paperLand.boardBluetoothServers.writeToCharacteristic( '6e400001-b5a3-f393-e0a9-e50e24dcca9e', '6e400003-b5a3-f393-e0a9-e50e24dcca9e', _ledMatrix );\n            };\n            \n            // the code block that the user wrote to change controlled Properties\n            let str = \"\";\n\nif (led1p0UpBoolean) {\n    str = \"p0U\";\n} else {\n    str = \"p0D\";\n}\n\nwriteStringToCharacteristic(str);\n\nconsole.log(`pin 0 being set to ${str}`);\n\n          }\n        } );\n      }\n      else {\n      \n        // Reading from the characteristic, in this case we are controlling other model components\n        phet.paperLand.boardBluetoothServers.addCharacteristicListener(\n          '6e400001-b5a3-f393-e0a9-e50e24dcca9e',\n          '6e400003-b5a3-f393-e0a9-e50e24dcca9e',\n          deviceValue => {\n          \n            if ( phet.paperLand.hasAllModelComponents( [  ] ) ) {\n            \n              // Make available as a string for easy reading\n              const _textDecoder = new TextDecoder('utf-8'); // Default is utf-8, which is typical for UART text data\n              const deviceValueString = _textDecoder.decode(deviceValue);\n            \n              // references to each model component controlled by this listener\n              \n            \n              // the functions create in the local scope to manipulate the controlled components\n              \n              \n              // the function that that the user wrote\n              let str = \"\";\n\nif (led1p0UpBoolean) {\n    str = \"p0U\";\n} else {\n    str = \"p0D\";\n}\n\nwriteStringToCharacteristic(str);\n\nconsole.log(`pin 0 being set to ${str}`);\n \n            }\n         \n          }\n        )\n        .then( addedListener => {\n          scratchpad.characteristicListener = addedListener;\n        } )\n        .catch( error => {\n          phet.paperLand.console.error( error );\n        } );\n      }\n    \n\n    \n      if ( true ) {\n        \n        // Writing to a characteristic, in this case we are controlling the device from the paper playground model.\n        // We can set up a mulilink that will write to the characteristic when the dependency properties change.\n        scratchpad.p1BLEWriterMultilinkId = phet.paperLand.addModelPropertyMultilink( [ 'led2p1UpBoolean' ], ( led2p1UpBoolean ) => {\n        \n          // references to each model components that will just be read from (not part of the multilink) - since\n          // they are not part of the multilink, they may not exist yet\n          if ( phet.paperLand.hasAllModelComponents( [  ] ) ) {\n            \n            \n            const writeToCharacteristic = _newCharacteristicValue => {\n              phet.paperLand.boardBluetoothServers.writeToCharacteristic( '6e400001-b5a3-f393-e0a9-e50e24dcca9e', '6e400003-b5a3-f393-e0a9-e50e24dcca9e', _newCharacteristicValue );\n            };\n            \n            const writeStringToCharacteristic = ( _newCharacteristicValueString, _startDelim = '$', _endDelim = '|' ) => {\n            \n              // wrap the string in delimiters for the device\n              const _wrappedString = _startDelim + _newCharacteristicValueString + _endDelim;\n              \n              // encode as UTF-8 Uint8Array\n              const _encodedValue = new TextEncoder().encode( _wrappedString );\n            \n              phet.paperLand.boardBluetoothServers.writeToCharacteristic( '6e400001-b5a3-f393-e0a9-e50e24dcca9e', '6e400003-b5a3-f393-e0a9-e50e24dcca9e', _encodedValue );\n            };\n            \n            // _matrix is a 5x5 2D array of 1s and 0s, corresponding to the LED matrix\n            const writeMatrixToCharacteristic = ( _matrix ) => {\n              const _ledMatrix = new Int8Array(5);\n              const _buffer = [\n                ['0', '0', '0', '0', '0', '0', '0', '0'],\n                ['0', '0', '0', '0', '0', '0', '0', '0'],\n                ['0', '0', '0', '0', '0', '0', '0', '0'],\n                ['0', '0', '0', '0', '0', '0', '0', '0'],\n                ['0', '0', '0', '0', '0', '0', '0', '0']\n              ]\n              for (var i = 0; i < 5; i++) {\n                for (var j = 0; j < 5; j++) {\n                  _buffer[i][7-j] = _matrix[i][4 - j]\n                }\n              }\n              for (var i = 0; i < 5; i++) {\n                const _string = _buffer[i].join(\"\");\n                _ledMatrix[i]=parseInt(_string,2)\n              }\n              phet.paperLand.boardBluetoothServers.writeToCharacteristic( '6e400001-b5a3-f393-e0a9-e50e24dcca9e', '6e400003-b5a3-f393-e0a9-e50e24dcca9e', _ledMatrix );\n            };\n            \n            // the code block that the user wrote to change controlled Properties\n            let str = \"\";\n\nif (led2p1UpBoolean) {\n    str = \"p1U\";\n} else {\n    str = \"p1D\";\n}\n\nwriteStringToCharacteristic(str);\n\nconsole.log(`pin 1 being set to ${str}`);\n          }\n        } );\n      }\n      else {\n      \n        // Reading from the characteristic, in this case we are controlling other model components\n        phet.paperLand.boardBluetoothServers.addCharacteristicListener(\n          '6e400001-b5a3-f393-e0a9-e50e24dcca9e',\n          '6e400003-b5a3-f393-e0a9-e50e24dcca9e',\n          deviceValue => {\n          \n            if ( phet.paperLand.hasAllModelComponents( [  ] ) ) {\n            \n              // Make available as a string for easy reading\n              const _textDecoder = new TextDecoder('utf-8'); // Default is utf-8, which is typical for UART text data\n              const deviceValueString = _textDecoder.decode(deviceValue);\n            \n              // references to each model component controlled by this listener\n              \n            \n              // the functions create in the local scope to manipulate the controlled components\n              \n              \n              // the function that that the user wrote\n              let str = \"\";\n\nif (led2p1UpBoolean) {\n    str = \"p1U\";\n} else {\n    str = \"p1D\";\n}\n\nwriteStringToCharacteristic(str);\n\nconsole.log(`pin 1 being set to ${str}`); \n            }\n         \n          }\n        )\n        .then( addedListener => {\n          scratchpad.characteristicListener = addedListener;\n        } )\n        .catch( error => {\n          phet.paperLand.console.error( error );\n        } );\n      }\n    \n\n    \n      if ( false ) {\n        \n        // Writing to a characteristic, in this case we are controlling the device from the paper playground model.\n        // We can set up a mulilink that will write to the characteristic when the dependency properties change.\n        scratchpad.readMicrobitUARTStringsMultilinkId = phet.paperLand.addModelPropertyMultilink( [  ], (  ) => {\n        \n          // references to each model components that will just be read from (not part of the multilink) - since\n          // they are not part of the multilink, they may not exist yet\n          if ( phet.paperLand.hasAllModelComponents( [ 'receivedUARTString' ] ) ) {\n            const receivedUARTString = phet.paperLand.getModelComponent( 'receivedUARTString' ).value;\n            \n            const writeToCharacteristic = _newCharacteristicValue => {\n              phet.paperLand.boardBluetoothServers.writeToCharacteristic( '6e400001-b5a3-f393-e0a9-e50e24dcca9e', '6e400002-b5a3-f393-e0a9-e50e24dcca9e', _newCharacteristicValue );\n            };\n            \n            const writeStringToCharacteristic = ( _newCharacteristicValueString, _startDelim = '$', _endDelim = '|' ) => {\n            \n              // wrap the string in delimiters for the device\n              const _wrappedString = _startDelim + _newCharacteristicValueString + _endDelim;\n              \n              // encode as UTF-8 Uint8Array\n              const _encodedValue = new TextEncoder().encode( _wrappedString );\n            \n              phet.paperLand.boardBluetoothServers.writeToCharacteristic( '6e400001-b5a3-f393-e0a9-e50e24dcca9e', '6e400002-b5a3-f393-e0a9-e50e24dcca9e', _encodedValue );\n            };\n            \n            // _matrix is a 5x5 2D array of 1s and 0s, corresponding to the LED matrix\n            const writeMatrixToCharacteristic = ( _matrix ) => {\n              const _ledMatrix = new Int8Array(5);\n              const _buffer = [\n                ['0', '0', '0', '0', '0', '0', '0', '0'],\n                ['0', '0', '0', '0', '0', '0', '0', '0'],\n                ['0', '0', '0', '0', '0', '0', '0', '0'],\n                ['0', '0', '0', '0', '0', '0', '0', '0'],\n                ['0', '0', '0', '0', '0', '0', '0', '0']\n              ]\n              for (var i = 0; i < 5; i++) {\n                for (var j = 0; j < 5; j++) {\n                  _buffer[i][7-j] = _matrix[i][4 - j]\n                }\n              }\n              for (var i = 0; i < 5; i++) {\n                const _string = _buffer[i].join(\"\");\n                _ledMatrix[i]=parseInt(_string,2)\n              }\n              phet.paperLand.boardBluetoothServers.writeToCharacteristic( '6e400001-b5a3-f393-e0a9-e50e24dcca9e', '6e400002-b5a3-f393-e0a9-e50e24dcca9e', _ledMatrix );\n            };\n            \n            // the code block that the user wrote to change controlled Properties\n            setReceivedUARTString( deviceValueString );\n\nconsole.log( `received ${deviceValueString}` );\n          }\n        } );\n      }\n      else {\n      \n        // Reading from the characteristic, in this case we are controlling other model components\n        phet.paperLand.boardBluetoothServers.addCharacteristicListener(\n          '6e400001-b5a3-f393-e0a9-e50e24dcca9e',\n          '6e400002-b5a3-f393-e0a9-e50e24dcca9e',\n          deviceValue => {\n          \n            if ( phet.paperLand.hasAllModelComponents( [ 'receivedUARTString' ] ) ) {\n            \n              // Make available as a string for easy reading\n              const _textDecoder = new TextDecoder('utf-8'); // Default is utf-8, which is typical for UART text data\n              const deviceValueString = _textDecoder.decode(deviceValue);\n            \n              // references to each model component controlled by this listener\n              const receivedUARTString = phet.paperLand.getModelComponent( 'receivedUARTString' ).value;\n            \n              // the functions create in the local scope to manipulate the controlled components\n              const setReceivedUARTString = newValue => {\n        const modelComponent = phet.paperLand.getModelComponent( 'receivedUARTString' );\n        modelComponent.value = newValue;  \n      }\n      \n              \n              // the function that that the user wrote\n              setReceivedUARTString( deviceValueString );\n\nconsole.log( `received ${deviceValueString}` ); \n            }\n         \n          }\n        )\n        .then( addedListener => {\n          scratchpad.characteristicListener = addedListener;\n        } )\n        .catch( error => {\n          phet.paperLand.console.error( error );\n        } );\n      }\n    \n  };\n\n  const onProgramRemoved = ( paperNumber, scratchpad, sharedData ) => {\n    \n      // Remove the component from the model\n      phet.paperLand.removeModelComponent( 'led1p0UpBoolean' );\n    \n\n      // Remove the component from the model\n      phet.paperLand.removeModelComponent( 'led2p1UpBoolean' );\n    \n\n      // Remove the component from the model\n      phet.paperLand.removeModelComponent( 'receivedUARTString' );\n    \n\n      // Remove the text from the view.\n      sharedData.scene.removeChild( scratchpad.receivedUARTTextText );\n      delete scratchpad.receivedUARTTextText;\n      \n      // Remove the multilink\n      phet.paperLand.removeModelPropertyMultilink( [ 'receivedUARTString' ], scratchpad.receivedUARTTextTextMultilinkId, {\n        otherReferences: [  ]\n      });\n      delete scratchpad.receivedUARTTextTextMultilinkId;\n    \n\n     phet.paperLand.console.log( 'Removing a BLE component' );\n     phet.paperLand.boardBluetoothServers.removeCharacteristicListener(\n       '6e400001-b5a3-f393-e0a9-e50e24dcca9e',\n       '6e400003-b5a3-f393-e0a9-e50e24dcca9e',\n       scratchpad.characteristicListener\n     ).catch( error => {\n       phet.paperLand.console.error( error );\n     } );\n     \n     if ( scratchpad.p0BLEWriterMultilinkId ) {\n       phet.paperLand.removeModelPropertyMultilink( [ 'led1p0UpBoolean' ], scratchpad.p0BLEWriterMultilinkId );\n       delete scratchpad.p0BLEWriterMultilinkId;\n     }\n    \n\n     phet.paperLand.console.log( 'Removing a BLE component' );\n     phet.paperLand.boardBluetoothServers.removeCharacteristicListener(\n       '6e400001-b5a3-f393-e0a9-e50e24dcca9e',\n       '6e400003-b5a3-f393-e0a9-e50e24dcca9e',\n       scratchpad.characteristicListener\n     ).catch( error => {\n       phet.paperLand.console.error( error );\n     } );\n     \n     if ( scratchpad.p1BLEWriterMultilinkId ) {\n       phet.paperLand.removeModelPropertyMultilink( [ 'led2p1UpBoolean' ], scratchpad.p1BLEWriterMultilinkId );\n       delete scratchpad.p1BLEWriterMultilinkId;\n     }\n    \n\n     phet.paperLand.console.log( 'Removing a BLE component' );\n     phet.paperLand.boardBluetoothServers.removeCharacteristicListener(\n       '6e400001-b5a3-f393-e0a9-e50e24dcca9e',\n       '6e400002-b5a3-f393-e0a9-e50e24dcca9e',\n       scratchpad.characteristicListener\n     ).catch( error => {\n       phet.paperLand.console.error( error );\n     } );\n     \n     if ( scratchpad.readMicrobitUARTStringsMultilinkId ) {\n       phet.paperLand.removeModelPropertyMultilink( [  ], scratchpad.readMicrobitUARTStringsMultilinkId );\n       delete scratchpad.readMicrobitUARTStringsMultilinkId;\n     }\n    \n  };\n\n  const onProgramChangedPosition = ( paperNumber, points, scratchpad, sharedData ) => {\n    \n  };\n  \n  const onProgramMarkersAdded = ( paperNumber, points, scratchpad, sharedData, markers ) => {\n    \n    const modelProperty159 = phet.paperLand.getModelComponent( 'led1p0UpBoolean' );\n    if ( modelProperty159 ) {\n      modelProperty159.value = _.filter(markers, { colorName: 'red' }).length > 0;\n    }\n\n    const modelProperty161 = phet.paperLand.getModelComponent( 'led2p1UpBoolean' );\n    if ( modelProperty161 ) {\n      modelProperty161.value = _.filter(markers, { colorName: 'green' }).length > 0;\n    }\n  };\n  \n  const onProgramMarkersRemoved = ( paperNumber, points, scratchpad, sharedData, markers ) => {\n    \n    const modelProperty164 = phet.paperLand.getModelComponent( 'led1p0UpBoolean' );\n    if ( modelProperty164 ) {\n      modelProperty164.value = _.filter(markers, { colorName: 'red' }).length > 0;\n    }\n\n    const modelProperty166 = phet.paperLand.getModelComponent( 'led2p1UpBoolean' );\n    if ( modelProperty166 ) {\n      modelProperty166.value = _.filter(markers, { colorName: 'green' }).length > 0;\n    }\n  };\n  \n  const onProgramMarkersChangedPosition = ( paperNumber, points, scratchpad, sharedData, markers ) => {\n    \n  };\n  \n  const onProgramAdjacent = ( paperNumber, otherPaperNumber, direction, scratchpad, sharedData ) => {\n    \n  };\n  \n  const onProgramSeparated = ( paperNumber, otherPaperNumber, direction, scratchpad, sharedData ) => {\n    \n  };\n\n  await paper.set( 'data', {\n    paperPlaygroundData: {\n      updateTime: Date.now(),\n      eventHandlers: {\n        onProgramAdded: onProgramAdded.toString(),\n        onProgramRemoved: onProgramRemoved.toString(),\n        onProgramChangedPosition: onProgramChangedPosition.toString(),\n        onProgramMarkersAdded: onProgramMarkersAdded.toString(),\n        onProgramMarkersRemoved: onProgramMarkersRemoved.toString(),\n        onProgramMarkersChangedPosition: onProgramMarkersChangedPosition.toString(),\n        onProgramAdjacent: onProgramAdjacent.toString(),\n        onProgramSeparated: onProgramSeparated.toString(),\n      },\n      customWhiskerLengths: {\n        top: 0.2,\n        right: 0.2,\n        bottom: 0.2,\n        left: 0.2\n      }\n    }\n  } );\n  \n  // PROJECTOR CODE //\n  // Get a canvas object for this paper to draw something to the Projector.\n  const canvas = await paper.get('canvas');\n\n  // Draw the name of the program to the projector\n  const ctx = canvas.getContext('2d');\n  ctx.font = '20px sans-serif';\n  ctx.textAlign = 'center';\n  ctx.fillStyle = 'rgb(255,0,0)';\n  ctx.fillText('', canvas.width / 2, canvas.height / 2 - 10);\n  ctx.fillStyle = 'rgb(0,255,0)';\n  ctx.font = '10px sans-serif';\n  ctx.fillText('UART to IO Pins (LEDs) with Markers', canvas.width / 2, canvas.height / 2 + 20);\n})();\n",
  "printed": false,
  "editorInfo": {},
  "currentCodeUrl": "program.microcontroller-ble-demos.7.js",
  "currentCodeHash": "",
  "debugUrl": "/api/spaces/microcontroller-ble-demos/programs/7/debugInfo",
  "claimUrl": "/api/spaces/microcontroller-ble-demos/programs/7/claim",
  "codeHasChanged": false,
  "debugInfo": "{\"logs\":[]}"
}