{
  "number": 1,
  "originalCode": "// Game Logic\n// Keywords: \n// Description: \n\nimportScripts('paper.js');\n\n(async () => {\n\n  const onProgramAdded = ( paperNumber, scratchpad, sharedData ) => {\n    \n      const gameWon = new phet.axon.BooleanProperty(false);\n      phet.paperLand.addModelComponent( 'gameWon', gameWon );\n    \n\n      const ballPosition = new phet.dot.Vector2Property(\n        new phet.dot.Vector2( 0.5, 0.5 )\n      );\n      phet.paperLand.addModelComponent( 'ballPosition', ballPosition );\n    \n\n      const ballVelocity = new phet.dot.Vector2Property(\n        new phet.dot.Vector2( 0.05, 0.1 )\n      );\n      phet.paperLand.addModelComponent( 'ballVelocity', ballVelocity );\n    \n\n      const ballRotation = new phet.axon.NumberProperty( 5, {\n        range: new phet.dot.Range( 0, 10 )\n      });\n      phet.paperLand.addModelComponent( 'ballRotation', ballRotation );\n    \n\n      const gameBeatWrappedAudioBuffer = createAndLoadWrappedAudioBuffer( 'media/sounds/musicalBeat.mp3' );\n      const gameBeatSoundClip = new phet.tambo.SoundClip( gameBeatWrappedAudioBuffer, {\n        loop: true,\n        initialOutputLevel: 0.5\n       } );\n      phet.tambo.soundManager.addSoundGenerator( gameBeatSoundClip );\n      scratchpad.gameBeatWrappedAudioBuffer = gameBeatWrappedAudioBuffer;\n      \n      let gameBeatStopSoundTimeout = null;\n      \n      // as a safety measure, sound can only be played every 0.25 seconds - initial value is very small\n      // so that it can be played immediately\n      let gameBeatLastPlayTime = 0;\n      \n      // The listener that will observe the model and play sounds is added as soon as the sounds are loaded, and\n      // added to the scratch pad so that it can be removed later.\n      scratchpad.gameBeatWrappedAudioBufferListener = _buffer => {\n        if ( _buffer ) {\n        \n          // Play the sound when any dependencies change value.\n          scratchpad.gameBeatSoundMultilinkId = phet.paperLand.addModelPropertyMultilink( [ 'gameWon' ], ( gameWon ) => {\n            \n            // in a local scope, define the functions that the user can use to manipulate the sound\n            const setOutputLevel = ( level ) => {\n            \n              // As a safety measure, don't let the user set a level below zero and above 2.\n              const outputLevel = Math.max( 0, Math.min( 2, level ) );\n              gameBeatSoundClip.outputLevel = outputLevel;\n            };\n            const setPlaybackRate = ( rate ) => {\n            \n              // As a safety measure, the playback rate cannot go below zero.\n              const playbackRate = Math.max( 0, rate );\n              gameBeatSoundClip.setPlaybackRate( playbackRate );\n            };\n            \n            // a function the user can call to play the sound\n            const play = () => {\n            \n              // Play the sound - if looping, we don't want to start playing again if already playing. The sound\n              // can only be played at a limited interval for safety.\n              if ( ( !gameBeatSoundClip.isPlaying || !true ) && phet.paperLand.elapsedTimeProperty.value - gameBeatLastPlayTime > 0.25 ) {\n      \n                // only start playing again if it has been stopped - but we still enter this block to update\n                // the last play time and timeouts        \n                if ( !gameBeatSoundClip.isPlaying ) {\n                  gameBeatSoundClip.play();\n                }\n                gameBeatLastPlayTime = phet.paperLand.elapsedTimeProperty.value;\n                \n                // Set a timer to turn off the sound when the value stops changing.\n                if ( gameBeatStopSoundTimeout ){\n                  window.clearTimeout( gameBeatStopSoundTimeout );\n                }\n                \n                // only stop if not looping\n                if ( !true ) {\n                  gameBeatStopSoundTimeout = window.setTimeout( () => {\n                    gameBeatSoundClip.stop();\n                  }, 5000 );\n                }  \n              }\n            };\n            \n            const stop = () => {\n              // Set a timer to turn off the sound when the value stops changing.\n              if ( gameBeatStopSoundTimeout ){\n                window.clearTimeout( gameBeatStopSoundTimeout );\n              }\n              gameBeatSoundClip.stop();\n            };\n            \n            if ( true ) {\n              play();\n            }\n            \n            // declare the references so that they can be used in the control function\n            \n          \n            \n          }, {\n            otherReferences: [  ],\n          } );  \n        }\n      };     \n      scratchpad.gameBeatWrappedAudioBuffer.audioBufferProperty.link( scratchpad.gameBeatWrappedAudioBufferListener );\n      \n      // Assign the sound to the scratchpad so that we can remove it later\n      scratchpad.gameBeatSoundClip = gameBeatSoundClip;\n    \n\n      const gameWonSoundWrappedAudioBuffer = createAndLoadWrappedAudioBuffer( 'media/sounds/short-success.mp3' );\n      const gameWonSoundSoundClip = new phet.tambo.SoundClip( gameWonSoundWrappedAudioBuffer, {\n        loop: false,\n        initialOutputLevel: 0.5\n       } );\n      phet.tambo.soundManager.addSoundGenerator( gameWonSoundSoundClip );\n      scratchpad.gameWonSoundWrappedAudioBuffer = gameWonSoundWrappedAudioBuffer;\n      \n      let gameWonSoundStopSoundTimeout = null;\n      \n      // as a safety measure, sound can only be played every 0.25 seconds - initial value is very small\n      // so that it can be played immediately\n      let gameWonSoundLastPlayTime = 0;\n      \n      // The listener that will observe the model and play sounds is added as soon as the sounds are loaded, and\n      // added to the scratch pad so that it can be removed later.\n      scratchpad.gameWonSoundWrappedAudioBufferListener = _buffer => {\n        if ( _buffer ) {\n        \n          // Play the sound when any dependencies change value.\n          scratchpad.gameWonSoundSoundMultilinkId = phet.paperLand.addModelPropertyMultilink( [ 'gameWon' ], ( gameWon ) => {\n            \n            // in a local scope, define the functions that the user can use to manipulate the sound\n            const setOutputLevel = ( level ) => {\n            \n              // As a safety measure, don't let the user set a level below zero and above 2.\n              const outputLevel = Math.max( 0, Math.min( 2, level ) );\n              gameWonSoundSoundClip.outputLevel = outputLevel;\n            };\n            const setPlaybackRate = ( rate ) => {\n            \n              // As a safety measure, the playback rate cannot go below zero.\n              const playbackRate = Math.max( 0, rate );\n              gameWonSoundSoundClip.setPlaybackRate( playbackRate );\n            };\n            \n            // a function the user can call to play the sound\n            const play = () => {\n            \n              // Play the sound - if looping, we don't want to start playing again if already playing. The sound\n              // can only be played at a limited interval for safety.\n              if ( ( !gameWonSoundSoundClip.isPlaying || !false ) && phet.paperLand.elapsedTimeProperty.value - gameWonSoundLastPlayTime > 0.25 ) {\n      \n                // only start playing again if it has been stopped - but we still enter this block to update\n                // the last play time and timeouts        \n                if ( !gameWonSoundSoundClip.isPlaying ) {\n                  gameWonSoundSoundClip.play();\n                }\n                gameWonSoundLastPlayTime = phet.paperLand.elapsedTimeProperty.value;\n                \n                // Set a timer to turn off the sound when the value stops changing.\n                if ( gameWonSoundStopSoundTimeout ){\n                  window.clearTimeout( gameWonSoundStopSoundTimeout );\n                }\n                \n                // only stop if not looping\n                if ( !false ) {\n                  gameWonSoundStopSoundTimeout = window.setTimeout( () => {\n                    gameWonSoundSoundClip.stop();\n                  }, 5000 );\n                }  \n              }\n            };\n            \n            const stop = () => {\n              // Set a timer to turn off the sound when the value stops changing.\n              if ( gameWonSoundStopSoundTimeout ){\n                window.clearTimeout( gameWonSoundStopSoundTimeout );\n              }\n              gameWonSoundSoundClip.stop();\n            };\n            \n            if ( false ) {\n              play();\n            }\n            \n            // declare the references so that they can be used in the control function\n            \n          \n            if ( gameWon ) {\n    play();\n}\n          }, {\n            otherReferences: [  ],\n          } );  \n        }\n      };     \n      scratchpad.gameWonSoundWrappedAudioBuffer.audioBufferProperty.link( scratchpad.gameWonSoundWrappedAudioBufferListener );\n      \n      // Assign the sound to the scratchpad so that we can remove it later\n      scratchpad.gameWonSoundSoundClip = gameWonSoundSoundClip;\n    \n\n      // Create the text and add it to the view - using RichText for nice markup support.\n      const gameWonTextText = new phet.scenery.RichText( '', { fill: 'white' } );\n      \n      sharedData.scene.addChild( gameWonTextText );\n      scratchpad.gameWonTextText = gameWonTextText;\n      \n      // Update the text when a dependency changes.\n      scratchpad.gameWonTextTextMultilinkId = phet.paperLand.addModelPropertyMultilink( [ 'gameWon' ], ( gameWon ) => {\n      \n        // the additional reference constants\n        \n      \n        // in a local scope, define the functions that the user can use to manipulate the text\n        \n      const unitBoundsToDisplayBounds = ( bounds ) => {\n        return phet.paperLand.utils.paperToBoardBounds( bounds, sharedData.displaySize.width, sharedData.displaySize.height );\n      };\n      \n      const unitPositionToDisplayPosition = ( position ) => {\n        return phet.paperLand.utils.paperToBoardCoordinates( position, sharedData.displaySize.width, sharedData.displaySize.height );\n      };\n    \n      const setCenterX = ( x ) => {\n        gameWonTextText.centerX = phet.paperLand.utils.paperToBoardX( x, sharedData.displaySize.width );\n      };\n      \n      const setCenterY = ( y ) => {\n        gameWonTextText.centerY = phet.paperLand.utils.paperToBoardY( y, sharedData.displaySize.height );\n      };\n      \n      const setLeft = ( left ) => {\n        gameWonTextText.left = phet.paperLand.utils.paperToBoardX( left, sharedData.displaySize.width );\n      };\n      \n      const setTop = ( top ) => {\n        gameWonTextText.top = phet.paperLand.utils.paperToBoardY( top, sharedData.displaySize.height );\n      };\n      \n      const setScale = ( scale ) => {\n        gameWonTextText.setScaleMagnitude( scale );\n      };\n      \n      const setOpacity = ( opacity ) => {\n        gameWonTextText.opacity = opacity;\n      };\n      \n      const setVisible = ( visible ) => {\n        gameWonTextText.visible = visible;\n      };\n      \n      const moveToFront = () => {\n        gameWonTextText.moveToFront();\n      };\n      \n      const moveToBack = () => {\n        gameWonTextText.moveToBack();\n      };\n      \n      const setRotation = ( rotation ) => {\n        gameWonTextText.rotation = rotation;\n      };\n\n      // Set the scale in X and Y and the       \n      const matchBounds = ( bounds, stretch ) => {\n      \n        // Find the scale to apply to the x and y dimensions so that the component bounds match the provided bounds\n        const gameWonTextTextViewBounds = phet.paperLand.utils.paperToBoardBounds(bounds, sharedData.displaySize.width, sharedData.displaySize.height);\n\n        // local bounds may be zero as things load\n        // const aspectRatio = ( gameWonTextText.localBounds.width || 1 ) / ( gameWonTextText.localBounds.height || 1 );\n\n        const scaleX = gameWonTextTextViewBounds.width / ( gameWonTextText.localBounds.width || 1 );\n        const scaleY = gameWonTextTextViewBounds.height / ( gameWonTextText.localBounds.height || 1 );\n\n        if ( stretch ) {\n          gameWonTextText.setScaleMagnitude(scaleX, scaleY);\n        }\n        else {\n        \n          // Scale by the minimum of the x and y scale factors, preserving the aspect ratio\n          gameWonTextText.setScaleMagnitude( Math.min( scaleX, scaleY ) );\n        }        \n\n        // Now put the component in the center of the bounds\n        gameWonTextText.center = gameWonTextTextViewBounds.center;\n      };\n      \n\n        const setString = ( string ) => {\n          gameWonTextText.string = string;\n        };\n        \n        const setFontSize = ( size ) => {\n        \n          // RichText has no setter for size, so we need to create a new font. Use\n          // state from the old font to maintain the family.\n          const currentFont = gameWonTextText.font;\n          const newFont = new phet.scenery.Font( { size: size, family: currentFont.family } );\n          gameWonTextText.font = newFont;\n        };\n\n        const setTextColor = ( color ) => {\n          gameWonTextText.fill = color;\n        };\n\n        const setFontFamily = ( family ) => {\n        \n          // RichText has no setter for fontFamily, so we need to create a new font. Use\n          // state from the old font to maintain the size.\n          const currentFont = gameWonTextText.font;\n          const newFont = new phet.scenery.Font( { size: currentFont.size, family: family } );\n          gameWonTextText.font = newFont;\n        };\n      \n\n        // the function that the user wrote to update the text      \n        setVisible( gameWon );\nsetString( 'You Won!!' );\nsetFontSize( 48 );\n\nsetCenterX( 0.5 )\nsetCenterY( 0.5 );\n      }, {\n        otherProperties: [ phet.paperLand.displaySizeProperty ],\n        otherReferences: [  ]\n      } );\n    \n\n\n      // Create a shape with kite.\n      const ballViewShape = phet.kite.Shape.ellipse( phet.paperLand.utils.paperToBoardX( 0.03, sharedData.displaySize.width ), phet.paperLand.utils.paperToBoardY( 0.03, sharedData.displaySize.height ) )\n      \n      // create a path for the shape\n      const ballViewPath = new phet.scenery.Path( ballViewShape, {\n        fill: 'red',\n        stroke: 'blue',\n        lineWidth: 1,\n        \n        // if initial position is zero, do not set that explicitly because it will break shape points \n        centerX: ('model' === 'model' && 0.5) ? phet.paperLand.utils.paperToBoardX( 0.5, sharedData.displaySize.width ) : 0.5,\n        centerY: ('model' === 'model' && 0.5) ? phet.paperLand.utils.paperToBoardY( 0.5, sharedData.displaySize.height) : 0.5,\n        scale: 1,\n        rotation: 0,\n        opacity: 1\n      } );\n      \n      // assign to scratchpad so that we can remove it later\n      sharedData.scene.addChild( ballViewPath );\n      scratchpad.ballViewPath = ballViewPath;\n      \n      // Update the shape when a dependency changes.\n      scratchpad.ballViewPathMultilinkId = phet.paperLand.addModelPropertyMultilink( [ 'ballPosition', 'ballRotation' ], ( ballPosition, ballRotation ) => {\n      \n        // We have to recreate the shape every change (especially important for a resize) - this is done first though\n        // because the user control functions might change the shape further.\n        const ballViewShape = phet.kite.Shape.ellipse( phet.paperLand.utils.paperToBoardX( 0.03, sharedData.displaySize.width ), phet.paperLand.utils.paperToBoardY( 0.03, sharedData.displaySize.height ) )\n        scratchpad.ballViewPath.setShape( ballViewShape );\n        \n        // now mutate with options that might depend on the shape or layout changes (again, user might override this \n        // so do before the control function)\n        scratchpad.ballViewPath.mutate( {\n          // if initial position is zero, do not set that explicitly because it will break shape points \n          centerX: ('model' === 'model' && 0.5) ? phet.paperLand.utils.paperToBoardX( 0.5, sharedData.displaySize.width ) : 0.5,\n          centerY: ('model' === 'model' && 0.5) ? phet.paperLand.utils.paperToBoardY( 0.5, sharedData.displaySize.height) : 0.5,\n          scale: 1,\n          rotation: 0\n        } );\n      \n        // the functions that are available for this view type\n        \n      const unitBoundsToDisplayBounds = ( bounds ) => {\n        return phet.paperLand.utils.paperToBoardBounds( bounds, sharedData.displaySize.width, sharedData.displaySize.height );\n      };\n      \n      const unitPositionToDisplayPosition = ( position ) => {\n        return phet.paperLand.utils.paperToBoardCoordinates( position, sharedData.displaySize.width, sharedData.displaySize.height );\n      };\n    \n      const setCenterX = ( x ) => {\n        ballViewPath.centerX = phet.paperLand.utils.paperToBoardX( x, sharedData.displaySize.width );\n      };\n      \n      const setCenterY = ( y ) => {\n        ballViewPath.centerY = phet.paperLand.utils.paperToBoardY( y, sharedData.displaySize.height );\n      };\n      \n      const setLeft = ( left ) => {\n        ballViewPath.left = phet.paperLand.utils.paperToBoardX( left, sharedData.displaySize.width );\n      };\n      \n      const setTop = ( top ) => {\n        ballViewPath.top = phet.paperLand.utils.paperToBoardY( top, sharedData.displaySize.height );\n      };\n      \n      const setScale = ( scale ) => {\n        ballViewPath.setScaleMagnitude( scale );\n      };\n      \n      const setOpacity = ( opacity ) => {\n        ballViewPath.opacity = opacity;\n      };\n      \n      const setVisible = ( visible ) => {\n        ballViewPath.visible = visible;\n      };\n      \n      const moveToFront = () => {\n        ballViewPath.moveToFront();\n      };\n      \n      const moveToBack = () => {\n        ballViewPath.moveToBack();\n      };\n      \n      const setRotation = ( rotation ) => {\n        ballViewPath.rotation = rotation;\n      };\n\n      // Set the scale in X and Y and the       \n      const matchBounds = ( bounds, stretch ) => {\n      \n        // Find the scale to apply to the x and y dimensions so that the component bounds match the provided bounds\n        const ballViewPathViewBounds = phet.paperLand.utils.paperToBoardBounds(bounds, sharedData.displaySize.width, sharedData.displaySize.height);\n\n        // local bounds may be zero as things load\n        // const aspectRatio = ( ballViewPath.localBounds.width || 1 ) / ( ballViewPath.localBounds.height || 1 );\n\n        const scaleX = ballViewPathViewBounds.width / ( ballViewPath.localBounds.width || 1 );\n        const scaleY = ballViewPathViewBounds.height / ( ballViewPath.localBounds.height || 1 );\n\n        if ( stretch ) {\n          ballViewPath.setScaleMagnitude(scaleX, scaleY);\n        }\n        else {\n        \n          // Scale by the minimum of the x and y scale factors, preserving the aspect ratio\n          ballViewPath.setScaleMagnitude( Math.min( scaleX, scaleY ) );\n        }        \n\n        // Now put the component in the center of the bounds\n        ballViewPath.center = ballViewPathViewBounds.center;\n      };\n      \n\n        const setStroke = ( color ) => {\n          ballViewPath.stroke = color;\n        };\n        \n        const setLineWidth = ( width ) => {\n          ballViewPath.lineWidth = width;\n        };\n        \n        const setFill = ( color ) => {\n          ballViewPath.fill = color;\n        };\n        \n        // for a line - Beware that the x/y variables are declared via the ShapeCodeFunctions!\n        const setX1 = ( newX1 ) => {\n          ballView_x1 = phet.paperLand.utils.paperToBoardX( newX1, sharedData.displaySize.width );\n          ballViewPath.shape = phet.kite.Shape.lineSegment( ballView_x1, ballView_y1, ballView_x2, ballView_y2 );\n        };\n        \n        const setY1 = ( newY1 ) => {\n          ballView_y1 = phet.paperLand.utils.paperToBoardY( newY1, sharedData.displaySize.height );\n          ballViewPath.shape = phet.kite.Shape.lineSegment( ballView_x1, ballView_y1, ballView_x2, ballView_y2 );\n        };\n\n        const setX2 = ( newX2 ) => {\n          ballView_x2 = phet.paperLand.utils.paperToBoardX( newX2, sharedData.displaySize.width );\n          ballViewPath.shape = phet.kite.Shape.lineSegment( ballView_x1, ballView_y1, ballView_x2, ballView_y2 );\n        };\n        \n        const setY2 = ( newY2 ) => {\n          ballView_y2 = phet.paperLand.utils.paperToBoardY( newY2, sharedData.displaySize.height );\n          ballViewPath.shape = phet.kite.Shape.lineSegment( ballView_x1, ballView_y1, ballView_x2, ballView_y2 );\n        };\n        \n        // for a circle\n        const setRadius = ( radius ) => {\n          // since this is a Path and not a Circle, we need to recreate the shape\n          ballViewPath.shape = phet.kite.Shape.circle( phet.paperLand.utils.paperToBoardX( radius, sharedData.displaySize.width ) );\n        };\n        \n        // for a rectangle\n        const setRectBounds = ( bounds ) => {\n          const transformedBounds = unitBoundsToDisplayBounds( bounds );\n          ballViewPath.shape = phet.kite.Shape.bounds( transformedBounds );\n        };\n        \n        // for a polygon\n        const setPoints = ( points ) => {\n          const transformedPoints = points.map( thisPoint => unitPositionToDisplayPosition( thisPoint ) );\n          ballViewPath.shape = phet.kite.Shape.polygon( transformedPoints );\n        };\n        \n        // bring in the reference components so they are available in the control function\n        \n        \n        setCenterX( ballPosition.x );\nsetCenterY( ballPosition.y );\n\nsetRotation( ballRotation );\n      }, {\n        otherProperties: [ phet.paperLand.displaySizeProperty ],\n        otherReferences: [  ]\n      } );\n    \n\n      // Speak whenever the dependencies change.\n      const speakWonSpeechFunction = ( gameWon ) => {\n      \n        // get the additional reference constants so they are available in the control function\n        \n      \n        // in a local scope, define the functions that the user can use to manipulate the text\n        \n      const unitBoundsToDisplayBounds = ( bounds ) => {\n        return phet.paperLand.utils.paperToBoardBounds( bounds, sharedData.displaySize.width, sharedData.displaySize.height );\n      };\n      \n      const unitPositionToDisplayPosition = ( position ) => {\n        return phet.paperLand.utils.paperToBoardCoordinates( position, sharedData.displaySize.width, sharedData.displaySize.height );\n      };\n    \n      const setCenterX = ( x ) => {\n        speakWonSpeech.centerX = x;\n      };\n      \n      const setCenterY = ( y ) => {\n        speakWonSpeech.centerY = y;\n      };\n      \n      const setLeft = ( left ) => {\n        speakWonSpeech.left = left;\n      };\n      \n      const setTop = ( top ) => {\n        speakWonSpeech.top = top;\n      };\n      \n      const setScale = ( scale ) => {\n        speakWonSpeech.setScaleMagnitude( scale );\n      };\n      \n      const setOpacity = ( opacity ) => {\n        speakWonSpeech.opacity = opacity;\n      };\n      \n      const setVisible = ( visible ) => {\n        speakWonSpeech.visible = visible;\n      };\n      \n      const moveToFront = () => {\n        speakWonSpeech.moveToFront();\n      };\n      \n      const moveToBack = () => {\n        speakWonSpeech.moveToBack();\n      };\n      \n      const setRotation = ( rotation ) => {\n        speakWonSpeech.rotation = rotation;\n      };\n\n      // Set the scale in X and Y and the       \n      const matchBounds = ( bounds, stretch ) => {\n      \n        // Find the scale to apply to the x and y dimensions so that the component bounds match the provided bounds\n        const speakWonSpeechViewBounds = phet.paperLand.utils.paperToBoardBounds(bounds, sharedData.displaySize.width, sharedData.displaySize.height);\n\n        // local bounds may be zero as things load\n        // const aspectRatio = ( speakWonSpeech.localBounds.width || 1 ) / ( speakWonSpeech.localBounds.height || 1 );\n\n        const scaleX = speakWonSpeechViewBounds.width / ( speakWonSpeech.localBounds.width || 1 );\n        const scaleY = speakWonSpeechViewBounds.height / ( speakWonSpeech.localBounds.height || 1 );\n\n        if ( stretch ) {\n          speakWonSpeech.setScaleMagnitude(scaleX, scaleY);\n        }\n        else {\n        \n          // Scale by the minimum of the x and y scale factors, preserving the aspect ratio\n          speakWonSpeech.setScaleMagnitude( Math.min( scaleX, scaleY ) );\n        }        \n\n        // Now put the component in the center of the bounds\n        speakWonSpeech.center = speakWonSpeechViewBounds.center;\n      };\n      \n\n      \n        // Stop all speech and clear the queue\n        const interruptSpeech = () => {\n          phet.scenery.voicingUtteranceQueue.cancel();;\n        };\n        \n        // Mute/unmute the utterance queue\n        const setMuted = ( v ) => {\n          phet.scenery.voicingUtteranceQueue.setMuted( v );\n        };\n        \n        // Sets the priority of this utterance in the queue\n        const setPriority = ( v ) => {\n          scratchpad.speakWonSpeechUtterance.priorityProperty.value = v;\n        }\n        \n        const setAlertStableDelay = ( v ) => {\n          scratchpad.speakWonSpeechUtterance.setAlertStableDelay( v );\n        };\n        \n        const setVoiceRate = ( v ) => {\n          phet.scenery.voicingManager.voiceRateProperty.value = v;\n        };\n        \n        const setVoicePitch = ( v ) => {\n          phet.scenery.voicingManager.voicePitchProperty.value = v;\n        };\n      \n      \n        if (gameWon) {\n return \"You did it!\"\n}\n      }\n      \n      // a reusable utterance for this speech component so that only the latest value is spoken - in general\n      // it should not cancel other Utterances in this context but it should cancel itself\n      scratchpad.speakWonSpeechUtterance = new phet.utteranceQueue.Utterance( { announcerOptions: { cancelOther: false } } );\n      \n      scratchpad.speakWonSpeechMultilinkId = phet.paperLand.addModelPropertyMultilink( [ 'gameWon' ], ( gameWon ) => {\n\n        // Make sure there is a string to speak, including converting falsy values and numbers to a string       \n        const speechResult = speakWonSpeechFunction( gameWon );\n        if ( speechResult && speechResult.toString ) {\n          const speechString = speechResult.toString();\n          if ( speechString && speechString.length > 0 ) {\n            scratchpad.speakWonSpeechUtterance.alert = speechString;\n            phet.scenery.voicingUtteranceQueue.addToBack( scratchpad.speakWonSpeechUtterance ); \n          }\n        }\n      }, {\n        lazy: false,\n        otherReferences: [  ]\n      } ); \n    \n\n      const gameLoopAnimationListener = dt => {\n      \n        // listener only runs if all declared dependencies are available in the model\n        if ( phet.paperLand.hasAllModelComponents( [ 'gameWon', 'ballPosition', 'ballVelocity', 'ballRotation', 'paddleCollideTrigger', 'paddleBounds', 'brick1Visible', 'brick1Bounds', 'resetGameTrigger', 'brick2Visible', 'brick2Bounds', 'brick3Visible', 'brick3Bounds', 'brick4Visible', 'brick4Bounds' ] ) ) {\n               \n          // A reference to the elapsed time so it is usable in the function\n          const elapsedTime = phet.paperLand.elapsedTimeProperty.value;\n          \n          // references to each model component controlled by this listener\n          const gameWon = phet.paperLand.getModelComponent( 'gameWon' ).value;\nconst ballPosition = phet.paperLand.getModelComponent( 'ballPosition' ).value;\nconst ballVelocity = phet.paperLand.getModelComponent( 'ballVelocity' ).value;\nconst ballRotation = phet.paperLand.getModelComponent( 'ballRotation' ).value;\nconst paddleCollideTrigger = phet.paperLand.getModelComponent( 'paddleCollideTrigger' ).value;\nconst paddleBounds = phet.paperLand.getModelComponent( 'paddleBounds' ).value;\nconst brick1Visible = phet.paperLand.getModelComponent( 'brick1Visible' ).value;\nconst brick1Bounds = phet.paperLand.getModelComponent( 'brick1Bounds' ).value;\nconst resetGameTrigger = phet.paperLand.getModelComponent( 'resetGameTrigger' ).value;\nconst brick2Visible = phet.paperLand.getModelComponent( 'brick2Visible' ).value;\nconst brick2Bounds = phet.paperLand.getModelComponent( 'brick2Bounds' ).value;\nconst brick3Visible = phet.paperLand.getModelComponent( 'brick3Visible' ).value;\nconst brick3Bounds = phet.paperLand.getModelComponent( 'brick3Bounds' ).value;\nconst brick4Visible = phet.paperLand.getModelComponent( 'brick4Visible' ).value;\nconst brick4Bounds = phet.paperLand.getModelComponent( 'brick4Bounds' ).value;\n        \n          // the functions create in the local scope to manipulate the controlled components\n          const setGameWon = newValue => {\n        const modelComponent = phet.paperLand.getModelComponent( 'gameWon' );\n        modelComponent.value = newValue;  \n      }\n      \nconst setBallPosition = newValue => {\n        const modelComponent = phet.paperLand.getModelComponent( 'ballPosition' );\n        modelComponent.value = newValue;  \n      }\n      \nconst setBallVelocity = newValue => {\n        const modelComponent = phet.paperLand.getModelComponent( 'ballVelocity' );\n        modelComponent.value = newValue;  \n      }\n      \nconst setBallRotation = newValue => {\n        const modelComponent = phet.paperLand.getModelComponent( 'ballRotation' );\n        modelComponent.value = newValue;  \n      }\n      \nconst setPaddleCollideTrigger = newValue => {\n        const modelComponent = phet.paperLand.getModelComponent( 'paddleCollideTrigger' );\n        modelComponent.value = newValue;  \n      }\n      \nconst setPaddleBounds = newValue => {\n        const modelComponent = phet.paperLand.getModelComponent( 'paddleBounds' );\n        modelComponent.value = newValue;  \n      }\n      \nconst setBrick1Visible = newValue => {\n        const modelComponent = phet.paperLand.getModelComponent( 'brick1Visible' );\n        modelComponent.value = newValue;  \n      }\n      \nconst setBrick1Bounds = newValue => {\n        const modelComponent = phet.paperLand.getModelComponent( 'brick1Bounds' );\n        modelComponent.value = newValue;  \n      }\n      \nconst setResetGameTrigger = newValue => {\n        const modelComponent = phet.paperLand.getModelComponent( 'resetGameTrigger' );\n        modelComponent.value = newValue;  \n      }\n      \nconst setBrick2Visible = newValue => {\n        const modelComponent = phet.paperLand.getModelComponent( 'brick2Visible' );\n        modelComponent.value = newValue;  \n      }\n      \nconst setBrick2Bounds = newValue => {\n        const modelComponent = phet.paperLand.getModelComponent( 'brick2Bounds' );\n        modelComponent.value = newValue;  \n      }\n      \nconst setBrick3Visible = newValue => {\n        const modelComponent = phet.paperLand.getModelComponent( 'brick3Visible' );\n        modelComponent.value = newValue;  \n      }\n      \nconst setBrick3Bounds = newValue => {\n        const modelComponent = phet.paperLand.getModelComponent( 'brick3Bounds' );\n        modelComponent.value = newValue;  \n      }\n      \nconst setBrick4Visible = newValue => {\n        const modelComponent = phet.paperLand.getModelComponent( 'brick4Visible' );\n        modelComponent.value = newValue;  \n      }\n      \nconst setBrick4Bounds = newValue => {\n        const modelComponent = phet.paperLand.getModelComponent( 'brick4Bounds' );\n        modelComponent.value = newValue;  \n      }\n      \n          \n          // the function that that the user wrote\n          // A constant used to set speed of the ball, change this value to make it move faster\n// or slower - ball velocity will be set based on game state using this value.\nconst ballSpeedY = 0.3;\nconst ballSpeedX = 0.2;\n\n// just for fun, make the ball rotate\nsetBallRotation( elapsedTime * 10 );\n\n// Update the ball to its new position based on the current velocity\nsetBallPosition( new phet.dot.Vector2(\n    ballPosition.x + ballVelocity.x * dt,\n    ballPosition.y + ballVelocity.y * dt,\n) );\n\n// if the ball goes below the paddle, reset its position and velocity to keep playing\nif ( ballPosition.y > 1 ) {\n    setBallPosition( new phet.dot.Vector2( 0.5, 0.5 ) );\n    setBallVelocity( new phet.dot.Vector2( 0, ballSpeedY ) );\n}\n\n// if the ball hits the left or right edge of the screen, set the x component\n// so that it stays in screen\nif ( ballPosition.x < 0 ) {\n    setBallVelocity( new phet.dot.Vector2( ballSpeedX, ballVelocity.y ) );\n}\nif ( ballPosition.x > 1 ) {\n    setBallVelocity( new phet.dot.Vector2( -ballSpeedX, ballVelocity.y ) );\n}\n\n// if the ball hits the top (0), flip the y component of velocity\nif ( ballPosition.y < 0 ) {\n    setBallVelocity( new phet.dot.Vector2( ballVelocity.x, ballSpeedY ) );\n}\n\n// If the ball hits the paddle, make it move up and give a random component of x velocity\nif ( paddleBounds.containsPoint( ballPosition ) ) {\n\n    // Ball will move in the direction of the side of the paddle it hits\n    let ballVelocityX = 0.5 * ( ( ballPosition.x - paddleBounds.centerX ) / paddleBounds.width );\n    setBallVelocity( new phet.dot.Vector2( ballVelocityX, -ballSpeedY ) );\n\n    // Set a trigger that will play a sound on the collision\n    setPaddleCollideTrigger( true );\n}\nelse {\n\n    // The paddle is no longer touching the ball, set the collide trigger to false\n    setPaddleCollideTrigger( false );\n}\n\n\n// collect brick bounds, visibility, and visibility setter functions into an array to work with them easily\nconst allBrickBounds = [\n    brick1Bounds,\n    brick2Bounds,\n    brick3Bounds,\n    brick4Bounds\n];\n\nconst allBrickVisibles = [\n    brick1Visible,\n    brick2Visible,\n    brick3Visible,\n    brick4Visible\n];\n\nconst brickVisibleSetters = [\n    setBrick1Visible,\n    setBrick2Visible,\n    setBrick3Visible,\n    setBrick4Visible\n];\n\n// If the ball hits any brick, make it invisible and then make the ball move down\nallBrickBounds.forEach( ( bounds, index ) => {\n\n    // NOTE - this assumes that the bricks in bounds and visibilities are IN THE SAME ORDER\n    // because the lookup for visibility setter uses the index from the bounds array.\n    const isBrickVisible = allBrickVisibles[ index ];\n    if ( isBrickVisible && bounds.containsPoint( ballPosition ) ) {\n        brickVisibleSetters[ index ]( false );\n        setBallVelocity( new phet.dot.Vector2( ballVelocity.x, ballSpeedY ) );\n    }\n} );\n\n// instead of using a link, it is easiest to reset the game state directly in the game loop since\n// we have the collections of bricks set up here\nif ( resetGameTrigger ) {\n    setBallVelocity( new phet.dot.Vector2( ballSpeedX, ballSpeedY ) );\n    setBallPosition( new phet.dot.Vector2( 0.5, 0.5 ) );\n\n    brickVisibleSetters.forEach( visibleSetter => {\n        visibleSetter( true );\n    } );\n}\n\n// game is won when all bricks are invisible\nsetGameWon( allBrickVisibles.every( brickVisible => !brickVisible ) ); \n        }\n      };\n      scratchpad.gameLoopAnimationListener = gameLoopAnimationListener;\n      \n      // add the listener to the step timer\n      phet.axon.stepTimer.addListener( gameLoopAnimationListener );\n      \n    \n  };\n\n  const onProgramRemoved = ( paperNumber, scratchpad, sharedData ) => {\n    \n      // Remove the component from the model\n      phet.paperLand.removeModelComponent( 'gameWon' );\n    \n\n      // Remove the component from the model\n      phet.paperLand.removeModelComponent( 'ballPosition' );\n    \n\n      // Remove the component from the model\n      phet.paperLand.removeModelComponent( 'ballVelocity' );\n    \n\n      // Remove the component from the model\n      phet.paperLand.removeModelComponent( 'ballRotation' );\n    \n\n      phet.tambo.soundManager.removeSoundGenerator( scratchpad.gameBeatSoundClip );\n      delete scratchpad.gameBeatSoundClip;\n      \n      scratchpad.gameBeatWrappedAudioBuffer.audioBufferProperty.unlink( scratchpad.gameBeatWrappedAudioBufferListener );\n      delete scratchpad.gameBeatWrappedAudioBufferListener;\n      \n      phet.paperLand.removeModelPropertyMultilink( [ 'gameWon' ], scratchpad.gameBeatSoundMultilinkId, {\n        otherReferences: [  ]\n       } );\n      delete scratchpad.gameBeatSoundMultilinkId;\n    \n\n      phet.tambo.soundManager.removeSoundGenerator( scratchpad.gameWonSoundSoundClip );\n      delete scratchpad.gameWonSoundSoundClip;\n      \n      scratchpad.gameWonSoundWrappedAudioBuffer.audioBufferProperty.unlink( scratchpad.gameWonSoundWrappedAudioBufferListener );\n      delete scratchpad.gameWonSoundWrappedAudioBufferListener;\n      \n      phet.paperLand.removeModelPropertyMultilink( [ 'gameWon' ], scratchpad.gameWonSoundSoundMultilinkId, {\n        otherReferences: [  ]\n       } );\n      delete scratchpad.gameWonSoundSoundMultilinkId;\n    \n\n      // Remove the text from the view.\n      sharedData.scene.removeChild( scratchpad.gameWonTextText );\n      delete scratchpad.gameWonTextText;\n      \n      // Remove the multilink\n      phet.paperLand.removeModelPropertyMultilink( [ 'gameWon' ], scratchpad.gameWonTextTextMultilinkId, {\n        otherReferences: [  ]\n      });\n      delete scratchpad.gameWonTextTextMultilinkId;\n    \n\n    \n      // Remove the Path from the view\n      sharedData.scene.removeChild( scratchpad.ballViewPath );\n      delete scratchpad.ballViewPath;\n      \n      // Remove the multilink\n      phet.paperLand.removeModelPropertyMultilink( [ 'ballPosition', 'ballRotation' ], scratchpad.ballViewPathMultilinkId, {\n        otherReferences: [  ]\n      } );\n      delete scratchpad.ballViewPathMultilinkId;\n    \n\n      // Remove the Speech multilink\n      phet.paperLand.removeModelPropertyMultilink( [ 'gameWon' ], scratchpad.speakWonSpeechMultilinkId, {\n        otherReferences: [  ]\n       } );\n      delete scratchpad.speakWonSpeechMultilinkId;\n      \n      // Remove the utterance\n      delete scratchpad.speakWonSpeechUtterance;\n    \n\n      phet.axon.stepTimer.removeListener( scratchpad.gameLoopAnimationListener );\n      delete scratchpad.gameLoopAnimationListener;\n    \n  };\n\n  const onProgramChangedPosition = ( paperNumber, points, scratchpad, sharedData ) => {\n    \n  };\n  \n  const onProgramMarkersAdded = ( paperNumber, points, scratchpad, sharedData, markers ) => {\n    \n  };\n  \n  const onProgramMarkersRemoved = ( paperNumber, points, scratchpad, sharedData, markers ) => {\n    \n  };\n  \n  const onProgramMarkersChangedPosition = ( paperNumber, points, scratchpad, sharedData, markers ) => {\n    \n  };\n  \n  const onProgramAdjacent = ( paperNumber, otherPaperNumber, direction, scratchpad, sharedData ) => {\n    \n  };\n  \n  const onProgramSeparated = ( paperNumber, otherPaperNumber, direction, scratchpad, sharedData ) => {\n    \n  };\n\n  await paper.set( 'data', {\n    paperPlaygroundData: {\n      updateTime: Date.now(),\n      eventHandlers: {\n        onProgramAdded: onProgramAdded.toString(),\n        onProgramRemoved: onProgramRemoved.toString(),\n        onProgramChangedPosition: onProgramChangedPosition.toString(),\n        onProgramMarkersAdded: onProgramMarkersAdded.toString(),\n        onProgramMarkersRemoved: onProgramMarkersRemoved.toString(),\n        onProgramMarkersChangedPosition: onProgramMarkersChangedPosition.toString(),\n        onProgramAdjacent: onProgramAdjacent.toString(),\n        onProgramSeparated: onProgramSeparated.toString(),\n      },\n      customWhiskerLengths: {\n        top: 0.2,\n        right: 0.2,\n        bottom: 0.2,\n        left: 0.2\n      }\n    }\n  } );\n  \n  // PROJECTOR CODE //\n  // Get a canvas object for this paper to draw something to the Projector.\n  const canvas = await paper.get('canvas');\n\n  // Draw the name of the program to the projector\n  const ctx = canvas.getContext('2d');\n  ctx.font = '20px sans-serif';\n  ctx.textAlign = 'center';\n  ctx.fillStyle = 'rgb(255,0,0)';\n  ctx.fillText('', canvas.width / 2, canvas.height / 2 - 10);\n  ctx.fillStyle = 'rgb(0,255,0)';\n  ctx.font = '10px sans-serif';\n  ctx.fillText('Game Logic', canvas.width / 2, canvas.height / 2 + 20);\n})();\n",
  "currentCode": "// Game Logic\n// Keywords: \n// Description: \n\nimportScripts('paper.js');\n\n(async () => {\n\n  const onProgramAdded = ( paperNumber, scratchpad, sharedData ) => {\n    \n      const gameWon = new phet.axon.BooleanProperty(false);\n      phet.paperLand.addModelComponent( 'gameWon', gameWon );\n    \n\n      const ballPosition = new phet.dot.Vector2Property(\n        new phet.dot.Vector2( 0.5, 0.5 )\n      );\n      phet.paperLand.addModelComponent( 'ballPosition', ballPosition );\n    \n\n      const ballVelocity = new phet.dot.Vector2Property(\n        new phet.dot.Vector2( 0.05, 0.1 )\n      );\n      phet.paperLand.addModelComponent( 'ballVelocity', ballVelocity );\n    \n\n      const ballRotation = new phet.axon.NumberProperty( 5, {\n        range: new phet.dot.Range( 0, 10 )\n      });\n      phet.paperLand.addModelComponent( 'ballRotation', ballRotation );\n    \n\n      const gameBeatWrappedAudioBuffer = createAndLoadWrappedAudioBuffer( 'media/sounds/musicalBeat.mp3' );\n      const gameBeatSoundClip = new phet.tambo.SoundClip( gameBeatWrappedAudioBuffer, {\n        loop: true,\n        initialOutputLevel: 0.5\n       } );\n      phet.tambo.soundManager.addSoundGenerator( gameBeatSoundClip );\n      scratchpad.gameBeatWrappedAudioBuffer = gameBeatWrappedAudioBuffer;\n      \n      let gameBeatStopSoundTimeout = null;\n      \n      // as a safety measure, sound can only be played every 0.25 seconds - initial value is very small\n      // so that it can be played immediately\n      let gameBeatLastPlayTime = 0;\n      \n      // The listener that will observe the model and play sounds is added as soon as the sounds are loaded, and\n      // added to the scratch pad so that it can be removed later.\n      scratchpad.gameBeatWrappedAudioBufferListener = _buffer => {\n        if ( _buffer ) {\n        \n          // Play the sound when any dependencies change value.\n          scratchpad.gameBeatSoundMultilinkId = phet.paperLand.addModelPropertyMultilink( [ 'gameWon' ], ( gameWon ) => {\n            \n            // in a local scope, define the functions that the user can use to manipulate the sound\n            const setOutputLevel = ( level ) => {\n            \n              // As a safety measure, don't let the user set a level below zero and above 2.\n              const outputLevel = Math.max( 0, Math.min( 2, level ) );\n              gameBeatSoundClip.outputLevel = outputLevel;\n            };\n            const setPlaybackRate = ( rate ) => {\n            \n              // As a safety measure, the playback rate cannot go below zero.\n              const playbackRate = Math.max( 0, rate );\n              gameBeatSoundClip.setPlaybackRate( playbackRate );\n            };\n            \n            // a function the user can call to play the sound\n            const play = () => {\n            \n              // Play the sound - if looping, we don't want to start playing again if already playing. The sound\n              // can only be played at a limited interval for safety.\n              if ( ( !gameBeatSoundClip.isPlaying || !true ) && phet.paperLand.elapsedTimeProperty.value - gameBeatLastPlayTime > 0.25 ) {\n      \n                // only start playing again if it has been stopped - but we still enter this block to update\n                // the last play time and timeouts        \n                if ( !gameBeatSoundClip.isPlaying ) {\n                  gameBeatSoundClip.play();\n                }\n                gameBeatLastPlayTime = phet.paperLand.elapsedTimeProperty.value;\n                \n                // Set a timer to turn off the sound when the value stops changing.\n                if ( gameBeatStopSoundTimeout ){\n                  window.clearTimeout( gameBeatStopSoundTimeout );\n                }\n                \n                // only stop if not looping\n                if ( !true ) {\n                  gameBeatStopSoundTimeout = window.setTimeout( () => {\n                    gameBeatSoundClip.stop();\n                  }, 5000 );\n                }  \n              }\n            };\n            \n            const stop = () => {\n              // Set a timer to turn off the sound when the value stops changing.\n              if ( gameBeatStopSoundTimeout ){\n                window.clearTimeout( gameBeatStopSoundTimeout );\n              }\n              gameBeatSoundClip.stop();\n            };\n            \n            if ( true ) {\n              play();\n            }\n            \n            // declare the references so that they can be used in the control function\n            \n          \n            \n          }, {\n            otherReferences: [  ],\n          } );  \n        }\n      };     \n      scratchpad.gameBeatWrappedAudioBuffer.audioBufferProperty.link( scratchpad.gameBeatWrappedAudioBufferListener );\n      \n      // Assign the sound to the scratchpad so that we can remove it later\n      scratchpad.gameBeatSoundClip = gameBeatSoundClip;\n    \n\n      const gameWonSoundWrappedAudioBuffer = createAndLoadWrappedAudioBuffer( 'media/sounds/short-success.mp3' );\n      const gameWonSoundSoundClip = new phet.tambo.SoundClip( gameWonSoundWrappedAudioBuffer, {\n        loop: false,\n        initialOutputLevel: 0.5\n       } );\n      phet.tambo.soundManager.addSoundGenerator( gameWonSoundSoundClip );\n      scratchpad.gameWonSoundWrappedAudioBuffer = gameWonSoundWrappedAudioBuffer;\n      \n      let gameWonSoundStopSoundTimeout = null;\n      \n      // as a safety measure, sound can only be played every 0.25 seconds - initial value is very small\n      // so that it can be played immediately\n      let gameWonSoundLastPlayTime = 0;\n      \n      // The listener that will observe the model and play sounds is added as soon as the sounds are loaded, and\n      // added to the scratch pad so that it can be removed later.\n      scratchpad.gameWonSoundWrappedAudioBufferListener = _buffer => {\n        if ( _buffer ) {\n        \n          // Play the sound when any dependencies change value.\n          scratchpad.gameWonSoundSoundMultilinkId = phet.paperLand.addModelPropertyMultilink( [ 'gameWon' ], ( gameWon ) => {\n            \n            // in a local scope, define the functions that the user can use to manipulate the sound\n            const setOutputLevel = ( level ) => {\n            \n              // As a safety measure, don't let the user set a level below zero and above 2.\n              const outputLevel = Math.max( 0, Math.min( 2, level ) );\n              gameWonSoundSoundClip.outputLevel = outputLevel;\n            };\n            const setPlaybackRate = ( rate ) => {\n            \n              // As a safety measure, the playback rate cannot go below zero.\n              const playbackRate = Math.max( 0, rate );\n              gameWonSoundSoundClip.setPlaybackRate( playbackRate );\n            };\n            \n            // a function the user can call to play the sound\n            const play = () => {\n            \n              // Play the sound - if looping, we don't want to start playing again if already playing. The sound\n              // can only be played at a limited interval for safety.\n              if ( ( !gameWonSoundSoundClip.isPlaying || !false ) && phet.paperLand.elapsedTimeProperty.value - gameWonSoundLastPlayTime > 0.25 ) {\n      \n                // only start playing again if it has been stopped - but we still enter this block to update\n                // the last play time and timeouts        \n                if ( !gameWonSoundSoundClip.isPlaying ) {\n                  gameWonSoundSoundClip.play();\n                }\n                gameWonSoundLastPlayTime = phet.paperLand.elapsedTimeProperty.value;\n                \n                // Set a timer to turn off the sound when the value stops changing.\n                if ( gameWonSoundStopSoundTimeout ){\n                  window.clearTimeout( gameWonSoundStopSoundTimeout );\n                }\n                \n                // only stop if not looping\n                if ( !false ) {\n                  gameWonSoundStopSoundTimeout = window.setTimeout( () => {\n                    gameWonSoundSoundClip.stop();\n                  }, 5000 );\n                }  \n              }\n            };\n            \n            const stop = () => {\n              // Set a timer to turn off the sound when the value stops changing.\n              if ( gameWonSoundStopSoundTimeout ){\n                window.clearTimeout( gameWonSoundStopSoundTimeout );\n              }\n              gameWonSoundSoundClip.stop();\n            };\n            \n            if ( false ) {\n              play();\n            }\n            \n            // declare the references so that they can be used in the control function\n            \n          \n            if ( gameWon ) {\n    play();\n}\n          }, {\n            otherReferences: [  ],\n          } );  \n        }\n      };     \n      scratchpad.gameWonSoundWrappedAudioBuffer.audioBufferProperty.link( scratchpad.gameWonSoundWrappedAudioBufferListener );\n      \n      // Assign the sound to the scratchpad so that we can remove it later\n      scratchpad.gameWonSoundSoundClip = gameWonSoundSoundClip;\n    \n\n      // Create the text and add it to the view - using RichText for nice markup support.\n      const gameWonTextText = new phet.scenery.RichText( '', { fill: 'white' } );\n      \n      sharedData.scene.addChild( gameWonTextText );\n      scratchpad.gameWonTextText = gameWonTextText;\n      \n      // Update the text when a dependency changes.\n      scratchpad.gameWonTextTextMultilinkId = phet.paperLand.addModelPropertyMultilink( [ 'gameWon' ], ( gameWon ) => {\n      \n        // the additional reference constants\n        \n      \n        // in a local scope, define the functions that the user can use to manipulate the text\n        \n      const unitBoundsToDisplayBounds = ( bounds ) => {\n        return phet.paperLand.utils.paperToBoardBounds( bounds, sharedData.displaySize.width, sharedData.displaySize.height );\n      };\n      \n      const unitPositionToDisplayPosition = ( position ) => {\n        return phet.paperLand.utils.paperToBoardCoordinates( position, sharedData.displaySize.width, sharedData.displaySize.height );\n      };\n    \n      const setCenterX = ( x ) => {\n        gameWonTextText.centerX = phet.paperLand.utils.paperToBoardX( x, sharedData.displaySize.width );\n      };\n      \n      const setCenterY = ( y ) => {\n        gameWonTextText.centerY = phet.paperLand.utils.paperToBoardY( y, sharedData.displaySize.height );\n      };\n      \n      const setLeft = ( left ) => {\n        gameWonTextText.left = phet.paperLand.utils.paperToBoardX( left, sharedData.displaySize.width );\n      };\n      \n      const setTop = ( top ) => {\n        gameWonTextText.top = phet.paperLand.utils.paperToBoardY( top, sharedData.displaySize.height );\n      };\n      \n      const setScale = ( scale ) => {\n        gameWonTextText.setScaleMagnitude( scale );\n      };\n      \n      const setOpacity = ( opacity ) => {\n        gameWonTextText.opacity = opacity;\n      };\n      \n      const setVisible = ( visible ) => {\n        gameWonTextText.visible = visible;\n      };\n      \n      const moveToFront = () => {\n        gameWonTextText.moveToFront();\n      };\n      \n      const moveToBack = () => {\n        gameWonTextText.moveToBack();\n      };\n      \n      const setRotation = ( rotation ) => {\n        gameWonTextText.rotation = rotation;\n      };\n\n      // Set the scale in X and Y and the       \n      const matchBounds = ( bounds, stretch ) => {\n      \n        // Find the scale to apply to the x and y dimensions so that the component bounds match the provided bounds\n        const gameWonTextTextViewBounds = phet.paperLand.utils.paperToBoardBounds(bounds, sharedData.displaySize.width, sharedData.displaySize.height);\n\n        // local bounds may be zero as things load\n        // const aspectRatio = ( gameWonTextText.localBounds.width || 1 ) / ( gameWonTextText.localBounds.height || 1 );\n\n        const scaleX = gameWonTextTextViewBounds.width / ( gameWonTextText.localBounds.width || 1 );\n        const scaleY = gameWonTextTextViewBounds.height / ( gameWonTextText.localBounds.height || 1 );\n\n        if ( stretch ) {\n          gameWonTextText.setScaleMagnitude(scaleX, scaleY);\n        }\n        else {\n        \n          // Scale by the minimum of the x and y scale factors, preserving the aspect ratio\n          gameWonTextText.setScaleMagnitude( Math.min( scaleX, scaleY ) );\n        }        \n\n        // Now put the component in the center of the bounds\n        gameWonTextText.center = gameWonTextTextViewBounds.center;\n      };\n      \n\n        const setString = ( string ) => {\n          gameWonTextText.string = string;\n        };\n        \n        const setFontSize = ( size ) => {\n        \n          // RichText has no setter for size, so we need to create a new font. Use\n          // state from the old font to maintain the family.\n          const currentFont = gameWonTextText.font;\n          const newFont = new phet.scenery.Font( { size: size, family: currentFont.family } );\n          gameWonTextText.font = newFont;\n        };\n\n        const setTextColor = ( color ) => {\n          gameWonTextText.fill = color;\n        };\n\n        const setFontFamily = ( family ) => {\n        \n          // RichText has no setter for fontFamily, so we need to create a new font. Use\n          // state from the old font to maintain the size.\n          const currentFont = gameWonTextText.font;\n          const newFont = new phet.scenery.Font( { size: currentFont.size, family: family } );\n          gameWonTextText.font = newFont;\n        };\n      \n\n        // the function that the user wrote to update the text      \n        setVisible( gameWon );\nsetString( 'You Won!!' );\nsetFontSize( 48 );\n\nsetCenterX( 0.5 )\nsetCenterY( 0.5 );\n      }, {\n        otherProperties: [ phet.paperLand.displaySizeProperty ],\n        otherReferences: [  ]\n      } );\n    \n\n\n      // Create a shape with kite.\n      const ballViewShape = phet.kite.Shape.ellipse( phet.paperLand.utils.paperToBoardX( 0.03, sharedData.displaySize.width ), phet.paperLand.utils.paperToBoardY( 0.03, sharedData.displaySize.height ) )\n      \n      // create a path for the shape\n      const ballViewPath = new phet.scenery.Path( ballViewShape, {\n        fill: 'red',\n        stroke: 'blue',\n        lineWidth: 1,\n        \n        // if initial position is zero, do not set that explicitly because it will break shape points \n        centerX: ('model' === 'model' && 0.5) ? phet.paperLand.utils.paperToBoardX( 0.5, sharedData.displaySize.width ) : 0.5,\n        centerY: ('model' === 'model' && 0.5) ? phet.paperLand.utils.paperToBoardY( 0.5, sharedData.displaySize.height) : 0.5,\n        scale: 1,\n        rotation: 0,\n        opacity: 1\n      } );\n      \n      // assign to scratchpad so that we can remove it later\n      sharedData.scene.addChild( ballViewPath );\n      scratchpad.ballViewPath = ballViewPath;\n      \n      // Update the shape when a dependency changes.\n      scratchpad.ballViewPathMultilinkId = phet.paperLand.addModelPropertyMultilink( [ 'ballPosition', 'ballRotation' ], ( ballPosition, ballRotation ) => {\n      \n        // We have to recreate the shape every change (especially important for a resize) - this is done first though\n        // because the user control functions might change the shape further.\n        const ballViewShape = phet.kite.Shape.ellipse( phet.paperLand.utils.paperToBoardX( 0.03, sharedData.displaySize.width ), phet.paperLand.utils.paperToBoardY( 0.03, sharedData.displaySize.height ) )\n        scratchpad.ballViewPath.setShape( ballViewShape );\n        \n        // now mutate with options that might depend on the shape or layout changes (again, user might override this \n        // so do before the control function)\n        scratchpad.ballViewPath.mutate( {\n          // if initial position is zero, do not set that explicitly because it will break shape points \n          centerX: ('model' === 'model' && 0.5) ? phet.paperLand.utils.paperToBoardX( 0.5, sharedData.displaySize.width ) : 0.5,\n          centerY: ('model' === 'model' && 0.5) ? phet.paperLand.utils.paperToBoardY( 0.5, sharedData.displaySize.height) : 0.5,\n          scale: 1,\n          rotation: 0\n        } );\n      \n        // the functions that are available for this view type\n        \n      const unitBoundsToDisplayBounds = ( bounds ) => {\n        return phet.paperLand.utils.paperToBoardBounds( bounds, sharedData.displaySize.width, sharedData.displaySize.height );\n      };\n      \n      const unitPositionToDisplayPosition = ( position ) => {\n        return phet.paperLand.utils.paperToBoardCoordinates( position, sharedData.displaySize.width, sharedData.displaySize.height );\n      };\n    \n      const setCenterX = ( x ) => {\n        ballViewPath.centerX = phet.paperLand.utils.paperToBoardX( x, sharedData.displaySize.width );\n      };\n      \n      const setCenterY = ( y ) => {\n        ballViewPath.centerY = phet.paperLand.utils.paperToBoardY( y, sharedData.displaySize.height );\n      };\n      \n      const setLeft = ( left ) => {\n        ballViewPath.left = phet.paperLand.utils.paperToBoardX( left, sharedData.displaySize.width );\n      };\n      \n      const setTop = ( top ) => {\n        ballViewPath.top = phet.paperLand.utils.paperToBoardY( top, sharedData.displaySize.height );\n      };\n      \n      const setScale = ( scale ) => {\n        ballViewPath.setScaleMagnitude( scale );\n      };\n      \n      const setOpacity = ( opacity ) => {\n        ballViewPath.opacity = opacity;\n      };\n      \n      const setVisible = ( visible ) => {\n        ballViewPath.visible = visible;\n      };\n      \n      const moveToFront = () => {\n        ballViewPath.moveToFront();\n      };\n      \n      const moveToBack = () => {\n        ballViewPath.moveToBack();\n      };\n      \n      const setRotation = ( rotation ) => {\n        ballViewPath.rotation = rotation;\n      };\n\n      // Set the scale in X and Y and the       \n      const matchBounds = ( bounds, stretch ) => {\n      \n        // Find the scale to apply to the x and y dimensions so that the component bounds match the provided bounds\n        const ballViewPathViewBounds = phet.paperLand.utils.paperToBoardBounds(bounds, sharedData.displaySize.width, sharedData.displaySize.height);\n\n        // local bounds may be zero as things load\n        // const aspectRatio = ( ballViewPath.localBounds.width || 1 ) / ( ballViewPath.localBounds.height || 1 );\n\n        const scaleX = ballViewPathViewBounds.width / ( ballViewPath.localBounds.width || 1 );\n        const scaleY = ballViewPathViewBounds.height / ( ballViewPath.localBounds.height || 1 );\n\n        if ( stretch ) {\n          ballViewPath.setScaleMagnitude(scaleX, scaleY);\n        }\n        else {\n        \n          // Scale by the minimum of the x and y scale factors, preserving the aspect ratio\n          ballViewPath.setScaleMagnitude( Math.min( scaleX, scaleY ) );\n        }        \n\n        // Now put the component in the center of the bounds\n        ballViewPath.center = ballViewPathViewBounds.center;\n      };\n      \n\n        const setStroke = ( color ) => {\n          ballViewPath.stroke = color;\n        };\n        \n        const setLineWidth = ( width ) => {\n          ballViewPath.lineWidth = width;\n        };\n        \n        const setFill = ( color ) => {\n          ballViewPath.fill = color;\n        };\n        \n        // for a line - Beware that the x/y variables are declared via the ShapeCodeFunctions!\n        const setX1 = ( newX1 ) => {\n          ballView_x1 = phet.paperLand.utils.paperToBoardX( newX1, sharedData.displaySize.width );\n          ballViewPath.shape = phet.kite.Shape.lineSegment( ballView_x1, ballView_y1, ballView_x2, ballView_y2 );\n        };\n        \n        const setY1 = ( newY1 ) => {\n          ballView_y1 = phet.paperLand.utils.paperToBoardY( newY1, sharedData.displaySize.height );\n          ballViewPath.shape = phet.kite.Shape.lineSegment( ballView_x1, ballView_y1, ballView_x2, ballView_y2 );\n        };\n\n        const setX2 = ( newX2 ) => {\n          ballView_x2 = phet.paperLand.utils.paperToBoardX( newX2, sharedData.displaySize.width );\n          ballViewPath.shape = phet.kite.Shape.lineSegment( ballView_x1, ballView_y1, ballView_x2, ballView_y2 );\n        };\n        \n        const setY2 = ( newY2 ) => {\n          ballView_y2 = phet.paperLand.utils.paperToBoardY( newY2, sharedData.displaySize.height );\n          ballViewPath.shape = phet.kite.Shape.lineSegment( ballView_x1, ballView_y1, ballView_x2, ballView_y2 );\n        };\n        \n        // for a circle\n        const setRadius = ( radius ) => {\n          // since this is a Path and not a Circle, we need to recreate the shape\n          ballViewPath.shape = phet.kite.Shape.circle( phet.paperLand.utils.paperToBoardX( radius, sharedData.displaySize.width ) );\n        };\n        \n        // for a rectangle\n        const setRectBounds = ( bounds ) => {\n          const transformedBounds = unitBoundsToDisplayBounds( bounds );\n          ballViewPath.shape = phet.kite.Shape.bounds( transformedBounds );\n        };\n        \n        // for a polygon\n        const setPoints = ( points ) => {\n          const transformedPoints = points.map( thisPoint => unitPositionToDisplayPosition( thisPoint ) );\n          ballViewPath.shape = phet.kite.Shape.polygon( transformedPoints );\n        };\n        \n        // bring in the reference components so they are available in the control function\n        \n        \n        setCenterX( ballPosition.x );\nsetCenterY( ballPosition.y );\n\nsetRotation( ballRotation );\n      }, {\n        otherProperties: [ phet.paperLand.displaySizeProperty ],\n        otherReferences: [  ]\n      } );\n    \n\n      // Speak whenever the dependencies change.\n      const speakWonSpeechFunction = ( gameWon ) => {\n      \n        // get the additional reference constants so they are available in the control function\n        \n      \n        // in a local scope, define the functions that the user can use to manipulate the text\n        \n      const unitBoundsToDisplayBounds = ( bounds ) => {\n        return phet.paperLand.utils.paperToBoardBounds( bounds, sharedData.displaySize.width, sharedData.displaySize.height );\n      };\n      \n      const unitPositionToDisplayPosition = ( position ) => {\n        return phet.paperLand.utils.paperToBoardCoordinates( position, sharedData.displaySize.width, sharedData.displaySize.height );\n      };\n    \n      const setCenterX = ( x ) => {\n        speakWonSpeech.centerX = x;\n      };\n      \n      const setCenterY = ( y ) => {\n        speakWonSpeech.centerY = y;\n      };\n      \n      const setLeft = ( left ) => {\n        speakWonSpeech.left = left;\n      };\n      \n      const setTop = ( top ) => {\n        speakWonSpeech.top = top;\n      };\n      \n      const setScale = ( scale ) => {\n        speakWonSpeech.setScaleMagnitude( scale );\n      };\n      \n      const setOpacity = ( opacity ) => {\n        speakWonSpeech.opacity = opacity;\n      };\n      \n      const setVisible = ( visible ) => {\n        speakWonSpeech.visible = visible;\n      };\n      \n      const moveToFront = () => {\n        speakWonSpeech.moveToFront();\n      };\n      \n      const moveToBack = () => {\n        speakWonSpeech.moveToBack();\n      };\n      \n      const setRotation = ( rotation ) => {\n        speakWonSpeech.rotation = rotation;\n      };\n\n      // Set the scale in X and Y and the       \n      const matchBounds = ( bounds, stretch ) => {\n      \n        // Find the scale to apply to the x and y dimensions so that the component bounds match the provided bounds\n        const speakWonSpeechViewBounds = phet.paperLand.utils.paperToBoardBounds(bounds, sharedData.displaySize.width, sharedData.displaySize.height);\n\n        // local bounds may be zero as things load\n        // const aspectRatio = ( speakWonSpeech.localBounds.width || 1 ) / ( speakWonSpeech.localBounds.height || 1 );\n\n        const scaleX = speakWonSpeechViewBounds.width / ( speakWonSpeech.localBounds.width || 1 );\n        const scaleY = speakWonSpeechViewBounds.height / ( speakWonSpeech.localBounds.height || 1 );\n\n        if ( stretch ) {\n          speakWonSpeech.setScaleMagnitude(scaleX, scaleY);\n        }\n        else {\n        \n          // Scale by the minimum of the x and y scale factors, preserving the aspect ratio\n          speakWonSpeech.setScaleMagnitude( Math.min( scaleX, scaleY ) );\n        }        \n\n        // Now put the component in the center of the bounds\n        speakWonSpeech.center = speakWonSpeechViewBounds.center;\n      };\n      \n\n      \n        // Stop all speech and clear the queue\n        const interruptSpeech = () => {\n          phet.scenery.voicingUtteranceQueue.cancel();;\n        };\n        \n        // Mute/unmute the utterance queue\n        const setMuted = ( v ) => {\n          phet.scenery.voicingUtteranceQueue.setMuted( v );\n        };\n        \n        // Sets the priority of this utterance in the queue\n        const setPriority = ( v ) => {\n          scratchpad.speakWonSpeechUtterance.priorityProperty.value = v;\n        }\n        \n        const setAlertStableDelay = ( v ) => {\n          scratchpad.speakWonSpeechUtterance.setAlertStableDelay( v );\n        };\n        \n        const setVoiceRate = ( v ) => {\n          phet.scenery.voicingManager.voiceRateProperty.value = v;\n        };\n        \n        const setVoicePitch = ( v ) => {\n          phet.scenery.voicingManager.voicePitchProperty.value = v;\n        };\n      \n      \n        if (gameWon) {\n return \"You did it!\"\n}\n      }\n      \n      // a reusable utterance for this speech component so that only the latest value is spoken - in general\n      // it should not cancel other Utterances in this context but it should cancel itself\n      scratchpad.speakWonSpeechUtterance = new phet.utteranceQueue.Utterance( { announcerOptions: { cancelOther: false } } );\n      \n      scratchpad.speakWonSpeechMultilinkId = phet.paperLand.addModelPropertyMultilink( [ 'gameWon' ], ( gameWon ) => {\n\n        // Make sure there is a string to speak, including converting falsy values and numbers to a string       \n        const speechResult = speakWonSpeechFunction( gameWon );\n        if ( speechResult && speechResult.toString ) {\n          const speechString = speechResult.toString();\n          if ( speechString && speechString.length > 0 ) {\n            scratchpad.speakWonSpeechUtterance.alert = speechString;\n            phet.scenery.voicingUtteranceQueue.addToBack( scratchpad.speakWonSpeechUtterance ); \n          }\n        }\n      }, {\n        lazy: false,\n        otherReferences: [  ]\n      } ); \n    \n\n      const gameLoopAnimationListener = dt => {\n      \n        // listener only runs if all declared dependencies are available in the model\n        if ( phet.paperLand.hasAllModelComponents( [ 'gameWon', 'ballPosition', 'ballVelocity', 'ballRotation', 'paddleCollideTrigger', 'paddleBounds', 'brick1Visible', 'brick1Bounds', 'resetGameTrigger', 'brick2Visible', 'brick2Bounds', 'brick3Visible', 'brick3Bounds', 'brick4Visible', 'brick4Bounds' ] ) ) {\n               \n          // A reference to the elapsed time so it is usable in the function\n          const elapsedTime = phet.paperLand.elapsedTimeProperty.value;\n          \n          // references to each model component controlled by this listener\n          const gameWon = phet.paperLand.getModelComponent( 'gameWon' ).value;\nconst ballPosition = phet.paperLand.getModelComponent( 'ballPosition' ).value;\nconst ballVelocity = phet.paperLand.getModelComponent( 'ballVelocity' ).value;\nconst ballRotation = phet.paperLand.getModelComponent( 'ballRotation' ).value;\nconst paddleCollideTrigger = phet.paperLand.getModelComponent( 'paddleCollideTrigger' ).value;\nconst paddleBounds = phet.paperLand.getModelComponent( 'paddleBounds' ).value;\nconst brick1Visible = phet.paperLand.getModelComponent( 'brick1Visible' ).value;\nconst brick1Bounds = phet.paperLand.getModelComponent( 'brick1Bounds' ).value;\nconst resetGameTrigger = phet.paperLand.getModelComponent( 'resetGameTrigger' ).value;\nconst brick2Visible = phet.paperLand.getModelComponent( 'brick2Visible' ).value;\nconst brick2Bounds = phet.paperLand.getModelComponent( 'brick2Bounds' ).value;\nconst brick3Visible = phet.paperLand.getModelComponent( 'brick3Visible' ).value;\nconst brick3Bounds = phet.paperLand.getModelComponent( 'brick3Bounds' ).value;\nconst brick4Visible = phet.paperLand.getModelComponent( 'brick4Visible' ).value;\nconst brick4Bounds = phet.paperLand.getModelComponent( 'brick4Bounds' ).value;\n        \n          // the functions create in the local scope to manipulate the controlled components\n          const setGameWon = newValue => {\n        const modelComponent = phet.paperLand.getModelComponent( 'gameWon' );\n        modelComponent.value = newValue;  \n      }\n      \nconst setBallPosition = newValue => {\n        const modelComponent = phet.paperLand.getModelComponent( 'ballPosition' );\n        modelComponent.value = newValue;  \n      }\n      \nconst setBallVelocity = newValue => {\n        const modelComponent = phet.paperLand.getModelComponent( 'ballVelocity' );\n        modelComponent.value = newValue;  \n      }\n      \nconst setBallRotation = newValue => {\n        const modelComponent = phet.paperLand.getModelComponent( 'ballRotation' );\n        modelComponent.value = newValue;  \n      }\n      \nconst setPaddleCollideTrigger = newValue => {\n        const modelComponent = phet.paperLand.getModelComponent( 'paddleCollideTrigger' );\n        modelComponent.value = newValue;  \n      }\n      \nconst setPaddleBounds = newValue => {\n        const modelComponent = phet.paperLand.getModelComponent( 'paddleBounds' );\n        modelComponent.value = newValue;  \n      }\n      \nconst setBrick1Visible = newValue => {\n        const modelComponent = phet.paperLand.getModelComponent( 'brick1Visible' );\n        modelComponent.value = newValue;  \n      }\n      \nconst setBrick1Bounds = newValue => {\n        const modelComponent = phet.paperLand.getModelComponent( 'brick1Bounds' );\n        modelComponent.value = newValue;  \n      }\n      \nconst setResetGameTrigger = newValue => {\n        const modelComponent = phet.paperLand.getModelComponent( 'resetGameTrigger' );\n        modelComponent.value = newValue;  \n      }\n      \nconst setBrick2Visible = newValue => {\n        const modelComponent = phet.paperLand.getModelComponent( 'brick2Visible' );\n        modelComponent.value = newValue;  \n      }\n      \nconst setBrick2Bounds = newValue => {\n        const modelComponent = phet.paperLand.getModelComponent( 'brick2Bounds' );\n        modelComponent.value = newValue;  \n      }\n      \nconst setBrick3Visible = newValue => {\n        const modelComponent = phet.paperLand.getModelComponent( 'brick3Visible' );\n        modelComponent.value = newValue;  \n      }\n      \nconst setBrick3Bounds = newValue => {\n        const modelComponent = phet.paperLand.getModelComponent( 'brick3Bounds' );\n        modelComponent.value = newValue;  \n      }\n      \nconst setBrick4Visible = newValue => {\n        const modelComponent = phet.paperLand.getModelComponent( 'brick4Visible' );\n        modelComponent.value = newValue;  \n      }\n      \nconst setBrick4Bounds = newValue => {\n        const modelComponent = phet.paperLand.getModelComponent( 'brick4Bounds' );\n        modelComponent.value = newValue;  \n      }\n      \n          \n          // the function that that the user wrote\n          // A constant used to set speed of the ball, change this value to make it move faster\n// or slower - ball velocity will be set based on game state using this value.\nconst ballSpeedY = 0.3;\nconst ballSpeedX = 0.2;\n\n// just for fun, make the ball rotate\nsetBallRotation( elapsedTime * 10 );\n\n// Update the ball to its new position based on the current velocity\nsetBallPosition( new phet.dot.Vector2(\n    ballPosition.x + ballVelocity.x * dt,\n    ballPosition.y + ballVelocity.y * dt,\n) );\n\n// if the ball goes below the paddle, reset its position and velocity to keep playing\nif ( ballPosition.y > 1 ) {\n    setBallPosition( new phet.dot.Vector2( 0.5, 0.5 ) );\n    setBallVelocity( new phet.dot.Vector2( 0, ballSpeedY ) );\n}\n\n// if the ball hits the left or right edge of the screen, set the x component\n// so that it stays in screen\nif ( ballPosition.x < 0 ) {\n    setBallVelocity( new phet.dot.Vector2( ballSpeedX, ballVelocity.y ) );\n}\nif ( ballPosition.x > 1 ) {\n    setBallVelocity( new phet.dot.Vector2( -ballSpeedX, ballVelocity.y ) );\n}\n\n// if the ball hits the top (0), flip the y component of velocity\nif ( ballPosition.y < 0 ) {\n    setBallVelocity( new phet.dot.Vector2( ballVelocity.x, ballSpeedY ) );\n}\n\n// If the ball hits the paddle, make it move up and give a random component of x velocity\nif ( paddleBounds.containsPoint( ballPosition ) ) {\n\n    // Ball will move in the direction of the side of the paddle it hits\n    let ballVelocityX = 0.5 * ( ( ballPosition.x - paddleBounds.centerX ) / paddleBounds.width );\n    setBallVelocity( new phet.dot.Vector2( ballVelocityX, -ballSpeedY ) );\n\n    // Set a trigger that will play a sound on the collision\n    setPaddleCollideTrigger( true );\n}\nelse {\n\n    // The paddle is no longer touching the ball, set the collide trigger to false\n    setPaddleCollideTrigger( false );\n}\n\n\n// collect brick bounds, visibility, and visibility setter functions into an array to work with them easily\nconst allBrickBounds = [\n    brick1Bounds,\n    brick2Bounds,\n    brick3Bounds,\n    brick4Bounds\n];\n\nconst allBrickVisibles = [\n    brick1Visible,\n    brick2Visible,\n    brick3Visible,\n    brick4Visible\n];\n\nconst brickVisibleSetters = [\n    setBrick1Visible,\n    setBrick2Visible,\n    setBrick3Visible,\n    setBrick4Visible\n];\n\n// If the ball hits any brick, make it invisible and then make the ball move down\nallBrickBounds.forEach( ( bounds, index ) => {\n\n    // NOTE - this assumes that the bricks in bounds and visibilities are IN THE SAME ORDER\n    // because the lookup for visibility setter uses the index from the bounds array.\n    const isBrickVisible = allBrickVisibles[ index ];\n    if ( isBrickVisible && bounds.containsPoint( ballPosition ) ) {\n        brickVisibleSetters[ index ]( false );\n        setBallVelocity( new phet.dot.Vector2( ballVelocity.x, ballSpeedY ) );\n    }\n} );\n\n// instead of using a link, it is easiest to reset the game state directly in the game loop since\n// we have the collections of bricks set up here\nif ( resetGameTrigger ) {\n    setBallVelocity( new phet.dot.Vector2( ballSpeedX, ballSpeedY ) );\n    setBallPosition( new phet.dot.Vector2( 0.5, 0.5 ) );\n\n    brickVisibleSetters.forEach( visibleSetter => {\n        visibleSetter( true );\n    } );\n}\n\n// game is won when all bricks are invisible\nsetGameWon( allBrickVisibles.every( brickVisible => !brickVisible ) ); \n        }\n      };\n      scratchpad.gameLoopAnimationListener = gameLoopAnimationListener;\n      \n      // add the listener to the step timer\n      phet.axon.stepTimer.addListener( gameLoopAnimationListener );\n      \n    \n  };\n\n  const onProgramRemoved = ( paperNumber, scratchpad, sharedData ) => {\n    \n      // Remove the component from the model\n      phet.paperLand.removeModelComponent( 'gameWon' );\n    \n\n      // Remove the component from the model\n      phet.paperLand.removeModelComponent( 'ballPosition' );\n    \n\n      // Remove the component from the model\n      phet.paperLand.removeModelComponent( 'ballVelocity' );\n    \n\n      // Remove the component from the model\n      phet.paperLand.removeModelComponent( 'ballRotation' );\n    \n\n      phet.tambo.soundManager.removeSoundGenerator( scratchpad.gameBeatSoundClip );\n      delete scratchpad.gameBeatSoundClip;\n      \n      scratchpad.gameBeatWrappedAudioBuffer.audioBufferProperty.unlink( scratchpad.gameBeatWrappedAudioBufferListener );\n      delete scratchpad.gameBeatWrappedAudioBufferListener;\n      \n      phet.paperLand.removeModelPropertyMultilink( [ 'gameWon' ], scratchpad.gameBeatSoundMultilinkId, {\n        otherReferences: [  ]\n       } );\n      delete scratchpad.gameBeatSoundMultilinkId;\n    \n\n      phet.tambo.soundManager.removeSoundGenerator( scratchpad.gameWonSoundSoundClip );\n      delete scratchpad.gameWonSoundSoundClip;\n      \n      scratchpad.gameWonSoundWrappedAudioBuffer.audioBufferProperty.unlink( scratchpad.gameWonSoundWrappedAudioBufferListener );\n      delete scratchpad.gameWonSoundWrappedAudioBufferListener;\n      \n      phet.paperLand.removeModelPropertyMultilink( [ 'gameWon' ], scratchpad.gameWonSoundSoundMultilinkId, {\n        otherReferences: [  ]\n       } );\n      delete scratchpad.gameWonSoundSoundMultilinkId;\n    \n\n      // Remove the text from the view.\n      sharedData.scene.removeChild( scratchpad.gameWonTextText );\n      delete scratchpad.gameWonTextText;\n      \n      // Remove the multilink\n      phet.paperLand.removeModelPropertyMultilink( [ 'gameWon' ], scratchpad.gameWonTextTextMultilinkId, {\n        otherReferences: [  ]\n      });\n      delete scratchpad.gameWonTextTextMultilinkId;\n    \n\n    \n      // Remove the Path from the view\n      sharedData.scene.removeChild( scratchpad.ballViewPath );\n      delete scratchpad.ballViewPath;\n      \n      // Remove the multilink\n      phet.paperLand.removeModelPropertyMultilink( [ 'ballPosition', 'ballRotation' ], scratchpad.ballViewPathMultilinkId, {\n        otherReferences: [  ]\n      } );\n      delete scratchpad.ballViewPathMultilinkId;\n    \n\n      // Remove the Speech multilink\n      phet.paperLand.removeModelPropertyMultilink( [ 'gameWon' ], scratchpad.speakWonSpeechMultilinkId, {\n        otherReferences: [  ]\n       } );\n      delete scratchpad.speakWonSpeechMultilinkId;\n      \n      // Remove the utterance\n      delete scratchpad.speakWonSpeechUtterance;\n    \n\n      phet.axon.stepTimer.removeListener( scratchpad.gameLoopAnimationListener );\n      delete scratchpad.gameLoopAnimationListener;\n    \n  };\n\n  const onProgramChangedPosition = ( paperNumber, points, scratchpad, sharedData ) => {\n    \n  };\n  \n  const onProgramMarkersAdded = ( paperNumber, points, scratchpad, sharedData, markers ) => {\n    \n  };\n  \n  const onProgramMarkersRemoved = ( paperNumber, points, scratchpad, sharedData, markers ) => {\n    \n  };\n  \n  const onProgramMarkersChangedPosition = ( paperNumber, points, scratchpad, sharedData, markers ) => {\n    \n  };\n  \n  const onProgramAdjacent = ( paperNumber, otherPaperNumber, direction, scratchpad, sharedData ) => {\n    \n  };\n  \n  const onProgramSeparated = ( paperNumber, otherPaperNumber, direction, scratchpad, sharedData ) => {\n    \n  };\n\n  await paper.set( 'data', {\n    paperPlaygroundData: {\n      updateTime: Date.now(),\n      eventHandlers: {\n        onProgramAdded: onProgramAdded.toString(),\n        onProgramRemoved: onProgramRemoved.toString(),\n        onProgramChangedPosition: onProgramChangedPosition.toString(),\n        onProgramMarkersAdded: onProgramMarkersAdded.toString(),\n        onProgramMarkersRemoved: onProgramMarkersRemoved.toString(),\n        onProgramMarkersChangedPosition: onProgramMarkersChangedPosition.toString(),\n        onProgramAdjacent: onProgramAdjacent.toString(),\n        onProgramSeparated: onProgramSeparated.toString(),\n      },\n      customWhiskerLengths: {\n        top: 0.2,\n        right: 0.2,\n        bottom: 0.2,\n        left: 0.2\n      }\n    }\n  } );\n  \n  // PROJECTOR CODE //\n  // Get a canvas object for this paper to draw something to the Projector.\n  const canvas = await paper.get('canvas');\n\n  // Draw the name of the program to the projector\n  const ctx = canvas.getContext('2d');\n  ctx.font = '20px sans-serif';\n  ctx.textAlign = 'center';\n  ctx.fillStyle = 'rgb(255,0,0)';\n  ctx.fillText('', canvas.width / 2, canvas.height / 2 - 10);\n  ctx.fillStyle = 'rgb(0,255,0)';\n  ctx.font = '10px sans-serif';\n  ctx.fillText('Game Logic', canvas.width / 2, canvas.height / 2 + 20);\n})();\n",
  "printed": false,
  "editorInfo": {},
  "currentCodeUrl": "program.creator-games.1.js",
  "currentCodeHash": "",
  "debugUrl": "/api/spaces/creator-games/programs/1/debugInfo",
  "claimUrl": "/api/spaces/creator-games/programs/1/claim",
  "codeHasChanged": false,
  "debugInfo": "{\"logs\":[]}"
}