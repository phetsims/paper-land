{
  "programs": [
    {
      "number": 183,
      "title": "x Squared Tiles A",
      "keywords": "TacTiles, algebra, voicing, x^2, x, squared, x-squared",
      "description": "A program that voices the number of x-squared tiles (the coefficient of x-squared) and increments and decrements the coefficient using markers.  Note that current model range is 0-9, voicing strings range from x squared to 10x^2.",
      "expanded": false,
      "topWhiskerLength": 0.05,
      "rightWhiskerLength": 0.05,
      "bottomWhiskerLength": 0.05,
      "leftWhiskerLength": 0.05,
      "positionProperty": {
        "x": 587.2012216739748,
        "y": 437
      },
      "modelContainer": {
        "namedBooleanProperties": [
          {
            "name": "BooleanOnLeftSideForXSquared_A",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          },
          {
            "name": "BooleanNegativeForXSquared_A",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          }
        ],
        "namedVector2Properties": [
          {
            "name": "PositionForXSquaredTiles_A",
            "propertyType": "Vector2Property",
            "defaultX": 0,
            "defaultY": 0
          }
        ],
        "namedNumberProperties": [
          {
            "name": "NumberXSquaredCoefficient_A",
            "propertyType": "NumberProperty",
            "min": "0",
            "max": "9",
            "defaultValue": "0"
          },
          {
            "name": "TermForXSquaredTile_A",
            "propertyType": "NumberProperty",
            "min": 0,
            "max": "2",
            "defaultValue": "2"
          }
        ],
        "namedEnumerationProperties": [],
        "namedDerivedProperties": [],
        "namedBounds2Properties": [],
        "namedObservableArrays": [],
        "namedArrayItems": [
          {
            "name": "xSquaredTileData_A",
            "arrayName": "tileData",
            "itemSchema": [
              {
                "entryName": "negative",
                "componentName": "BooleanNegativeForXSquared_A"
              },
              {
                "entryName": "onLeftSide",
                "componentName": "BooleanOnLeftSideForXSquared_A"
              },
              {
                "entryName": "count",
                "componentName": "NumberXSquaredCoefficient_A"
              },
              {
                "entryName": "term",
                "componentName": "TermForXSquaredTile_A"
              }
            ]
          }
        ],
        "namedArrayItemReferences": [],
        "namedStringProperties": []
      },
      "controllerContainer": {
        "vector2PropertyControllers": [
          {
            "name": "ControllerPositionForXSquared_A",
            "controlledComponentName": "PositionForXSquaredTiles_A",
            "controlType": "MATCH_CENTER",
            "controlTypeFamily": ""
          }
        ],
        "boundsPropertyControllers": [],
        "booleanPropertyControllers": [
          {
            "name": "ControllerBooleanNegativeForXSquared_A",
            "controlledComponentName": "BooleanNegativeForXSquared_A",
            "controlType": "ROTATION",
            "controlTypeFamily": "",
            "whiskerConfiguration": {
              "topLength": 0.2,
              "rightLength": 0.2,
              "bottomLength": 0.2,
              "leftLength": 0.2,
              "otherPaperNumber": null
            },
            "markerColor": ""
          }
        ],
        "numberPropertyControllers": [
          {
            "name": "ControllerXSquareCoefficient_A",
            "controlledComponentName": "NumberXSquaredCoefficient_A",
            "controlType": "MARKER_COUNT",
            "controlTypeFamily": "MARKERS",
            "markerColor": "all",
            "relationshipControlType": null
          }
        ],
        "enumerationPropertyControllers": []
      },
      "viewContainer": {
        "soundViews": [],
        "speechViews": [
          {
            "name": "ViewNumberOfXSquared_A",
            "modelComponentNames": [
              "BooleanNegativeForXSquared_A",
              "NumberXSquaredCoefficient_A"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "// A paper with no markers represent a potential stack of tiles\n// Adding or removing markers increments or decrements\n// the number of tiles of that type\nphet.paperLand.console.log(NumberXSquaredCoefficient_A);\nif (Math.floor(NumberXSquaredCoefficient_A) !== 0) {\n   // Test for negative tile value\n   if (BooleanNegativeForXSquared_A) {\n       speak( -Math.floor(NumberXSquaredCoefficient_A) + 'x squared' );\n   }\n   // else assume positive value\n   else {\n       speak( Math.floor(NumberXSquaredCoefficient_A) + 'x squared' );\n   }\n}",
            "lazyLink": false
          }
        ],
        "textViews": [
          {
            "name": "ViewTextTilesForXSquared_A",
            "modelComponentNames": [
              "BooleanNegativeForXSquared_A",
              "PositionForXSquaredTiles_A",
              "NumberXSquaredCoefficient_A"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "if ( BooleanNegativeForXSquared_A )  {\n    if ( NumberXSquaredCoefficient_A === 0 ) {\n        setString('Add negative X Squared tiles.'); // empty tile\n    }\n    else {\n        setString('] ' + (-NumberXSquaredCoefficient_A) +  'x^2 [');\n    }\n}\nelse {\n    if ( NumberXSquaredCoefficient_A === 0 ) {\n        setString('Add X Squared tiles.'); // empty tile\n    }\n    else {\n        if (NumberXSquaredCoefficient_A === 1) {\n            setString('[ x^2 ]');\n        }\n        else {\n            setString('[ ' + (NumberXSquaredCoefficient_A) + 'x^2 ]');\n        }\n    }\n}\nsetFontSize(20);\nsetCenterX( phet.paperLand.utils.paperToBoardX( PositionForXSquaredTiles_A.x, sharedData.displaySize.width ))\nsetCenterY( phet.paperLand.utils.paperToBoardY( PositionForXSquaredTiles_A.y, sharedData.displaySize.height ))",
            "lazyLink": false,
            "defaultViewOptions": {
              "centerX": 0.5,
              "centerY": 0.5,
              "scale": 1,
              "rotation": 0,
              "opacity": 1,
              "visible": true,
              "viewUnits": "model"
            }
          }
        ],
        "shapeViews": [
          {
            "name": "XSquaredTilesShape_A",
            "modelComponentNames": [],
            "referenceComponentNames": [],
            "controlFunctionString": "// Set the square to the desired size\n const rectangleHeight = 0.36\n const rectangleWidth = 0.36\n\nsetRectBounds( new phet.dot.Bounds2( 0, 0, rectangleWidth, rectangleHeight * sharedData.displaySize.width / sharedData.displaySize.height ) );\n\nsetVisible(Math.floor(NumberXSquaredCoefficient_A) !== 0)\nif (BooleanNegativeForXSquared_A) {\n    // If negative make a frame tile\n    // setRectBounds( new phet.dot.Bounds2( 0, 0, squareWidth, squareWidth * sharedData.displaySize.width / sharedData.displaySize.height ) );\n    setStroke('#ff0000'); // red\n    setFill('transparent');\t\t// fill\n    setLineWidth(4); // pixels\n}\nelse {\n    // Else assume positive and make a tile: stroke, fill\n    // setRectBounds( new phet.dot.Bounds2( 0, 0, squareWidth, squareWidth * sharedData.displaySize.width / sharedData.displaySize.height ) );\n    setStroke('#ff0000');\t// red\n    setLineWidth(4);\t\t// pixels\n    setFill('#ff0000');\t\t// fill\n    setOpacity( 0.6 );      // make tile transparent\n    // moveToFront();\t\t\t// keep in background behind any text\n}\n\nsetCenterX(PositionForXSquaredTiles_A.x);\nsetCenterY(PositionForXSquaredTiles_A.y);\n",
            "lazyLink": false,
            "defaultViewOptions": {
              "centerX": 0.5,
              "centerY": 0.5,
              "scale": 1,
              "rotation": 0,
              "opacity": 1,
              "visible": true,
              "viewUnits": "model"
            },
            "defaultShapeOptions": {
              "shapeType": "rectangle",
              "fill": "lightblue",
              "stroke": "red",
              "lineWidth": 1,
              "rectWidth": 0.5,
              "rectHeight": 0.5,
              "circleRadius": 0.05,
              "ellipseRadiusX": 0.3,
              "ellipseRadiusY": 0.15,
              "lineStartX": 0,
              "lineStartY": 0,
              "lineEndX": 0.3,
              "lineEndY": 0.3,
              "triangleBaseWidth": 0.1,
              "triangleHeight": 0.3,
              "polygonPoints": [
                [
                  0,
                  0
                ],
                [
                  0.1,
                  0
                ],
                [
                  0.1,
                  0.1
                ],
                [
                  0,
                  0.1
                ]
              ]
            }
          }
        ],
        "backgroundViews": [],
        "imageViews": []
      },
      "listenerContainer": {
        "linkListeners": [
          {
            "name": "ControllerBooleanLeftSideForXSquared_A",
            "controlledPropertyNames": [
              "BooleanOnLeftSideForXSquared_A"
            ],
            "controlFunctionString": "setBooleanOnLeftSideForXSquared_A(BoundsLeftSideOfEquals.containsPoint( PositionForXSquaredTiles_A )); \n",
            "dependencyNames": [
              "PositionForXSquaredTiles_A",
              "BoundsLeftSideOfEquals"
            ],
            "referenceComponentNames": []
          }
        ],
        "animationListeners": [],
        "bluetoothListeners": []
      },
      "customCodeContainer": {
        "onProgramAddedCode": "// Setting program data to the program for some sound design.\r\nphet.paperLand.setProgramData( paperNumber, 'term', 'xSquared' );\r\n\r\n// Using addModelObserver lets us add the tiles/bounds programs in any order\r\nscratchpad.observerId = phet.paperLand.addModelObserver(\r\n  'tileData', // the bounds program will create this array when it is added\r\n  tileData => {\r\n\r\n    // as soon as the array is available, add this tile to it\r\n    scratchpad.thisTileData = {\r\n      onLeftSideProperty: phet.paperLand.getModelComponent( 'BooleanOnLeftSideForXSquared_A' ),\r\n      negativeProperty: phet.paperLand.getModelComponent( 'BooleanNegativeForXSquared_A' ),\r\n      countProperty: phet.paperLand.getModelComponent( 'NumberXSquaredCoefficient_A' ),\r\n      term: 'xSquared'\r\n    }\r\n    tileData.push( scratchpad.thisTileData );\r\n  },\r\n  tileData => {\r\n\r\n    // Remove this tile from the array when the array is being removed\r\n    const index = tileData.indexOf( scratchpad.thisTileData );\r\n    if ( index > -1 ) {\r\n        tileData.splice( index, 1 );\r\n        delete scratchpad.tileData;\r\n    }\r\n  }\r\n);",
        "onProgramRemovedCode": "// Removes the term data from the model\r\nphet.paperLand.removeProgramData( paperNumber, 'term' );\r\n\r\nconst tileData = phet.paperLand.getModelComponent( 'tileData' );\r\nif ( tileData ) {\r\n\r\n    // Remove the tile from the array\r\n    const index = tileData.indexOf( scratchpad.thisTileData );\r\n    if ( index > -1 ) {\r\n        tileData.splice( index, 1 );\r\n        delete scratchpad.tileData;        \r\n    }\r\n}\r\n\r\n// remove the model observer\r\nphet.paperLand.removeModelObserver( 'tileData', scratchpad.observerId );\r\ndelete scratchpad.observerId;",
        "onProgramChangedPositionCode": "",
        "onProgramMarkersAddedCode": "",
        "onProgramMarkersRemovedCode": "",
        "onProgramMarkersChangedPositionCode": "",
        "onProgramAdjacentCode": "",
        "onProgramSeparatedCode": ""
      }
    },
    {
      "number": 983,
      "title": "X Tiles A",
      "keywords": "NumberXCoefficient",
      "description": "A program that voices the number of x-tiles (the coefficient of x) and increments and decrements the coefficient using markers.  Note that current model range for the coefficient is 0-9, voicing strings range from x to 10x.",
      "expanded": false,
      "topWhiskerLength": 0.05,
      "rightWhiskerLength": 0.05,
      "bottomWhiskerLength": 0.05,
      "leftWhiskerLength": 0.05,
      "positionProperty": {
        "x": 589.9807779890396,
        "y": 373
      },
      "modelContainer": {
        "namedBooleanProperties": [
          {
            "name": "BooleanOnLeftSideForX_A",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          },
          {
            "name": "BooleanNegativeForX_A",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          },
          {
            "name": "BooleanGoodConnectionForX_A",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          },
          {
            "name": "BooleanBadConnectionForX_A",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          }
        ],
        "namedVector2Properties": [
          {
            "name": "PositionForXTiles_A",
            "propertyType": "Vector2Property",
            "defaultX": 0,
            "defaultY": 0
          }
        ],
        "namedNumberProperties": [
          {
            "name": "NumberXCoefficient_A",
            "propertyType": "NumberProperty",
            "min": 0,
            "max": "9",
            "defaultValue": "0"
          },
          {
            "name": "TermForXTile_A",
            "propertyType": "NumberProperty",
            "min": 0,
            "max": "2",
            "defaultValue": "1"
          }
        ],
        "namedEnumerationProperties": [],
        "namedDerivedProperties": [],
        "namedBounds2Properties": [],
        "namedObservableArrays": [],
        "namedArrayItems": [
          {
            "name": "xTileData_A",
            "arrayName": "tileData",
            "itemSchema": [
              {
                "entryName": "negative",
                "componentName": "BooleanNegativeForX_A"
              },
              {
                "entryName": "onLeftSide",
                "componentName": "BooleanOnLeftSideForX_A"
              },
              {
                "entryName": "count",
                "componentName": "NumberXCoefficient_A"
              },
              {
                "entryName": "term",
                "componentName": "TermForXTile_A"
              }
            ]
          }
        ],
        "namedArrayItemReferences": [],
        "namedStringProperties": []
      },
      "controllerContainer": {
        "vector2PropertyControllers": [
          {
            "name": "ControllerPositionForX_A",
            "controlledComponentName": "PositionForXTiles_A",
            "controlType": "MATCH_CENTER",
            "controlTypeFamily": ""
          }
        ],
        "boundsPropertyControllers": [],
        "booleanPropertyControllers": [
          {
            "name": "ControllerBooleanNegativeForX_A",
            "controlledComponentName": "BooleanNegativeForX_A",
            "controlType": "ROTATION",
            "controlTypeFamily": "",
            "whiskerConfiguration": {
              "topLength": 0.2,
              "rightLength": 0.2,
              "bottomLength": 0.2,
              "leftLength": 0.2,
              "otherPaperNumber": null
            },
            "markerColor": ""
          }
        ],
        "numberPropertyControllers": [
          {
            "name": "ControllerXCoefficient_A",
            "controlledComponentName": "NumberXCoefficient_A",
            "controlType": "MARKER_COUNT",
            "controlTypeFamily": "MARKERS",
            "markerColor": "all",
            "relationshipControlType": null
          }
        ],
        "enumerationPropertyControllers": []
      },
      "viewContainer": {
        "soundViews": [
          {
            "name": "ViewGoodConnectionSoundForX_A",
            "modelComponentNames": [
              "BooleanGoodConnectionForX_A",
              "RectangleModelMode"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "if ( BooleanGoodConnectionForX_A && RectangleModelMode ) {\r\n    play();\r\n}",
            "lazyLink": false,
            "soundFileName": "/uploads/SuccessSound.mp3",
            "loop": false,
            "autoplay": false
          },
          {
            "name": "ViewBadConnectionSoundForX_A",
            "modelComponentNames": [
              "BooleanBadConnectionForX_A",
              "RectangleModelMode"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "if ( BooleanBadConnectionForX_A && RectangleModelMode ) {\n    play();\n}",
            "lazyLink": false,
            "soundFileName": "/uploads/OutOfBalanceSound.mp3",
            "loop": false,
            "autoplay": false
          }
        ],
        "speechViews": [
          {
            "name": "ViewNumberOfX_A",
            "modelComponentNames": [
              "BooleanNegativeForX_A",
              "NumberXCoefficient_A"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "// A paper with no markers represent a potential stack of tiles\n// Adding or removing markers increments or decrements\n// the number of tiles of that type\nphet.paperLand.console.log(NumberXCoefficient_A);\nif (Math.floor(NumberXCoefficient_A) !== 0) {\n   // Test for negative tile value\n   if (BooleanNegativeForX_A) {\n       speak( -Math.floor(NumberXCoefficient_A) + 'x' );\n   }\n   // else assume positive value\n   else {\n       speak( Math.floor(NumberXCoefficient_A) + 'x' );\n   }\n}\n",
            "lazyLink": false
          }
        ],
        "textViews": [
          {
            "name": "ViewTextTilesForXTiles_A",
            "modelComponentNames": [
              "BooleanNegativeForX_A",
              "PositionForXTiles_A",
              "NumberXCoefficient_A"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "if ( BooleanNegativeForX_A )  {\n    if ( NumberXCoefficient_A === 0 ) {\n        setString('Add negative X-tiles.'); // empty tile\n    }\n    else {\n        setString('] ' + (-NumberXCoefficient_A) +  'x [');\n    }\n}\nelse {\n    if ( NumberXCoefficient_A === 0 ) {\n        setString('Add X-tiles.'); // empty tile\n    }\n    else {\n        if (NumberXCoefficient_A === 1) {\n            setString('[ x ]');\n        }\n        else {\n            setString('[ ' + (NumberXCoefficient_A) + 'x ]');\n        }\n    }\n}\nsetFontSize(20);\nsetCenterX( phet.paperLand.utils.paperToBoardX( PositionForXTiles_A.x, sharedData.displaySize.width ))\nsetCenterY( phet.paperLand.utils.paperToBoardY( PositionForXTiles_A.y, sharedData.displaySize.height ))",
            "lazyLink": false,
            "defaultViewOptions": {
              "centerX": 0.5,
              "centerY": 0.5,
              "scale": 1,
              "rotation": 0,
              "opacity": 1,
              "visible": true,
              "viewUnits": "model"
            }
          }
        ],
        "shapeViews": [
          {
            "name": "XTilesShape_A",
            "modelComponentNames": [
              "BooleanOnLeftSideForX_A",
              "BooleanNegativeForX_A",
              "PositionForXTiles_A",
              "NumberXCoefficient_A"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "// Set the square to the desired size\n const rectangleHeight = 0.36\n const rectangleWidth = 0.1\n\nsetRectBounds( new phet.dot.Bounds2( 0, 0, rectangleWidth, rectangleHeight * sharedData.displaySize.width / sharedData.displaySize.height ) );\n\nsetVisible(Math.floor(NumberXCoefficient_A) !== 0)\nif (BooleanNegativeForX_A) {\n    // If negative make a frame tile\n    // setRectBounds( new phet.dot.Bounds2( 0, 0, squareWidth, squareWidth * sharedData.displaySize.width / sharedData.displaySize.height ) );\n    setStroke('#ff0000'); // red\n    setFill('transparent');\t\t// fill\n    setLineWidth(4); // pixels\n}\nelse {\n    // Else assume positive and make a tile: stroke, fill\n    // setRectBounds( new phet.dot.Bounds2( 0, 0, squareWidth, squareWidth * sharedData.displaySize.width / sharedData.displaySize.height ) );\n    setStroke('#ff0000');\t// red\n    setLineWidth(4);\t\t// pixels\n    setFill('#ff0000');\t\t// fill\n    setOpacity( 0.6 );      // make tile transparent\n    // moveToFront();\t\t\t// keep in background behind any text\n}\n\nsetCenterX(PositionForXTiles_A.x);\nsetCenterY(PositionForXTiles_A.y);\n",
            "lazyLink": false,
            "defaultViewOptions": {
              "centerX": 0.5,
              "centerY": 0.5,
              "scale": 1,
              "rotation": 0,
              "opacity": 1,
              "visible": true,
              "viewUnits": "model"
            },
            "defaultShapeOptions": {
              "shapeType": "rectangle",
              "fill": "lightblue",
              "stroke": "red",
              "lineWidth": 1,
              "rectWidth": 0.5,
              "rectHeight": 0.5,
              "circleRadius": 0.05,
              "ellipseRadiusX": 0.3,
              "ellipseRadiusY": 0.15,
              "lineStartX": 0,
              "lineStartY": 0,
              "lineEndX": 0.3,
              "lineEndY": 0.3,
              "triangleBaseWidth": 0.1,
              "triangleHeight": 0.3,
              "polygonPoints": [
                [
                  0,
                  0
                ],
                [
                  0.1,
                  0
                ],
                [
                  0.1,
                  0.1
                ],
                [
                  0,
                  0.1
                ]
              ]
            }
          }
        ],
        "backgroundViews": [],
        "imageViews": []
      },
      "listenerContainer": {
        "linkListeners": [
          {
            "name": "ControllerBooleanLeftSideForX_A",
            "controlledPropertyNames": [
              "BooleanOnLeftSideForX_A"
            ],
            "controlFunctionString": "// Uncomment to voice side of equation - What does this comment mean?\nsetBooleanOnLeftSideForX_A(BoundsLeftSideOfEquals.containsPoint( PositionForXTiles_A )); \n\n",
            "dependencyNames": [
              "PositionForXTiles_A",
              "BoundsLeftSideOfEquals"
            ],
            "referenceComponentNames": []
          }
        ],
        "animationListeners": [],
        "bluetoothListeners": []
      },
      "customCodeContainer": {
        "onProgramAddedCode": "// Setting program data to the program for some sound design.\r\nphet.paperLand.setProgramData( paperNumber, 'term', 'x' );\r\n\r\n",
        "onProgramRemovedCode": "// Removes the term data from the model\r\nphet.paperLand.removeProgramData( paperNumber, 'term' );\r\n\r\n",
        "onProgramChangedPositionCode": "",
        "onProgramMarkersAddedCode": "",
        "onProgramMarkersRemovedCode": "",
        "onProgramMarkersChangedPositionCode": "",
        "onProgramAdjacentCode": "\n// Get a reference to the model component and only update it if it exists.\nconst goodConnectionComponent = phet.paperLand.getModelComponent( 'BooleanGoodConnectionForX_A' );\nconst badConnectionComponent = phet.paperLand.getModelComponent( 'BooleanBadConnectionForX_A' );\n\n\nif ( goodConnectionComponent && badConnectionComponent ) {\n\n    // If this is the left or right whisker...\n    if ( direction === 'left' || direction === 'right' ) {\n\n        // These are the terms that this program is allowed to connect to.\n        const goodConnectionTerms = [ 'xSquared' ];\n       \n        // These are the terms that this program is NOT allowed to connect to.\n        const badConnectionTerms = [ 'ones' ];\n\n        // This connection is \"good\" if the other program has a term in the good list\n        goodConnectionComponent.value = goodConnectionTerms.includes(\n\n            // get the term from the other program\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\n        );\n        // This connection is \"bad\" if the other program has a term in the bad list\n        badConnectionComponent.value = badConnectionTerms.includes(\n\n            // get the term from the other program\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\n        );\n    }\n\n    phet.paperLand.console.log( direction );\n\n    // If this is the top or bottom whisker...\n    if ( direction === 'top' || direction === 'bottom' ) {\n        \n        // These are the terms that this program is allowed to connect to.\n        const goodConnectionTerms = [ 'ones' ];\n       \n        // These are the terms that this program is NOT allowed to connect to.\n        const badConnectionTerms = [ 'xSquared' ];\n\n        // This connection is \"good\" if the other program has a term in the good list\n        goodConnectionComponent.value = goodConnectionTerms.includes(\n\n            // get the term from the other program\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\n        );\n        // This connection is \"bad\" if the other program has a term in the bad list\n        badConnectionComponent.value = badConnectionTerms.includes(\n\n            // get the term from the other program\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\n        );\n    }\n}",
        "onProgramSeparatedCode": "\r\n// Get a reference to the model component and only update it if it exists.\r\nconst goodConnectionComponent = phet.paperLand.getModelComponent( 'BooleanGoodConnectionForX_A' );\r\nconst badConnectionComponent = phet.paperLand.getModelComponent( 'BooleanBadConnectionForX_A' );\r\n\r\n// Components must exit check\r\nif ( goodConnectionComponent && badConnectionComponent )  {\r\n\r\n    // If this is the left or right whisker...\r\n    if ( direction === 'left' || direction === 'right' ) {\r\n\r\n        // These are the terms that this program is allowed to connect to.\r\n        const goodConnectionTerms = [ 'xSquared' ];\r\n\r\n         // These are the terms that this program is NOT allowed to connect to.\r\n        const badConnectionTerms = [ 'ones' ];\r\n\r\n        // If detatching from another program where connection is \"good\",\r\n        // the connection is no longer there.\r\n        if ( goodConnectionTerms.includes(\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        ) ) {\r\n            goodConnectionComponent.value = false;\r\n        }\r\n        // If detatching from another program where connection is \"bad\",\r\n        // the connection is no longer there.\r\n        if ( badConnectionTerms.includes(\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        ) ) {\r\n            badConnectionComponent.value = false;\r\n        }\r\n    }\r\n\r\n    // If this is the top or bottom whisker...\r\n    if ( direction === 'top' || direction === 'bottom' ) {\r\n\r\n       // These are the terms that this program is allowed to connect to.\r\n       // TODO: Need to add top and bottom of X tiles\r\n        const goodConnectionTerms = [ 'ones' ];\r\n\r\n         // These are the terms that this program is NOT allowed to connect to.\r\n        // TODO: Need to add left and right of X tiles\r\n        const badConnectionTerms = [ 'xSquared' ];\r\n\r\n        // If detatching from another program where connection is \"good\",\r\n        // the connection is no longer there.\r\n        if ( goodConnectionTerms.includes(\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        ) ) {\r\n            goodConnectionComponent.value = false;\r\n        }\r\n        // If detatching from another program where connection is \"bad\",\r\n        // the connection is no longer there.\r\n        if ( badConnectionTerms.includes(\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        ) ) {\r\n            badConnectionComponent.value = false;\r\n        }\r\n    }\r\n}"
      }
    },
    {
      "number": 802,
      "title": "Equation Bounds TacTiles",
      "keywords": "TactTiles, algebra, voicing, balanced equations",
      "description": "A program that defines the bounds of an algebraic equation, so that the other programs representing tiles can be placed on the left and right sides of the camera's view and which can be interpreted as being on the left and right sides an the equal sign. ",
      "expanded": true,
      "topWhiskerLength": 0.2,
      "rightWhiskerLength": 0.2,
      "bottomWhiskerLength": 0.2,
      "leftWhiskerLength": 0.2,
      "positionProperty": {
        "x": 267.90000915527344,
        "y": 144.53718349343393
      },
      "modelContainer": {
        "namedBooleanProperties": [],
        "namedVector2Properties": [
          {
            "name": "BoundsPositionModel",
            "propertyType": "Vector2Property",
            "defaultX": 0,
            "defaultY": 0
          }
        ],
        "namedNumberProperties": [
          {
            "name": "BoundsRotationModel",
            "propertyType": "NumberProperty",
            "min": 0,
            "max": 10,
            "defaultValue": 5
          }
        ],
        "namedEnumerationProperties": [],
        "namedDerivedProperties": [
          {
            "name": "tileDataLength",
            "propertyType": "DerivedProperty",
            "dependencyNames": [
              "tileData"
            ],
            "derivation": "return tileData.length;"
          }
        ],
        "namedBounds2Properties": [
          {
            "name": "BoundsLeftSideOfEquals",
            "propertyType": "Bounds2Property",
            "defaultMinX": 0,
            "defaultMinY": "0.1",
            "defaultMaxX": "0.5",
            "defaultMaxY": 1
          },
          {
            "name": "BoundsRightSideOfEquals",
            "propertyType": "Bounds2Property",
            "defaultMinX": "0.5",
            "defaultMinY": "0.1",
            "defaultMaxX": "1",
            "defaultMaxY": 1
          }
        ],
        "namedObservableArrays": [
          {
            "name": "tileData",
            "propertyType": "ObservableArray",
            "lengthComponentName": "tileDataArrayLength",
            "arrayAddedItemReferenceName": "tileDataAddedItem",
            "arrayRemovedItemReferenceName": "tileDataRemovedItem"
          }
        ],
        "namedArrayItems": [],
        "namedArrayItemReferences": [
          {
            "name": "tileDataAddedItem"
          },
          {
            "name": "tileDataRemovedItem"
          }
        ],
        "namedStringProperties": []
      },
      "controllerContainer": {
        "vector2PropertyControllers": [
          {
            "name": "ControllerBoundsPosition",
            "controlledComponentName": "BoundsPositionModel",
            "controlType": "MATCH_CENTER",
            "controlTypeFamily": ""
          }
        ],
        "boundsPropertyControllers": [],
        "booleanPropertyControllers": [],
        "numberPropertyControllers": [
          {
            "name": "ControllerBoundsRotationVoicer",
            "controlledComponentName": "BoundsRotationModel",
            "controlType": "ROTATION",
            "controlTypeFamily": "PAPER_MOVEMENT",
            "markerColor": "all",
            "relationshipControlType": "LINEAR"
          }
        ],
        "enumerationPropertyControllers": []
      },
      "viewContainer": {
        "soundViews": [],
        "speechViews": [
          {
            "name": "ViewVoiceBoundsRotation",
            "modelComponentNames": [
              "BoundsRotationModel"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "// tileData is created in custom code for this program so we know it exists\nconst tileData = phet.paperLand.getModelComponent( 'tileData' ).value;\n\nif ( BoundsRotationModel >= 1 && BoundsRotationModel <= 4 ) {\n\n    // find all of the entries of tile data that are on the left side\n    const rightTiles = tileData.filter( data => !data.onLeftSide );\n    speak( scratchpad.getTermDescriptionForSide( rightTiles, 'right' ) );\n\n} else if ( BoundsRotationModel >= 6 && BoundsRotationModel <= 9 ) {\n\n    // find all of the entries of tile data that are on the left side\n    const leftTiles = tileData.filter( data => data.onLeftSide );\n    speak( scratchpad.getTermDescriptionForSide( leftTiles, 'left' ) );\n}\n\n\n\n\n\n\n\n\n\n",
            "lazyLink": false
          }
        ],
        "textViews": [],
        "shapeViews": [
          {
            "name": "ViewLeftBackground",
            "modelComponentNames": [
              "BoundsLeftSideOfEquals"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "setRectBounds(BoundsLeftSideOfEquals);",
            "lazyLink": false,
            "defaultViewOptions": {
              "centerX": null,
              "centerY": null,
              "scale": 1,
              "rotation": 0,
              "opacity": "0.5",
              "visible": true,
              "viewUnits": "model"
            },
            "defaultShapeOptions": {
              "shapeType": "rectangle",
              "fill": "#007BFF",
              "stroke": "#000000",
              "lineWidth": 1,
              "rectWidth": 100,
              "rectHeight": 50,
              "circleRadius": 50,
              "ellipseRadiusX": 100,
              "ellipseRadiusY": 50,
              "lineStartX": 0,
              "lineStartY": 0,
              "lineEndX": 100,
              "lineEndY": 100,
              "triangleBaseWidth": 100,
              "triangleHeight": 100,
              "polygonPoints": [
                [
                  0,
                  0
                ],
                [
                  100,
                  0
                ],
                [
                  100,
                  100
                ],
                [
                  0,
                  100
                ]
              ]
            }
          },
          {
            "name": "ViewRightBackground",
            "modelComponentNames": [
              "BoundsRightSideOfEquals"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "setRectBounds(BoundsRightSideOfEquals);",
            "lazyLink": false,
            "defaultViewOptions": {
              "centerX": null,
              "centerY": null,
              "scale": 1,
              "rotation": 0,
              "opacity": "0.5",
              "visible": true,
              "viewUnits": "model"
            },
            "defaultShapeOptions": {
              "shapeType": "rectangle",
              "fill": "#87CEEB",
              "stroke": "#000000",
              "lineWidth": 1,
              "rectWidth": 100,
              "rectHeight": 50,
              "circleRadius": 50,
              "ellipseRadiusX": 100,
              "ellipseRadiusY": 50,
              "lineStartX": 0,
              "lineStartY": 0,
              "lineEndX": 100,
              "lineEndY": 100,
              "triangleBaseWidth": 100,
              "triangleHeight": 100,
              "polygonPoints": [
                [
                  0,
                  0
                ],
                [
                  100,
                  0
                ],
                [
                  100,
                  100
                ],
                [
                  0,
                  100
                ]
              ]
            }
          }
        ],
        "backgroundViews": [],
        "imageViews": []
      },
      "listenerContainer": {
        "linkListeners": [],
        "animationListeners": [],
        "bluetoothListeners": []
      },
      "customCodeContainer": {
        "onProgramAddedCode": "// A function to generate a description for a particular side.\r\nscratchpad.getTermDescriptionForSide = ( tileData, leftOrRightString ) => {\r\n    const xSquaredTiles = tileData.filter( data => data.term === 2 );   //xSquared\r\n    const xTiles = tileData.filter( data => data.term === 1 );         // x\r\n    const onesTiles = tileData.filter( data => data.term === 0 );      // one\r\n\r\n    let description= '';\r\n\r\n    const handleTile = ( tile, term ) => {\r\n        if ( tile.negative && tile.count !== 0 ) {\r\n\r\n            // always describe if it is a negative operation\r\n            description += 'minus';\r\n        }\r\n        else if ( description.length > 0 && tile.count !== 0 ) {\r\n\r\n            // if there are terms before this one, include the operation\r\n            description += 'plus';\r\n        }\r\n        if ( tile.count > 0 ) {\r\n\r\n            // if we include the 'one' description OR there are more than one\r\n            // in the count, include the number\r\n            description += ` ${tile.count}`; // ${tile.count + 1}`\r\n        }\r\n        description += `${term}`; \r\n    }\r\n\r\n    xSquaredTiles.forEach( tile => handleTile( tile, 'x squared' ) );\r\n    xTiles.forEach( tile => handleTile( tile, 'x' ) );\r\n    onesTiles.forEach( tile => handleTile( tile, '' ) );\r\n\r\n    if ( description ) {\r\n        return description + leftOrRightString + ' of equals.';\r\n    }\r\n    else {\r\n        return 'No tiles ' + leftOrRightString + ' of equals.';\r\n    }\r\n};\r\n",
        "onProgramRemovedCode": "",
        "onProgramChangedPositionCode": "",
        "onProgramMarkersAddedCode": "",
        "onProgramMarkersRemovedCode": "",
        "onProgramMarkersChangedPositionCode": "",
        "onProgramAdjacentCode": "",
        "onProgramSeparatedCode": ""
      }
    },
    {
      "number": 1413,
      "title": "Equation01",
      "keywords": "TacTiles, equation, example, simple",
      "description": "Program to print and voice equation 1 at top of display.",
      "expanded": false,
      "topWhiskerLength": 0.2,
      "rightWhiskerLength": 0.2,
      "bottomWhiskerLength": 0.2,
      "leftWhiskerLength": 0.2,
      "positionProperty": {
        "x": 11.380661231884062,
        "y": 139.0299145567507
      },
      "modelContainer": {
        "namedBooleanProperties": [
          {
            "name": "BooleanIsRotatedEquation01",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          }
        ],
        "namedVector2Properties": [
          {
            "name": "Equation01Position",
            "propertyType": "Vector2Property",
            "defaultX": "0.5",
            "defaultY": "0.05"
          }
        ],
        "namedNumberProperties": [],
        "namedEnumerationProperties": [],
        "namedDerivedProperties": [],
        "namedBounds2Properties": [],
        "namedObservableArrays": [],
        "namedArrayItems": [],
        "namedArrayItemReferences": [],
        "namedStringProperties": []
      },
      "controllerContainer": {
        "vector2PropertyControllers": [],
        "boundsPropertyControllers": [],
        "booleanPropertyControllers": [
          {
            "name": "ControllerReVoiceEquation01",
            "controlledComponentName": "BooleanIsRotatedEquation01",
            "controlType": "ROTATION",
            "controlTypeFamily": "",
            "whiskerConfiguration": {
              "topLength": 0.2,
              "rightLength": 0.2,
              "bottomLength": 0.2,
              "leftLength": 0.2,
              "otherPaperNumber": null
            },
            "markerColor": ""
          }
        ],
        "numberPropertyControllers": [],
        "enumerationPropertyControllers": []
      },
      "viewContainer": {
        "soundViews": [],
        "speechViews": [
          {
            "name": "ViewVoiceEquation01",
            "modelComponentNames": [
              "BooleanIsRotatedEquation01"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "// 3x  = 2x - 3\nspeak( \"3x equals 2x minus 3\" );",
            "lazyLink": false
          }
        ],
        "textViews": [
          {
            "name": "ViewTextEquation01",
            "modelComponentNames": [
              "Equation01Position"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "setString( '3x  = 2x - 3' );\nsetFontSize(40);\nsetFontFamily('serif');\nsetCenterX( phet.paperLand.utils.paperToBoardX( Equation01Position.x, sharedData.displaySize.width ));\nsetCenterY( phet.paperLand.utils.paperToBoardY( Equation01Position.y, sharedData.displaySize.height ));",
            "lazyLink": false,
            "defaultViewOptions": {
              "centerX": 0.5,
              "centerY": 0.5,
              "scale": 1,
              "rotation": 0,
              "opacity": 1,
              "visible": true,
              "viewUnits": "model"
            }
          }
        ],
        "shapeViews": [],
        "backgroundViews": [],
        "imageViews": []
      },
      "listenerContainer": {
        "linkListeners": [],
        "animationListeners": [],
        "bluetoothListeners": []
      },
      "customCodeContainer": {
        "onProgramAddedCode": "",
        "onProgramRemovedCode": "",
        "onProgramChangedPositionCode": "",
        "onProgramMarkersAddedCode": "",
        "onProgramMarkersRemovedCode": "",
        "onProgramMarkersChangedPositionCode": "",
        "onProgramAdjacentCode": "",
        "onProgramSeparatedCode": ""
      }
    },
    {
      "number": 1802,
      "title": "Rectangle Model",
      "keywords": "",
      "description": "Adding this program will enable connection sounds between tiles.",
      "expanded": false,
      "topWhiskerLength": 0.2,
      "rightWhiskerLength": 0.2,
      "bottomWhiskerLength": 0.2,
      "leftWhiskerLength": 0.2,
      "positionProperty": {
        "x": 11.59648220530147,
        "y": 300.25836697376184
      },
      "modelContainer": {
        "namedBooleanProperties": [
          {
            "name": "RectangleModelMode",
            "defaultValue": true,
            "propertyType": "BooleanProperty"
          }
        ],
        "namedVector2Properties": [],
        "namedNumberProperties": [],
        "namedEnumerationProperties": [],
        "namedDerivedProperties": [],
        "namedBounds2Properties": [],
        "namedObservableArrays": [],
        "namedArrayItems": [],
        "namedArrayItemReferences": [],
        "namedStringProperties": []
      },
      "controllerContainer": {
        "vector2PropertyControllers": [],
        "boundsPropertyControllers": [],
        "booleanPropertyControllers": [],
        "numberPropertyControllers": [],
        "enumerationPropertyControllers": []
      },
      "viewContainer": {
        "soundViews": [],
        "speechViews": [
          {
            "name": "ViewVoiceRectangleModelHelpText",
            "modelComponentNames": [
              "RectangleModelMode"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "return ( 'Make a rectangle with your tiles. Keep long sides on long sides and short sides on short sides.' );",
            "lazyLink": false
          }
        ],
        "textViews": [],
        "shapeViews": [],
        "backgroundViews": [],
        "imageViews": []
      },
      "listenerContainer": {
        "linkListeners": [],
        "animationListeners": [],
        "bluetoothListeners": []
      },
      "customCodeContainer": {
        "onProgramAddedCode": "",
        "onProgramRemovedCode": "",
        "onProgramChangedPositionCode": "",
        "onProgramMarkersAddedCode": "",
        "onProgramMarkersRemovedCode": "",
        "onProgramMarkersChangedPositionCode": "",
        "onProgramAdjacentCode": "",
        "onProgramSeparatedCode": ""
      }
    },
    {
      "number": 264,
      "title": "Equation02",
      "keywords": "TacTiles, equation, example, simple",
      "description": "Program to print and voice equation 1 at top of display.",
      "expanded": false,
      "topWhiskerLength": 0.2,
      "rightWhiskerLength": 0.2,
      "bottomWhiskerLength": 0.2,
      "leftWhiskerLength": 0.2,
      "positionProperty": {
        "x": 0.7087296195652186,
        "y": 183.73074721423984
      },
      "modelContainer": {
        "namedBooleanProperties": [
          {
            "name": "BooleanIsRotatedEquation02",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          }
        ],
        "namedVector2Properties": [
          {
            "name": "Equation02Position",
            "propertyType": "Vector2Property",
            "defaultX": "0.5",
            "defaultY": "0.05"
          }
        ],
        "namedNumberProperties": [],
        "namedEnumerationProperties": [],
        "namedDerivedProperties": [],
        "namedBounds2Properties": [],
        "namedObservableArrays": [],
        "namedArrayItems": [],
        "namedArrayItemReferences": [],
        "namedStringProperties": []
      },
      "controllerContainer": {
        "vector2PropertyControllers": [],
        "boundsPropertyControllers": [],
        "booleanPropertyControllers": [
          {
            "name": "ControllerReVoiceEquation02",
            "controlledComponentName": "BooleanIsRotatedEquation02",
            "controlType": "ROTATION",
            "controlTypeFamily": "",
            "whiskerConfiguration": {
              "topLength": 0.2,
              "rightLength": 0.2,
              "bottomLength": 0.2,
              "leftLength": 0.2,
              "otherPaperNumber": null
            },
            "markerColor": ""
          }
        ],
        "numberPropertyControllers": [],
        "enumerationPropertyControllers": []
      },
      "viewContainer": {
        "soundViews": [],
        "speechViews": [
          {
            "name": "ViewVoiceEquation02",
            "modelComponentNames": [
              "BooleanIsRotatedEquation02"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "// 3x  = 2x - 3\nspeak( \"3x^2 equals x^2 plus 8\" );",
            "lazyLink": false
          }
        ],
        "textViews": [
          {
            "name": "ViewTextEquation02",
            "modelComponentNames": [
              "Equation02Position"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "setString( '3x^2 = x^2 + 8' );\nsetFontSize(40);\nsetFontFamily('serif');\nsetCenterX( phet.paperLand.utils.paperToBoardX( Equation02Position.x, sharedData.displaySize.width ));\nsetCenterY( phet.paperLand.utils.paperToBoardY( Equation02Position.y, sharedData.displaySize.height ));",
            "lazyLink": false,
            "defaultViewOptions": {
              "centerX": 0.5,
              "centerY": 0.5,
              "scale": 1,
              "rotation": 0,
              "opacity": 1,
              "visible": true,
              "viewUnits": "model"
            }
          }
        ],
        "shapeViews": [],
        "backgroundViews": [],
        "imageViews": []
      },
      "listenerContainer": {
        "linkListeners": [],
        "animationListeners": [],
        "bluetoothListeners": []
      },
      "customCodeContainer": {
        "onProgramAddedCode": "",
        "onProgramRemovedCode": "",
        "onProgramChangedPositionCode": "",
        "onProgramMarkersAddedCode": "",
        "onProgramMarkersRemovedCode": "",
        "onProgramMarkersChangedPositionCode": "",
        "onProgramAdjacentCode": "",
        "onProgramSeparatedCode": ""
      }
    },
    {
      "number": 1394,
      "title": "Equation03",
      "keywords": "TacTiles, equation, example, simple",
      "description": "Program to print and voice equation 1 at top of display.",
      "expanded": false,
      "topWhiskerLength": 0.2,
      "rightWhiskerLength": 0.2,
      "bottomWhiskerLength": 0.2,
      "leftWhiskerLength": 0.2,
      "positionProperty": {
        "x": 2.23828125,
        "y": 221.89501113337553
      },
      "modelContainer": {
        "namedBooleanProperties": [
          {
            "name": "BooleanIsRotatedEquation03",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          }
        ],
        "namedVector2Properties": [
          {
            "name": "Equation03Position",
            "propertyType": "Vector2Property",
            "defaultX": "0.5",
            "defaultY": "0.05"
          }
        ],
        "namedNumberProperties": [],
        "namedEnumerationProperties": [],
        "namedDerivedProperties": [],
        "namedBounds2Properties": [],
        "namedObservableArrays": [],
        "namedArrayItems": [],
        "namedArrayItemReferences": [],
        "namedStringProperties": []
      },
      "controllerContainer": {
        "vector2PropertyControllers": [],
        "boundsPropertyControllers": [],
        "booleanPropertyControllers": [
          {
            "name": "ControllerReVoiceEquation03",
            "controlledComponentName": "BooleanIsRotatedEquation03",
            "controlType": "ROTATION",
            "controlTypeFamily": "",
            "whiskerConfiguration": {
              "topLength": 0.2,
              "rightLength": 0.2,
              "bottomLength": 0.2,
              "leftLength": 0.2,
              "otherPaperNumber": null
            },
            "markerColor": ""
          }
        ],
        "numberPropertyControllers": [],
        "enumerationPropertyControllers": []
      },
      "viewContainer": {
        "soundViews": [],
        "speechViews": [
          {
            "name": "ViewVoiceEquation03",
            "modelComponentNames": [
              "BooleanIsRotatedEquation03"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "// 3x  = 2x - 3\nspeak( \"2x plus 3 equals 7 \" );",
            "lazyLink": false
          }
        ],
        "textViews": [
          {
            "name": "ViewTextEquation03",
            "modelComponentNames": [
              "Equation03Position"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "setString( '2x + 3 = 7' );\nsetFontSize(40);\nsetFontFamily('serif');\nsetCenterX( phet.paperLand.utils.paperToBoardX( Equation03Position.x, sharedData.displaySize.width ));\nsetCenterY( phet.paperLand.utils.paperToBoardY( Equation03Position.y, sharedData.displaySize.height ));",
            "lazyLink": false,
            "defaultViewOptions": {
              "centerX": 0.5,
              "centerY": 0.5,
              "scale": 1,
              "rotation": 0,
              "opacity": 1,
              "visible": true,
              "viewUnits": "model"
            }
          }
        ],
        "shapeViews": [],
        "backgroundViews": [],
        "imageViews": []
      },
      "listenerContainer": {
        "linkListeners": [],
        "animationListeners": [],
        "bluetoothListeners": []
      },
      "customCodeContainer": {
        "onProgramAddedCode": "",
        "onProgramRemovedCode": "",
        "onProgramChangedPositionCode": "",
        "onProgramMarkersAddedCode": "",
        "onProgramMarkersRemovedCode": "",
        "onProgramMarkersChangedPositionCode": "",
        "onProgramAdjacentCode": "",
        "onProgramSeparatedCode": ""
      }
    },
    {
      "number": 505,
      "title": "Equation04",
      "keywords": "TacTiles, equation, example, simple",
      "description": "Program to print and voice equation at top of display.",
      "expanded": false,
      "topWhiskerLength": 0.2,
      "rightWhiskerLength": 0.2,
      "bottomWhiskerLength": 0.2,
      "leftWhiskerLength": 0.2,
      "positionProperty": {
        "x": 6.258839165223833,
        "y": 218.15204543513335
      },
      "modelContainer": {
        "namedBooleanProperties": [
          {
            "name": "BooleanIsRotatedEquation04",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          }
        ],
        "namedVector2Properties": [
          {
            "name": "Equation04Position",
            "propertyType": "Vector2Property",
            "defaultX": "0.5",
            "defaultY": "0.05"
          }
        ],
        "namedNumberProperties": [],
        "namedEnumerationProperties": [],
        "namedDerivedProperties": [],
        "namedBounds2Properties": [],
        "namedObservableArrays": [],
        "namedArrayItems": [],
        "namedArrayItemReferences": [],
        "namedStringProperties": []
      },
      "controllerContainer": {
        "vector2PropertyControllers": [],
        "boundsPropertyControllers": [],
        "booleanPropertyControllers": [
          {
            "name": "ControllerReVoiceEquation04",
            "controlledComponentName": "BooleanIsRotatedEquation04",
            "controlType": "ROTATION",
            "controlTypeFamily": "",
            "whiskerConfiguration": {
              "topLength": 0.2,
              "rightLength": 0.2,
              "bottomLength": 0.2,
              "leftLength": 0.2,
              "otherPaperNumber": null
            },
            "markerColor": ""
          }
        ],
        "numberPropertyControllers": [],
        "enumerationPropertyControllers": []
      },
      "viewContainer": {
        "soundViews": [],
        "speechViews": [
          {
            "name": "ViewVoiceEquation04",
            "modelComponentNames": [
              "BooleanIsRotatedEquation04"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "// 3x  = 2x - 3\nspeak( \"4x plus 4 equals 2x\" );",
            "lazyLink": false
          }
        ],
        "textViews": [
          {
            "name": "ViewTextEquation04",
            "modelComponentNames": [
              "Equation04Position"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "setString( '4x + 4 = 2x' );\nsetFontSize(40);\nsetFontFamily('serif');\nsetCenterX( phet.paperLand.utils.paperToBoardX( Equation04Position.x, sharedData.displaySize.width ));\nsetCenterY( phet.paperLand.utils.paperToBoardY( Equation04Position.y, sharedData.displaySize.height ));",
            "lazyLink": false,
            "defaultViewOptions": {
              "centerX": 0.5,
              "centerY": 0.5,
              "scale": 1,
              "rotation": 0,
              "opacity": 1,
              "visible": true,
              "viewUnits": "model"
            }
          }
        ],
        "shapeViews": [],
        "backgroundViews": [],
        "imageViews": []
      },
      "listenerContainer": {
        "linkListeners": [],
        "animationListeners": [],
        "bluetoothListeners": []
      },
      "customCodeContainer": {
        "onProgramAddedCode": "",
        "onProgramRemovedCode": "",
        "onProgramChangedPositionCode": "",
        "onProgramMarkersAddedCode": "",
        "onProgramMarkersRemovedCode": "",
        "onProgramMarkersChangedPositionCode": "",
        "onProgramAdjacentCode": "",
        "onProgramSeparatedCode": ""
      }
    },
    {
      "number": 1461,
      "title": "Equation05",
      "keywords": "TacTiles, equation, example, simple",
      "description": "Program to print and voice equation at top of display.",
      "expanded": false,
      "topWhiskerLength": 0.2,
      "rightWhiskerLength": 0.2,
      "bottomWhiskerLength": 0.2,
      "leftWhiskerLength": 0.2,
      "positionProperty": {
        "x": 5.525779724121094,
        "y": 254.86704641700328
      },
      "modelContainer": {
        "namedBooleanProperties": [
          {
            "name": "BooleanIsRotatedEquation05",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          }
        ],
        "namedVector2Properties": [
          {
            "name": "Equation05Position",
            "propertyType": "Vector2Property",
            "defaultX": "0.5",
            "defaultY": "0.05"
          }
        ],
        "namedNumberProperties": [],
        "namedEnumerationProperties": [],
        "namedDerivedProperties": [],
        "namedBounds2Properties": [],
        "namedObservableArrays": [],
        "namedArrayItems": [],
        "namedArrayItemReferences": [],
        "namedStringProperties": []
      },
      "controllerContainer": {
        "vector2PropertyControllers": [],
        "boundsPropertyControllers": [],
        "booleanPropertyControllers": [
          {
            "name": "ControllerReVoiceEquation05",
            "controlledComponentName": "BooleanIsRotatedEquation05",
            "controlType": "ROTATION",
            "controlTypeFamily": "",
            "whiskerConfiguration": {
              "topLength": 0.2,
              "rightLength": 0.2,
              "bottomLength": 0.2,
              "leftLength": 0.2,
              "otherPaperNumber": null
            },
            "markerColor": ""
          }
        ],
        "numberPropertyControllers": [],
        "enumerationPropertyControllers": []
      },
      "viewContainer": {
        "soundViews": [],
        "speechViews": [
          {
            "name": "ViewVoiceEquation05",
            "modelComponentNames": [
              "BooleanIsRotatedEquation05"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "// 3x  = 2x - 3\nspeak( \"4x minus 4 equals 3x\" );",
            "lazyLink": false
          }
        ],
        "textViews": [
          {
            "name": "ViewTextEquation05",
            "modelComponentNames": [
              "Equation05Position"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "setString( '4x - 4 = 3x' );\nsetFontSize(40);\nsetFontFamily('serif');\nsetCenterX( phet.paperLand.utils.paperToBoardX( Equation05Position.x, sharedData.displaySize.width ));\nsetCenterY( phet.paperLand.utils.paperToBoardY( Equation05Position.y, sharedData.displaySize.height ));",
            "lazyLink": false,
            "defaultViewOptions": {
              "centerX": 0.5,
              "centerY": 0.5,
              "scale": 1,
              "rotation": 0,
              "opacity": 1,
              "visible": true,
              "viewUnits": "model"
            }
          }
        ],
        "shapeViews": [],
        "backgroundViews": [],
        "imageViews": []
      },
      "listenerContainer": {
        "linkListeners": [],
        "animationListeners": [],
        "bluetoothListeners": []
      },
      "customCodeContainer": {
        "onProgramAddedCode": "",
        "onProgramRemovedCode": "",
        "onProgramChangedPositionCode": "",
        "onProgramMarkersAddedCode": "",
        "onProgramMarkersRemovedCode": "",
        "onProgramMarkersChangedPositionCode": "",
        "onProgramAdjacentCode": "",
        "onProgramSeparatedCode": ""
      }
    },
    {
      "number": 620,
      "title": "Equation06",
      "keywords": "TacTiles, equation, example, simple",
      "description": "Program to print and voice equation at top of display.",
      "expanded": false,
      "topWhiskerLength": 0.2,
      "rightWhiskerLength": 0.2,
      "bottomWhiskerLength": 0.2,
      "leftWhiskerLength": 0.2,
      "positionProperty": {
        "x": 33.03733919668889,
        "y": 272.47653006360315
      },
      "modelContainer": {
        "namedBooleanProperties": [
          {
            "name": "BooleanIsRotatedEquation06",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          }
        ],
        "namedVector2Properties": [
          {
            "name": "Equation06Position",
            "propertyType": "Vector2Property",
            "defaultX": "0.5",
            "defaultY": "0.05"
          }
        ],
        "namedNumberProperties": [],
        "namedEnumerationProperties": [],
        "namedDerivedProperties": [],
        "namedBounds2Properties": [],
        "namedObservableArrays": [],
        "namedArrayItems": [],
        "namedArrayItemReferences": [],
        "namedStringProperties": []
      },
      "controllerContainer": {
        "vector2PropertyControllers": [],
        "boundsPropertyControllers": [],
        "booleanPropertyControllers": [
          {
            "name": "ControllerReVoiceEquation06",
            "controlledComponentName": "BooleanIsRotatedEquation06",
            "controlType": "ROTATION",
            "controlTypeFamily": "",
            "whiskerConfiguration": {
              "topLength": 0.2,
              "rightLength": 0.2,
              "bottomLength": 0.2,
              "leftLength": 0.2,
              "otherPaperNumber": null
            },
            "markerColor": ""
          }
        ],
        "numberPropertyControllers": [],
        "enumerationPropertyControllers": []
      },
      "viewContainer": {
        "soundViews": [],
        "speechViews": [
          {
            "name": "ViewVoiceEquation06",
            "modelComponentNames": [
              "BooleanIsRotatedEquation06"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "// 3x  = 2x - 3\nspeak( \"2x minus 4 equals 3x\" );",
            "lazyLink": false
          }
        ],
        "textViews": [
          {
            "name": "ViewTextEquation06",
            "modelComponentNames": [
              "Equation06Position"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "setString( '2x - 4 = 3x' );\nsetFontSize(40);\nsetFontFamily('serif');\nsetCenterX( phet.paperLand.utils.paperToBoardX( Equation06Position.x, sharedData.displaySize.width ));\nsetCenterY( phet.paperLand.utils.paperToBoardY( Equation06Position.y, sharedData.displaySize.height ));",
            "lazyLink": false,
            "defaultViewOptions": {
              "centerX": 0.5,
              "centerY": 0.5,
              "scale": 1,
              "rotation": 0,
              "opacity": 1,
              "visible": true,
              "viewUnits": "model"
            }
          }
        ],
        "shapeViews": [],
        "backgroundViews": [],
        "imageViews": []
      },
      "listenerContainer": {
        "linkListeners": [],
        "animationListeners": [],
        "bluetoothListeners": []
      },
      "customCodeContainer": {
        "onProgramAddedCode": "",
        "onProgramRemovedCode": "",
        "onProgramChangedPositionCode": "",
        "onProgramMarkersAddedCode": "",
        "onProgramMarkersRemovedCode": "",
        "onProgramMarkersChangedPositionCode": "",
        "onProgramAdjacentCode": "",
        "onProgramSeparatedCode": ""
      }
    },
    {
      "number": 1295,
      "title": "Equation07",
      "keywords": "TacTiles, equation, example, simple",
      "description": "Program to print and voice equation at top of display.",
      "expanded": true,
      "topWhiskerLength": 0.2,
      "rightWhiskerLength": 0.2,
      "bottomWhiskerLength": 0.2,
      "leftWhiskerLength": 0.2,
      "positionProperty": {
        "x": 27.117183685302734,
        "y": 312.3356544439224
      },
      "modelContainer": {
        "namedBooleanProperties": [
          {
            "name": "BooleanIsRotatedEquation07",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          }
        ],
        "namedVector2Properties": [
          {
            "name": "Equation07Position",
            "propertyType": "Vector2Property",
            "defaultX": "0.5",
            "defaultY": "0.05"
          }
        ],
        "namedNumberProperties": [],
        "namedEnumerationProperties": [],
        "namedDerivedProperties": [],
        "namedBounds2Properties": [],
        "namedObservableArrays": [],
        "namedArrayItems": [],
        "namedArrayItemReferences": [],
        "namedStringProperties": []
      },
      "controllerContainer": {
        "vector2PropertyControllers": [],
        "boundsPropertyControllers": [],
        "booleanPropertyControllers": [
          {
            "name": "ControllerReVoiceEquation07",
            "controlledComponentName": "BooleanIsRotatedEquation07",
            "controlType": "ROTATION",
            "controlTypeFamily": "",
            "whiskerConfiguration": {
              "topLength": 0.2,
              "rightLength": 0.2,
              "bottomLength": 0.2,
              "leftLength": 0.2,
              "otherPaperNumber": null
            },
            "markerColor": ""
          }
        ],
        "numberPropertyControllers": [],
        "enumerationPropertyControllers": []
      },
      "viewContainer": {
        "soundViews": [],
        "speechViews": [
          {
            "name": "ViewVoiceEquation07",
            "modelComponentNames": [
              "BooleanIsRotatedEquation07"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "speak( \"2x squared plus 4 equals 3x squared\" );",
            "lazyLink": false
          }
        ],
        "textViews": [
          {
            "name": "ViewTextEquation07",
            "modelComponentNames": [
              "Equation07Position"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "setString( '2x^2 + 4 = 3x^2' );\nsetFontSize(40);\nsetFontFamily('serif');\nsetCenterX( phet.paperLand.utils.paperToBoardX( Equation07Position.x, sharedData.displaySize.width ));\nsetCenterY( phet.paperLand.utils.paperToBoardY( Equation07Position.y, sharedData.displaySize.height ));",
            "lazyLink": false,
            "defaultViewOptions": {
              "centerX": 0.5,
              "centerY": 0.5,
              "scale": 1,
              "rotation": 0,
              "opacity": 1,
              "visible": true,
              "viewUnits": "model"
            }
          }
        ],
        "shapeViews": [],
        "backgroundViews": [],
        "imageViews": []
      },
      "listenerContainer": {
        "linkListeners": [],
        "animationListeners": [],
        "bluetoothListeners": []
      },
      "customCodeContainer": {
        "onProgramAddedCode": "",
        "onProgramRemovedCode": "",
        "onProgramChangedPositionCode": "",
        "onProgramMarkersAddedCode": "",
        "onProgramMarkersRemovedCode": "",
        "onProgramMarkersChangedPositionCode": "",
        "onProgramAdjacentCode": "",
        "onProgramSeparatedCode": ""
      }
    },
    {
      "number": 224,
      "title": "Check Balance",
      "keywords": "",
      "description": "",
      "expanded": false,
      "topWhiskerLength": 0.2,
      "rightWhiskerLength": 0.2,
      "bottomWhiskerLength": 0.2,
      "leftWhiskerLength": 0.2,
      "positionProperty": {
        "x": 617,
        "y": 144.43534323847788
      },
      "modelContainer": {
        "namedBooleanProperties": [
          {
            "name": "BooleanIsInBalance",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          },
          {
            "name": "BooleanIsBalanceRotated",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          }
        ],
        "namedVector2Properties": [],
        "namedNumberProperties": [
          {
            "name": "BalanceLeftXSquaredTerms",
            "propertyType": "NumberProperty",
            "min": 0,
            "max": "100",
            "defaultValue": "0"
          },
          {
            "name": "BalanceLeftXTerms",
            "propertyType": "NumberProperty",
            "min": 0,
            "max": 10,
            "defaultValue": 5
          },
          {
            "name": "BalanceLeftOnesTerms",
            "propertyType": "NumberProperty",
            "min": 0,
            "max": 10,
            "defaultValue": 5
          },
          {
            "name": "BalanceRightXSquaredTerms",
            "propertyType": "NumberProperty",
            "min": 0,
            "max": 10,
            "defaultValue": 5
          },
          {
            "name": "BalanceRightXTerms",
            "propertyType": "NumberProperty",
            "min": 0,
            "max": 10,
            "defaultValue": 5
          },
          {
            "name": "BalanceRightOnesTerms",
            "propertyType": "NumberProperty",
            "min": 0,
            "max": 10,
            "defaultValue": 5
          },
          {
            "name": "BalanceSoundTrigger",
            "propertyType": "NumberProperty",
            "min": 0,
            "max": 10,
            "defaultValue": 5
          }
        ],
        "namedEnumerationProperties": [],
        "namedDerivedProperties": [],
        "namedBounds2Properties": [],
        "namedObservableArrays": [],
        "namedArrayItems": [],
        "namedArrayItemReferences": [],
        "namedStringProperties": []
      },
      "controllerContainer": {
        "vector2PropertyControllers": [],
        "boundsPropertyControllers": [],
        "booleanPropertyControllers": [
          {
            "name": "ControllerBalanceRotation",
            "controlledComponentName": "BooleanIsBalanceRotated",
            "controlType": "ROTATION",
            "controlTypeFamily": "",
            "whiskerConfiguration": {
              "topLength": 0.2,
              "rightLength": 0.2,
              "bottomLength": 0.2,
              "leftLength": 0.2,
              "otherPaperNumber": null
            },
            "markerColor": ""
          }
        ],
        "numberPropertyControllers": [],
        "enumerationPropertyControllers": []
      },
      "viewContainer": {
        "soundViews": [
          {
            "name": "ViewOutOfBalanceSound",
            "modelComponentNames": [
              "BooleanIsInBalance",
              "BalanceSoundTrigger"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "if ( !BooleanIsInBalance ) {\r\n    phet.paperLand.console.log( 'Out of balance' );\r\n    play();\r\n}",
            "lazyLink": false,
            "soundFileName": "/uploads/OutOfBalanceSound.mp3",
            "loop": false,
            "autoplay": false
          },
          {
            "name": "ViewInBalanceSound",
            "modelComponentNames": [
              "BooleanIsInBalance",
              "BalanceSoundTrigger"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "if ( BooleanIsInBalance ) {\r\n    phet.paperLand.console.log( 'In balance' );\r\n    play();\r\n}",
            "lazyLink": false,
            "soundFileName": "/uploads/SuccessSound.mp3",
            "loop": false,
            "autoplay": false
          }
        ],
        "speechViews": [],
        "textViews": [
          {
            "name": "BalanceDebugText",
            "modelComponentNames": [
              "BooleanIsInBalance",
              "BalanceLeftXSquaredTerms",
              "BalanceLeftXTerms",
              "BalanceLeftOnesTerms",
              "BalanceRightXSquaredTerms",
              "BalanceRightXTerms",
              "BalanceRightOnesTerms"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "// setCenterX( 200 );\r\n// setCenterY( 200 );\r\n// setString( `\r\n// In Balance Left X Squared: ${BalanceLeftXSquaredTerms}<br>\r\n// In Balance Left X: ${BalanceLeftXTerms}<br>\r\n// In Balance Left Ones: ${BalanceLeftOnesTerms}<br>\r\n// <br>\r\n// In Balance Right X Squared: ${BalanceRightXSquaredTerms}<br>\r\n// In Balance Right X: ${BalanceRightXTerms}<br>\r\n// In Balance Right Ones: ${BalanceRightOnesTerms}<br>\r\n// <br>\r\n// IN BALANCE: ${BooleanIsInBalance}\r\n// ` );",
            "lazyLink": false,
            "defaultViewOptions": {
              "centerX": 0.5,
              "centerY": 0.5,
              "scale": 1,
              "rotation": 0,
              "opacity": 1,
              "visible": true,
              "viewUnits": "model"
            }
          },
          {
            "name": "ViewInBalanceTextRecord",
            "modelComponentNames": [
              "BooleanIsBalanceRotated"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "// Get the model components you want to inspect without listenening to their\n// changes.\n// TODO: This part should be an option in the UI soon.\nconst tileDataProperty = phet.paperLand.getModelComponent( 'tileData' );\n\n// Only update if both model components exists.\nif ( tileDataProperty && scratchpad.getTermStringForSide ) {\n    const tileData = tileDataProperty.value;\n\n\n        const leftTiles = tileData.filter( data => data.onLeftSide );\n        const leftEquationString = scratchpad.getTermStringForSide( leftTiles );\n\n        const rightTiles = tileData.filter( data => !data.onLeftSide );\n        const rightEquationString = scratchpad.getTermStringForSide( rightTiles );\n\n        // Print the equation like\n        // x^2 + 5x + 3 = 3x - 4\n        setCenterX( 100 );\n        setCenterY( 400 );\n        setString( `${leftEquationString} = ${rightEquationString}` );\n    }",
            "lazyLink": false,
            "defaultViewOptions": {
              "centerX": 0.5,
              "centerY": 0.5,
              "scale": 1,
              "rotation": 0,
              "opacity": 1,
              "visible": true,
              "viewUnits": "model"
            }
          }
        ],
        "shapeViews": [],
        "backgroundViews": [],
        "imageViews": []
      },
      "listenerContainer": {
        "linkListeners": [
          {
            "name": "RotationBalanceChecker",
            "controlledPropertyNames": [
              "BooleanIsInBalance",
              "BalanceSoundTrigger"
            ],
            "controlFunctionString": "// Use internal Paper Playground function to get a reference to the tileData array, without\r\n// add a listener to it so that the balance isn't checked EVERY time the array changes.\r\nconst tileDataProperty = phet.paperLand.getModelComponent( 'tileData' );\r\nif ( tileDataProperty ) {\r\n    const tileData = tileDataProperty.value;\r\n\r\n    // find all of the entries of tile data that are on the left side\r\n    const rightTiles = tileData.filter( data => !data.onLeftSide );\r\n    const leftTiles = tileData.filter( data => data.onLeftSide );\r\n\r\n    // This is a function that we use to count the \"number\" of terms for a given term. We go \r\n    // through the tiles and increment by the number of terms on that tile if positive, and \r\n    // decrement by the number of terms if negative.\r\n    const createAccumulatorFunction = term => {\r\n        return ( accumulator, data ) => {\r\n            if ( data.term === term ) {\r\n                const numberOfTerms = data.count;\r\n                return data.negative ? accumulator - numberOfTerms : accumulator + numberOfTerms;\r\n            }\r\n            else {\r\n                return accumulator;\r\n            }\r\n        }\r\n    }\r\n    \r\n    // Remember, terms are mapped to a number. 'xSquared' is 2, 'x' is 1 and 'ones' is 0.\r\n    const currentRightXSquaredTerms = rightTiles.reduce( createAccumulatorFunction( 2 ), 0 );\r\n    const currentRightXTerms = rightTiles.reduce( createAccumulatorFunction( 1 ), 0 );\r\n    const currentRightOnesTerms = rightTiles.reduce( createAccumulatorFunction( 0 ), 0 );\r\n\r\n    const currentLeftXSquaredTerms = leftTiles.reduce( createAccumulatorFunction( 2 ), 0 );\r\n    const currentLeftXTerms = leftTiles.reduce( createAccumulatorFunction( 1 ), 0 );\r\n    const currentLeftOnesTerms = leftTiles.reduce( createAccumulatorFunction( 0 ), 0 ); \r\n\r\n    // Get the difference in tiles for the right side since this program was added.\r\n    const rightXSquaredDifference = BalanceRightXSquaredTerms - currentRightXSquaredTerms;\r\n    const rightXDifference = BalanceRightXTerms - currentRightXTerms;\r\n    const rightOnesDifference = BalanceRightOnesTerms - currentRightOnesTerms;\r\n\r\n    // Get the difference in tiles for the left side since this program was added.\r\n    const leftXSquaredDifference = BalanceLeftXSquaredTerms - currentLeftXSquaredTerms;\r\n    const leftXDifference = BalanceLeftXTerms - currentLeftXTerms;\r\n    const leftOnesDifference = BalanceLeftOnesTerms - currentLeftOnesTerms;\r\n\r\n    // The equation will be in balance if the differences for all terms is the same\r\n    // for both sides.\r\n    const finalInBalance = rightXSquaredDifference === leftXSquaredDifference &&\r\n                            rightXDifference === leftXDifference &&\r\n                            rightOnesDifference === leftOnesDifference;\r\n\r\n    phet.paperLand.console.log( finalInBalance );\r\n\r\n    // Finally, update our model component representing the state of balance.\r\n    setBooleanIsInBalance( finalInBalance );\r\n\r\n    // BalanceSoundTrigger is just a model component that triggers sound. Add a value to play the sound.\r\n    setBalanceSoundTrigger( BalanceSoundTrigger + 1 );\r\n}",
            "dependencyNames": [
              "BooleanIsBalanceRotated",
              "BalanceLeftXSquaredTerms",
              "BalanceLeftXTerms",
              "BalanceLeftOnesTerms",
              "BalanceRightXSquaredTerms",
              "BalanceRightXTerms",
              "BalanceRightOnesTerms"
            ],
            "referenceComponentNames": []
          }
        ],
        "animationListeners": [],
        "bluetoothListeners": []
      },
      "customCodeContainer": {
        "onProgramAddedCode": "// When this program is added, set the model components that represent the number\r\n// of terms on each side. This means that whatever tiles are out when this program\r\n// is added, that will be considered the baseline for balance. Note that this program\r\n// must be added AFTER the Equation Bounds program because it requires the tileData\r\n// array created in custom code in that program.\r\n\r\nconst tileDataProperty = phet.paperLand.getModelComponent( 'tileData' );\r\nif ( tileDataProperty ) {\r\n    \r\n    // find all of the entries of tile data that are on the left side\r\n    const tileData = tileDataProperty.value;\r\n\r\n    // find all of the entries of tile data that are on the left side\r\n    const rightTiles = tileData.filter( data => !data.onLeftSide );\r\n    const leftTiles = tileData.filter( data => data.onLeftSide );\r\n\r\n    const BalanceLeftXSquaredTerms = phet.paperLand.getModelComponent( 'BalanceLeftXSquaredTerms' );\r\n    const BalanceLeftXTerms = phet.paperLand.getModelComponent( 'BalanceLeftXTerms' );\r\n    const BalanceLeftOnesTerms = phet.paperLand.getModelComponent( 'BalanceLeftOnesTerms' );\r\n\r\n    const BalanceRightXSquaredTerms = phet.paperLand.getModelComponent( 'BalanceRightXSquaredTerms' );\r\n    const BalanceRightXTerms = phet.paperLand.getModelComponent( 'BalanceRightXTerms' );\r\n    const BalanceRightOnesTerms = phet.paperLand.getModelComponent( 'BalanceRightOnesTerms' );\r\n\r\n   // This is a function that we use to count the \"number\" of terms for a given term. We go \r\n   // through the tiles and increment by the number of terms on that tile if positive, and \r\n   // decrement by the number of terms if negative.\r\n   const createAccumulatorFunction = term => {\r\n      return ( accumulator, data ) => {\r\n        if ( data.term === term ) {\r\n\r\n          // This gets the count of the active markers\r\n          const numberOfTerms = data.count;\r\n          return data.negative ? accumulator - numberOfTerms : accumulator + numberOfTerms;\r\n        }\r\n        else {\r\n          return accumulator;\r\n        }\r\n      }\r\n    }\r\n\r\n    BalanceRightXSquaredTerms.value = rightTiles.reduce( createAccumulatorFunction( 2 ), 0 ); // xSquared\r\n    BalanceRightXTerms.value = rightTiles.reduce( createAccumulatorFunction( 1 ), 0 );      // x\r\n    BalanceRightOnesTerms.value = rightTiles.reduce( createAccumulatorFunction( 0 ), 0 );   //one\r\n\r\n    BalanceLeftXSquaredTerms.value = leftTiles.reduce( createAccumulatorFunction( 2 ), 0 );\r\n    BalanceLeftXTerms.value = leftTiles.reduce( createAccumulatorFunction( 1 ), 0 );\r\n    BalanceLeftOnesTerms.value = leftTiles.reduce( createAccumulatorFunction( 0 ), 0 );  \r\n}\r\n\r\n\r\n// A function to get a string that will print the current terms in the equation.\r\nscratchpad.getTermStringForSide = ( tileData ) => {\r\n    const xSquaredTiles = tileData.filter( data => data.term === 2 );   //xSquared\r\n    const xTiles = tileData.filter( data => data.term === 1 );         // x\r\n    const onesTiles = tileData.filter( data => data.term === 0 );      // one\r\n\r\n    let termsString = '';\r\n\r\n    const handleTile = ( tile, term ) => {\r\n        if ( tile.negative && tile.count !== 0 ) {\r\n\r\n            // always describe if it is a negative operation\r\n            termsString += '-';\r\n        }\r\n        else if ( termsString.length > 0 && tile.count !== 0 ) {\r\n\r\n            // if there are terms before this one, include the operation\r\n            termsString += '+';\r\n        }\r\n        // X and XSquared are terms that need a count greater than 1 and \r\n        // ones don't have a term and need to print if greater than zero.\r\n        if ( tile.count > 1 || ( term === '' && tile.count > 0 ) )  {\r\n\r\n            // if there are more than one in the count, include the number\r\n            termsString += ` ${tile.count}`;\r\n            \r\n        }\r\n        if ( tile.count > 0 ) {\r\n            termsString += `${term}`; \r\n        }\r\n        \r\n    }\r\n\r\n    xSquaredTiles.forEach( tile => handleTile( tile, 'x^2' ) );\r\n    xTiles.forEach( tile => handleTile( tile, 'x' ) );\r\n    onesTiles.forEach( tile => handleTile( tile, '' ) );\r\n\r\n    if ( termsString ) {\r\n        return termsString;\r\n    }\r\n    else {\r\n        return 'EMPTY';\r\n    }\r\n};\r\n",
        "onProgramRemovedCode": "",
        "onProgramChangedPositionCode": "",
        "onProgramMarkersAddedCode": "",
        "onProgramMarkersRemovedCode": "",
        "onProgramMarkersChangedPositionCode": "",
        "onProgramAdjacentCode": "",
        "onProgramSeparatedCode": ""
      }
    },
    {
      "number": 1641,
      "title": "Ones Tiles E",
      "keywords": "TacTiles, algebra, voicing, ones, one, numbers",
      "description": "A program that voices the number of one-tiles and increments and decrements the number of ones using markers. Note that current model range is 0-9, and the voicing strings range from 1-10.",
      "expanded": false,
      "topWhiskerLength": 0.05,
      "rightWhiskerLength": 0.05,
      "bottomWhiskerLength": 0.05,
      "leftWhiskerLength": 0.05,
      "positionProperty": {
        "x": 529.0777692033937,
        "y": 279.54165824401485
      },
      "modelContainer": {
        "namedBooleanProperties": [
          {
            "name": "BooleanOnLeftSideForOnes_E",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          },
          {
            "name": "BooleanNegativeForOnes_E",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          },
          {
            "name": "BooleanGoodConnectionForOnes_E",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          },
          {
            "name": "BooleanBadConnectionForOnes_E",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          }
        ],
        "namedVector2Properties": [
          {
            "name": "PositionForOnesTiles_E",
            "propertyType": "Vector2Property",
            "defaultX": 0,
            "defaultY": 0
          }
        ],
        "namedNumberProperties": [
          {
            "name": "NumberOfOnes_E",
            "propertyType": "NumberProperty",
            "min": 0,
            "max": "9",
            "defaultValue": "0"
          }
        ],
        "namedEnumerationProperties": [],
        "namedDerivedProperties": [],
        "namedBounds2Properties": [],
        "namedObservableArrays": [],
        "namedArrayItems": [],
        "namedArrayItemReferences": [],
        "namedStringProperties": []
      },
      "controllerContainer": {
        "vector2PropertyControllers": [
          {
            "name": "ControllerPositionForOnes_E",
            "controlledComponentName": "PositionForOnesTiles_E",
            "controlType": "MATCH_CENTER",
            "controlTypeFamily": ""
          }
        ],
        "boundsPropertyControllers": [],
        "booleanPropertyControllers": [
          {
            "name": "ControllerBooleanNegativeForOnes_E",
            "controlledComponentName": "BooleanNegativeForOnes_E",
            "controlType": "ROTATION",
            "controlTypeFamily": "",
            "whiskerConfiguration": {
              "topLength": 0.2,
              "rightLength": 0.2,
              "bottomLength": 0.2,
              "leftLength": 0.2,
              "otherPaperNumber": null
            },
            "markerColor": ""
          }
        ],
        "numberPropertyControllers": [
          {
            "name": "ControllerForOnes_E",
            "controlledComponentName": "NumberOfOnes_E",
            "controlType": "MARKER_COUNT",
            "controlTypeFamily": "MARKERS",
            "markerColor": "all",
            "relationshipControlType": null
          }
        ],
        "enumerationPropertyControllers": []
      },
      "viewContainer": {
        "soundViews": [
          {
            "name": "ViewGoodConnectionSoundForOnes_E",
            "modelComponentNames": [
              "RectangleModelMode",
              "BooleanGoodConnectionForOnes_E"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "if ( BooleanGoodConnectionForOnes_E && RectangleModelMode ) {\r\n    play();\r\n}",
            "lazyLink": false,
            "soundFileName": "/uploads/SuccessSound.mp3",
            "loop": false,
            "autoplay": false
          },
          {
            "name": "ViewBadConnectionSoundForOnes_E",
            "modelComponentNames": [
              "RectangleModelMode",
              "BooleanBadConnectionForOnes_E"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "if ( BooleanBadConnectionForOnes_E && RectangleModelMode) {\r\n    play();\r\n}",
            "lazyLink": false,
            "soundFileName": "/uploads/OutOfBalanceSound.mp3",
            "loop": false,
            "autoplay": false
          }
        ],
        "speechViews": [
          {
            "name": "ViewNumberOfOnes_E",
            "modelComponentNames": [
              "BooleanNegativeForOnes_E",
              "NumberOfOnes_E"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "phet.paperLand.console.log(NumberOfOnes_E);\nif (Math.floor(NumberOfOnes_E) === 0) {\n// A paper with no markers represents a single 1 tile, so \n// we need to add 1 or -1 to the min value of 0. \n    if (BooleanNegativeForOnes_E) {\n        speak( -1 );\n    }\n    else {\n        speak( 1 );\n    }\n} else {\n    if (BooleanNegativeForOnes_E) {\n        speak( -Math.floor(NumberOfOnes_E) - 1);\n    }\n    else {\n        speak( Math.floor(NumberOfOnes_E) + 1 );\n    }\n}",
            "lazyLink": false
          }
        ],
        "textViews": [
          {
            "name": "ViewTextTilesForOnes_E",
            "modelComponentNames": [
              "BooleanNegativeForOnes_E",
              "PositionForOnesTiles_E",
              "NumberOfOnes_E"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "if (BooleanNegativeForOnes_E) {\n        setString('] ' + (-NumberOfOnes_E - 1) + ' [');\n    }\n    else {\n        setString('[ ' + (NumberOfOnes_E + 1) + ' ]');\n    }\nsetFontSize(20);\nsetCenterX( phet.paperLand.utils.paperToBoardX( PositionForOnesTiles_E.x, sharedData.displaySize.width ))\nsetCenterY( phet.paperLand.utils.paperToBoardY( PositionForOnesTiles_E.y, sharedData.displaySize.height ))",
            "lazyLink": false,
            "defaultViewOptions": {
              "centerX": 0.5,
              "centerY": 0.5,
              "scale": 1,
              "rotation": 0,
              "opacity": 1,
              "visible": true,
              "viewUnits": "model"
            }
          }
        ],
        "shapeViews": [],
        "backgroundViews": [],
        "imageViews": []
      },
      "listenerContainer": {
        "linkListeners": [
          {
            "name": "ControllerBooleanLeftSideForOnes_E",
            "controlledPropertyNames": [
              "BooleanOnLeftSideForOnes_E"
            ],
            "controlFunctionString": "// Uncomment to voice side of equation\nsetBooleanOnLeftSideForOnes_E(BoundsLeftSideOfEquals.containsPoint( PositionForOnesTiles_E )); ",
            "dependencyNames": [
              "BoundsLeftSideOfEquals",
              "PositionForOnesTiles_E"
            ],
            "referenceComponentNames": []
          }
        ],
        "animationListeners": [],
        "bluetoothListeners": []
      },
      "customCodeContainer": {
        "onProgramAddedCode": "// Setting program data to the program for some sound design.\r\nphet.paperLand.setProgramData( paperNumber, 'term', 'ones' );\r\n\r\n// Using addModelObserver lets us add the tiles/bounds programs in any order\r\nscratchpad.observerId = phet.paperLand.addModelObserver(\r\n  'tileData', // the bounds program will create this array when it is added\r\n  tileData => {\r\n\r\n    // as soon as the array is available, add this tile to it\r\n    scratchpad.thisTileData = {\r\n      onLeftSideProperty: phet.paperLand.getModelComponent( 'BooleanOnLeftSideForOnes_E' ),\r\n      negativeProperty: phet.paperLand.getModelComponent( 'BooleanNegativeForOnes_E' ),\r\n      countProperty: phet.paperLand.getModelComponent( 'NumberOfOnes_E' ),\r\n      term: 'ones'\r\n    }\r\n    tileData.push( scratchpad.thisTileData );\r\n  },\r\n  tileData => {\r\n\r\n    // Remove this tile from the array when the array is being removed\r\n    const index = tileData.indexOf( scratchpad.thisTileData );\r\n    if ( index > -1 ) {\r\n        tileData.splice( index, 1 );\r\n        delete scratchpad.tileData;\r\n    }\r\n  }\r\n);",
        "onProgramRemovedCode": "// Removes the term data from the model\r\nphet.paperLand.removeProgramData( paperNumber, 'term' );\r\n\r\nconst tileData = phet.paperLand.getModelComponent( 'tileData' );\r\nif ( tileData ) {\r\n\r\n    // Remove the tile from the array\r\n    const index = tileData.indexOf( scratchpad.thisTileData );\r\n    if ( index > -1 ) {\r\n        tileData.splice( index, 1 );\r\n        delete scratchpad.tileData;        \r\n    }\r\n}\r\n\r\n// remove the model observer\r\nphet.paperLand.removeModelObserver( 'tileData', scratchpad.observerId );\r\ndelete scratchpad.observerId;",
        "onProgramChangedPositionCode": "",
        "onProgramMarkersAddedCode": "",
        "onProgramMarkersRemovedCode": "",
        "onProgramMarkersChangedPositionCode": "",
        "onProgramAdjacentCode": "\r\n// Get a reference to the model component and only update it if it exists.\r\nconst goodConnectionComponent = phet.paperLand.getModelComponent( 'BooleanGoodConnectionForOnes_E' );\r\nconst badConnectionComponent = phet.paperLand.getModelComponent( 'BooleanBadConnectionForOnes_E' );\r\n\r\n\r\nif ( goodConnectionComponent && badConnectionComponent ) {\r\n\r\n    // If this is the left or right whisker...\r\n    if ( direction === 'left' || direction === 'right' ) {\r\n\r\n        // These are the terms that this program is allowed to connect to.\r\n        const goodConnectionTerms = [ 'ones' ];\r\n       \r\n        // These are the terms that this program is NOT allowed to connect to.\r\n        const badConnectionTerms = [ 'x', 'xSquared' ];\r\n\r\n        // This connection is \"good\" if the other program has a term in the good list\r\n        goodConnectionComponent.value = goodConnectionTerms.includes(\r\n\r\n            // get the term from the other program\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        );\r\n        // This connection is \"bad\" if the other program has a term in the bad list\r\n        badConnectionComponent.value = badConnectionTerms.includes(\r\n\r\n            // get the term from the other program\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        );\r\n    }\r\n\r\n    phet.paperLand.console.log( direction );\r\n\r\n    // If this is the top or bottom whisker...\r\n    if ( direction === 'top' || direction === 'bottom' ) {\r\n        \r\n        // These are the terms that this program is allowed to connect to.\r\n        // TODO: Add top and bottom of X tiles\r\n        const goodConnectionTerms = [ 'ones' ];\r\n       \r\n        // These are the terms that this program is NOT allowed to connect to.\r\n        // TODO: Add left and right of X tiles\r\n        const badConnectionTerms = [ 'xSquared' ];\r\n\r\n        // This connection is \"good\" if the other program has a term in the good list\r\n        goodConnectionComponent.value = goodConnectionTerms.includes(\r\n\r\n            // get the term from the other program\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        );\r\n        // This connection is \"bad\" if the other program has a term in the bad list\r\n        badConnectionComponent.value = badConnectionTerms.includes(\r\n\r\n            // get the term from the other program\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        );\r\n    }\r\n}",
        "onProgramSeparatedCode": "\r\n// Get a reference to the model component and only update it if it exists.\r\nconst goodConnectionComponent = phet.paperLand.getModelComponent( 'BooleanGoodConnectionForOnes_E' );\r\nconst badConnectionComponent = phet.paperLand.getModelComponent( 'BooleanBadConnectionForOnes_E' );\r\n\r\n// Components must exit check\r\nif ( goodConnectionComponent && badConnectionComponent )  {\r\n\r\n    // If this is the left or right whisker...\r\n    if ( direction === 'left' || direction === 'right' ) {\r\n\r\n        // These are the terms that this program is allowed to connect to.\r\n        const goodConnectionTerms = [ 'ones' ];\r\n\r\n         // These are the terms that this program is NOT allowed to connect to.\r\n        const badConnectionTerms = [ 'x', 'xSquared' ];\r\n\r\n        // If detatching from another program where connection is \"good\",\r\n        // the connection is no longer there.\r\n        if ( goodConnectionTerms.includes(\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        ) ) {\r\n            goodConnectionComponent.value = false;\r\n        }\r\n        // If detatching from another program where connection is \"bad\",\r\n        // the connection is no longer there.\r\n        if ( badConnectionTerms.includes(\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        ) ) {\r\n            badConnectionComponent.value = false;\r\n        }\r\n    }\r\n\r\n    // If this is the top or bottom whisker...\r\n    if ( direction === 'top' || direction === 'bottom' ) {\r\n\r\n       // These are the terms that this program is allowed to connect to.\r\n       // TODO: top and bottom of X tiles need to be added\r\n        const goodConnectionTerms = [ 'ones' ];\r\n\r\n         // These are the terms that this program is NOT allowed to connect to.\r\n         // TODO: left and right of X tiles need to be added\r\n        const badConnectionTerms = [ 'xSquared' ];\r\n\r\n        // If detatching from another program where connection is \"good\",\r\n        // the connection is no longer there.\r\n        if ( goodConnectionTerms.includes(\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        ) ) {\r\n            goodConnectionComponent.value = false;\r\n        }\r\n        // If detatching from another program where connection is \"bad\",\r\n        // the connection is no longer there.\r\n        if ( badConnectionTerms.includes(\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        ) ) {\r\n            badConnectionComponent.value = false;\r\n        }\r\n    }\r\n}"
      }
    },
    {
      "number": 141,
      "title": "X Tiles C",
      "keywords": "NumberXCoefficient",
      "description": "A program that voices the number of x-tiles (the coefficient of x) and increments and decrements the coefficient using markers.  Note that current model range for the coefficient is 0-9, voicing strings range from x to 10x.",
      "expanded": false,
      "topWhiskerLength": 0.05,
      "rightWhiskerLength": 0.05,
      "bottomWhiskerLength": 0.05,
      "leftWhiskerLength": 0.05,
      "positionProperty": {
        "x": 515.4000091552734,
        "y": 352.49969713868677
      },
      "modelContainer": {
        "namedBooleanProperties": [
          {
            "name": "BooleanOnLeftSideForX_C",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          },
          {
            "name": "BooleanNegativeForX_C",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          },
          {
            "name": "BooleanGoodConnectionForX_C",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          },
          {
            "name": "BooleanBadConnectionForX_C",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          }
        ],
        "namedVector2Properties": [
          {
            "name": "PositionForXTiles_C",
            "propertyType": "Vector2Property",
            "defaultX": 0,
            "defaultY": 0
          }
        ],
        "namedNumberProperties": [
          {
            "name": "NumberXCoefficient_C",
            "propertyType": "NumberProperty",
            "min": 0,
            "max": "9",
            "defaultValue": "0"
          }
        ],
        "namedEnumerationProperties": [],
        "namedDerivedProperties": [],
        "namedBounds2Properties": [],
        "namedObservableArrays": [],
        "namedArrayItems": [],
        "namedArrayItemReferences": [],
        "namedStringProperties": []
      },
      "controllerContainer": {
        "vector2PropertyControllers": [
          {
            "name": "ControllerPositionForX_C",
            "controlledComponentName": "PositionForXTiles_C",
            "controlType": "MATCH_CENTER",
            "controlTypeFamily": ""
          }
        ],
        "boundsPropertyControllers": [],
        "booleanPropertyControllers": [
          {
            "name": "ControllerBooleanNegativeForX_C",
            "controlledComponentName": "BooleanNegativeForX_C",
            "controlType": "ROTATION",
            "controlTypeFamily": "",
            "whiskerConfiguration": {
              "topLength": 0.2,
              "rightLength": 0.2,
              "bottomLength": 0.2,
              "leftLength": 0.2,
              "otherPaperNumber": null
            },
            "markerColor": ""
          }
        ],
        "numberPropertyControllers": [
          {
            "name": "ControllerXCoefficient_C",
            "controlledComponentName": "NumberXCoefficient_C",
            "controlType": "MARKER_COUNT",
            "controlTypeFamily": "MARKERS",
            "markerColor": "all",
            "relationshipControlType": null
          }
        ],
        "enumerationPropertyControllers": []
      },
      "viewContainer": {
        "soundViews": [
          {
            "name": "ViewGoodConnectionSoundForX_C",
            "modelComponentNames": [
              "RectangleModelMode",
              "BooleanGoodConnectionForX_C"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "if ( BooleanGoodConnectionForX_C && RectangleModelMode ) {\r\n    play();\r\n}",
            "lazyLink": false,
            "soundFileName": "/uploads/SuccessSound.mp3",
            "loop": false,
            "autoplay": false
          },
          {
            "name": "ViewBadConnectionSoundForX_C",
            "modelComponentNames": [
              "RectangleModelMode",
              "BooleanBadConnectionForX_C"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "if ( BooleanBadConnectionForX_C && RectangleModelMode ) {\n    play();\n}",
            "lazyLink": false,
            "soundFileName": "/uploads/OutOfBalanceSound.mp3",
            "loop": false,
            "autoplay": false
          }
        ],
        "speechViews": [
          {
            "name": "ViewNumberOfX_C",
            "modelComponentNames": [
              "BooleanNegativeForX_C",
              "NumberXCoefficient_C"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "  // A paper with no markers represents a 1x tile or a -1x tile \n  // and not 0x. We need to add or minus 1, and \n  // for the case of 1x not voice the coefficient. \n  // I think it is ok to voice -1x rather than -x.\nif (Math.floor(NumberXCoefficient_C) === 0) {\n    if (BooleanNegativeForX_C) {\n        speak( 'minus x' );\n    }\n    else {\n        speak( 'x' );\n    }\n} else {\n    if (BooleanNegativeForX_C) {\n        speak( -Math.floor(NumberXCoefficient_C) - 1 + 'x' );\n    }\n    else {\n        speak( Math.floor(NumberXCoefficient_C) + 1 + 'x' );\n    }\n}",
            "lazyLink": false
          }
        ],
        "textViews": [
          {
            "name": "ViewTextTilesForXTiles_C",
            "modelComponentNames": [
              "BooleanNegativeForX_C",
              "PositionForXTiles_C",
              "NumberXCoefficient_C"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "if (Math.floor(NumberXCoefficient_C) === 0) {\n    if (BooleanNegativeForX_C) {\n        setString('] ' + '-x [');\n    }\n    else {\n        setString('[ ' + 'x ]');\n    }\n} \nelse {\n    if (BooleanNegativeForX_C) {\n        setString('] ' + (-NumberXCoefficient_C - 1) + 'x [');\n    }\n    else {\n        setString('[ ' + (NumberXCoefficient_C + 1) + 'x ]');\n    }\n}\nsetFontSize(20);\nsetCenterX( phet.paperLand.utils.paperToBoardX( PositionForXTiles_C.x, sharedData.displaySize.width ))\nsetCenterY( phet.paperLand.utils.paperToBoardY( PositionForXTiles_C.y, sharedData.displaySize.height ))\nphet.paperLand.console.log( phet.paperLand.utils.paperToBoardX( PositionForXTiles_C.x, sharedData.displaySize.width ));",
            "lazyLink": false,
            "defaultViewOptions": {
              "centerX": 0.5,
              "centerY": 0.5,
              "scale": 1,
              "rotation": 0,
              "opacity": 1,
              "visible": true,
              "viewUnits": "model"
            }
          }
        ],
        "shapeViews": [],
        "backgroundViews": [],
        "imageViews": []
      },
      "listenerContainer": {
        "linkListeners": [
          {
            "name": "ControllerBooleanLeftSideForX_C",
            "controlledPropertyNames": [
              "BooleanOnLeftSideForX_C"
            ],
            "controlFunctionString": "setBooleanOnLeftSideForX_C(BoundsLeftSideOfEquals.containsPoint( PositionForXTiles_C )); ",
            "dependencyNames": [
              "BoundsLeftSideOfEquals",
              "PositionForXTiles_C"
            ],
            "referenceComponentNames": []
          }
        ],
        "animationListeners": [],
        "bluetoothListeners": []
      },
      "customCodeContainer": {
        "onProgramAddedCode": "// Setting program data to the program for some sound design.\r\nphet.paperLand.setProgramData( paperNumber, 'term', 'x' );\r\n\r\n// Using addModelObserver lets us add the tiles/bounds programs in any order\r\nscratchpad.observerId = phet.paperLand.addModelObserver(\r\n  'tileData', // the bounds program will create this array when it is added\r\n  tileData => {\r\n\r\n    // as soon as the array is available, add this tile to it\r\n    scratchpad.thisTileData = {\r\n      onLeftSideProperty: phet.paperLand.getModelComponent( 'BooleanOnLeftSideForX_C' ),\r\n      negativeProperty: phet.paperLand.getModelComponent( 'BooleanNegativeForX_C' ),\r\n      countProperty: phet.paperLand.getModelComponent( 'NumberXCoefficient_C' ),\r\n      term: 'x'\r\n    }\r\n    tileData.push( scratchpad.thisTileData );\r\n  },\r\n  tileData => {\r\n\r\n    // Remove this tile from the array when the array is being removed\r\n    const index = tileData.indexOf( scratchpad.thisTileData );\r\n    if ( index > -1 ) {\r\n        tileData.splice( index, 1 );\r\n        delete scratchpad.tileData;\r\n    }\r\n  }\r\n);",
        "onProgramRemovedCode": "// Removes the term data from the model\r\nphet.paperLand.removeProgramData( paperNumber, 'term' );\r\n\r\nconst tileData = phet.paperLand.getModelComponent( 'tileData' );\r\nif ( tileData ) {\r\n\r\n    // Remove the tile from the array\r\n    const index = tileData.indexOf( scratchpad.thisTileData );\r\n    if ( index > -1 ) {\r\n        tileData.splice( index, 1 );\r\n        delete scratchpad.tileData;        \r\n    }\r\n}\r\n\r\n// remove the model observer\r\nphet.paperLand.removeModelObserver( 'tileData', scratchpad.observerId );\r\ndelete scratchpad.observerId;",
        "onProgramChangedPositionCode": "",
        "onProgramMarkersAddedCode": "",
        "onProgramMarkersRemovedCode": "",
        "onProgramMarkersChangedPositionCode": "",
        "onProgramAdjacentCode": "\n// Get a reference to the model component and only update it if it exists.\nconst goodConnectionComponent = phet.paperLand.getModelComponent( 'BooleanGoodConnectionForX_C' );\nconst badConnectionComponent = phet.paperLand.getModelComponent( 'BooleanBadConnectionForX_C' );\n\n\nif ( goodConnectionComponent && badConnectionComponent ) {\n\n    // If this is the left or right whisker...\n    if ( direction === 'left' || direction === 'right' ) {\n\n        // These are the terms that this program is allowed to connect to.\n        const goodConnectionTerms = [ 'xSquared' ];\n       \n        // These are the terms that this program is NOT allowed to connect to.\n        const badConnectionTerms = [ 'ones' ];\n\n        // This connection is \"good\" if the other program has a term in the good list\n        goodConnectionComponent.value = goodConnectionTerms.includes(\n\n            // get the term from the other program\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\n        );\n        // This connection is \"bad\" if the other program has a term in the bad list\n        badConnectionComponent.value = badConnectionTerms.includes(\n\n            // get the term from the other program\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\n        );\n    }\n\n    phet.paperLand.console.log( direction );\n\n    // If this is the top or bottom whisker...\n    if ( direction === 'top' || direction === 'bottom' ) {\n        \n        // These are the terms that this program is allowed to connect to.\n        const goodConnectionTerms = [ 'ones' ];\n       \n        // These are the terms that this program is NOT allowed to connect to.\n        const badConnectionTerms = [ 'xSquared' ];\n\n        // This connection is \"good\" if the other program has a term in the good list\n        goodConnectionComponent.value = goodConnectionTerms.includes(\n\n            // get the term from the other program\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\n        );\n        // This connection is \"bad\" if the other program has a term in the bad list\n        badConnectionComponent.value = badConnectionTerms.includes(\n\n            // get the term from the other program\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\n        );\n    }\n}",
        "onProgramSeparatedCode": "\r\n// Get a reference to the model component and only update it if it exists.\r\nconst goodConnectionComponent = phet.paperLand.getModelComponent( 'BooleanGoodConnectionForX_C' );\r\nconst badConnectionComponent = phet.paperLand.getModelComponent( 'BooleanBadConnectionForX_C' );\r\n\r\n// Components must exit check\r\nif ( goodConnectionComponent && badConnectionComponent )  {\r\n\r\n    // If this is the left or right whisker...\r\n    if ( direction === 'left' || direction === 'right' ) {\r\n\r\n        // These are the terms that this program is allowed to connect to.\r\n        const goodConnectionTerms = [ 'xSquared' ];\r\n\r\n         // These are the terms that this program is NOT allowed to connect to.\r\n        const badConnectionTerms = [ 'ones' ];\r\n\r\n        // If detatching from another program where connection is \"good\",\r\n        // the connection is no longer there.\r\n        if ( goodConnectionTerms.includes(\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        ) ) {\r\n            goodConnectionComponent.value = false;\r\n        }\r\n        // If detatching from another program where connection is \"bad\",\r\n        // the connection is no longer there.\r\n        if ( badConnectionTerms.includes(\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        ) ) {\r\n            badConnectionComponent.value = false;\r\n        }\r\n    }\r\n\r\n    // If this is the top or bottom whisker...\r\n    if ( direction === 'top' || direction === 'bottom' ) {\r\n\r\n       // These are the terms that this program is allowed to connect to.\r\n       // TODO: Need to add top and bottom of X tiles\r\n        const goodConnectionTerms = [ 'ones' ];\r\n\r\n         // These are the terms that this program is NOT allowed to connect to.\r\n        // TODO: Need to add left and right of X tiles\r\n        const badConnectionTerms = [ 'xSquared' ];\r\n\r\n        // If detatching from another program where connection is \"good\",\r\n        // the connection is no longer there.\r\n        if ( goodConnectionTerms.includes(\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        ) ) {\r\n            goodConnectionComponent.value = false;\r\n        }\r\n        // If detatching from another program where connection is \"bad\",\r\n        // the connection is no longer there.\r\n        if ( badConnectionTerms.includes(\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        ) ) {\r\n            badConnectionComponent.value = false;\r\n        }\r\n    }\r\n}"
      }
    },
    {
      "number": 1036,
      "title": "X Tiles D",
      "keywords": "NumberXCoefficient",
      "description": "A program that voices the number of x-tiles (the coefficient of x) and increments and decrements the coefficient using markers.  Note that current model range for the coefficient is 0-9, voicing strings range from x to 10x.",
      "expanded": false,
      "topWhiskerLength": 0.05,
      "rightWhiskerLength": 0.05,
      "bottomWhiskerLength": 0.05,
      "leftWhiskerLength": 0.05,
      "positionProperty": {
        "x": 605.0473721031335,
        "y": 394.7895992098286
      },
      "modelContainer": {
        "namedBooleanProperties": [
          {
            "name": "BooleanOnLeftSideForX_D",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          },
          {
            "name": "BooleanNegativeForX_D",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          },
          {
            "name": "BooleanGoodConnectionForX_D",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          },
          {
            "name": "BooleanBadConnectionForX_D",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          }
        ],
        "namedVector2Properties": [
          {
            "name": "PositionForXTiles_D",
            "propertyType": "Vector2Property",
            "defaultX": 0,
            "defaultY": 0
          }
        ],
        "namedNumberProperties": [
          {
            "name": "NumberXCoefficient_D",
            "propertyType": "NumberProperty",
            "min": 0,
            "max": "9",
            "defaultValue": "0"
          }
        ],
        "namedEnumerationProperties": [],
        "namedDerivedProperties": [],
        "namedBounds2Properties": [],
        "namedObservableArrays": [],
        "namedArrayItems": [],
        "namedArrayItemReferences": [],
        "namedStringProperties": []
      },
      "controllerContainer": {
        "vector2PropertyControllers": [
          {
            "name": "ControllerPositionForX_D",
            "controlledComponentName": "PositionForXTiles_D",
            "controlType": "MATCH_CENTER",
            "controlTypeFamily": ""
          }
        ],
        "boundsPropertyControllers": [],
        "booleanPropertyControllers": [
          {
            "name": "ControllerBooleanNegativeForX_D",
            "controlledComponentName": "BooleanNegativeForX_D",
            "controlType": "ROTATION",
            "controlTypeFamily": "",
            "whiskerConfiguration": {
              "topLength": 0.2,
              "rightLength": 0.2,
              "bottomLength": 0.2,
              "leftLength": 0.2,
              "otherPaperNumber": null
            },
            "markerColor": ""
          }
        ],
        "numberPropertyControllers": [
          {
            "name": "ControllerXCoefficient_D",
            "controlledComponentName": "NumberXCoefficient_D",
            "controlType": "MARKER_COUNT",
            "controlTypeFamily": "MARKERS",
            "markerColor": "all",
            "relationshipControlType": null
          }
        ],
        "enumerationPropertyControllers": []
      },
      "viewContainer": {
        "soundViews": [
          {
            "name": "ViewGoodConnectionSoundForX_D",
            "modelComponentNames": [
              "RectangleModelMode",
              "BooleanGoodConnectionForX_D"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "if ( BooleanGoodConnectionForX_D && RectangleModelMode ) {\r\n    play();\r\n}",
            "lazyLink": false,
            "soundFileName": "/uploads/SuccessSound.mp3",
            "loop": false,
            "autoplay": false
          },
          {
            "name": "ViewBadConnectionSoundForX_D",
            "modelComponentNames": [
              "RectangleModelMode",
              "BooleanBadConnectionForX_D"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "if ( BooleanBadConnectionForX_D && RectangleModelMode ) {\n    play();\n}",
            "lazyLink": false,
            "soundFileName": "/uploads/OutOfBalanceSound.mp3",
            "loop": false,
            "autoplay": false
          }
        ],
        "speechViews": [
          {
            "name": "ViewNumberOfX_D",
            "modelComponentNames": [
              "BooleanNegativeForX_D",
              "NumberXCoefficient_D"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "  // A paper with no markers represents a 1x tile or a -1x tile \n  // and not 0x. We need to add or minus 1, and \n  // for the case of 1x not voice the coefficient. \n  // I think it is ok to voice -1x rather than -x.\nif (Math.floor(NumberXCoefficient_D) === 0) {\n    if (BooleanNegativeForX_D) {\n        speak( 'minus x' );\n    }\n    else {\n        speak( 'x' );\n    }\n} else {\n    if (BooleanNegativeForX_D) {\n        speak( -Math.floor(NumberXCoefficient_D) - 1 + 'x' );\n    }\n    else {\n        speak( Math.floor(NumberXCoefficient_D) + 1 + 'x' );\n    }\n}",
            "lazyLink": false
          }
        ],
        "textViews": [
          {
            "name": "ViewTextTilesForXTiles_D",
            "modelComponentNames": [
              "BooleanNegativeForX_D",
              "PositionForXTiles_D",
              "NumberXCoefficient_D"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "if (Math.floor(NumberXCoefficient_D) === 0) {\n    if (BooleanNegativeForX_D) {\n        setString('] ' + '-x [');\n    }\n    else {\n        setString('[ ' + 'x ]');\n    }\n} \nelse {\n    if (BooleanNegativeForX_D) {\n        setString('] ' + (-NumberXCoefficient_D - 1) + 'x [');\n    }\n    else {\n        setString('[ ' + (NumberXCoefficient_D + 1) + 'x ]');\n    }\n}\nsetFontSize(20);\nsetCenterX( phet.paperLand.utils.paperToBoardX( PositionForXTiles_D.x, sharedData.displaySize.width ))\nsetCenterY( phet.paperLand.utils.paperToBoardY( PositionForXTiles_D.y, sharedData.displaySize.height ))\nphet.paperLand.console.log( phet.paperLand.utils.paperToBoardX( PositionForXTiles_D.x, sharedData.displaySize.width ));",
            "lazyLink": false,
            "defaultViewOptions": {
              "centerX": 0.5,
              "centerY": 0.5,
              "scale": 1,
              "rotation": 0,
              "opacity": 1,
              "visible": true,
              "viewUnits": "model"
            }
          }
        ],
        "shapeViews": [],
        "backgroundViews": [],
        "imageViews": []
      },
      "listenerContainer": {
        "linkListeners": [
          {
            "name": "ControllerBooleanLeftSideForX_D",
            "controlledPropertyNames": [
              "BooleanOnLeftSideForX_D"
            ],
            "controlFunctionString": "setBooleanOnLeftSideForX_D(BoundsLeftSideOfEquals.containsPoint( PositionForXTiles_D )); ",
            "dependencyNames": [
              "BoundsLeftSideOfEquals",
              "PositionForXTiles_D"
            ],
            "referenceComponentNames": []
          }
        ],
        "animationListeners": [],
        "bluetoothListeners": []
      },
      "customCodeContainer": {
        "onProgramAddedCode": "// Setting program data to the program for some sound design.\r\nphet.paperLand.setProgramData( paperNumber, 'term', 'x' );\r\n\r\n// Using addModelObserver lets us add the tiles/bounds programs in any order\r\nscratchpad.observerId = phet.paperLand.addModelObserver(\r\n  'tileData', // the bounds program will create this array when it is added\r\n  tileData => {\r\n\r\n    // as soon as the array is available, add this tile to it\r\n    scratchpad.thisTileData = {\r\n      onLeftSideProperty: phet.paperLand.getModelComponent( 'BooleanOnLeftSideForX_D' ),\r\n      negativeProperty: phet.paperLand.getModelComponent( 'BooleanNegativeForX_D' ),\r\n      countProperty: phet.paperLand.getModelComponent( 'NumberXCoefficient_D' ),\r\n      term: 'x'\r\n    }\r\n    tileData.push( scratchpad.thisTileData );\r\n  },\r\n  tileData => {\r\n\r\n    // Remove this tile from the array when the array is being removed\r\n    const index = tileData.indexOf( scratchpad.thisTileData );\r\n    if ( index > -1 ) {\r\n        tileData.splice( index, 1 );\r\n        delete scratchpad.tileData;\r\n    }\r\n  }\r\n);",
        "onProgramRemovedCode": "// Removes the term data from the model\r\nphet.paperLand.removeProgramData( paperNumber, 'term' );\r\n\r\nconst tileData = phet.paperLand.getModelComponent( 'tileData' );\r\nif ( tileData ) {\r\n\r\n    // Remove the tile from the array\r\n    const index = tileData.indexOf( scratchpad.thisTileData );\r\n    if ( index > -1 ) {\r\n        tileData.splice( index, 1 );\r\n        delete scratchpad.tileData;        \r\n    }\r\n}\r\n\r\n// remove the model observer\r\nphet.paperLand.removeModelObserver( 'tileData', scratchpad.observerId );\r\ndelete scratchpad.observerId;",
        "onProgramChangedPositionCode": "",
        "onProgramMarkersAddedCode": "",
        "onProgramMarkersRemovedCode": "",
        "onProgramMarkersChangedPositionCode": "",
        "onProgramAdjacentCode": "\n// Get a reference to the model component and only update it if it exists.\nconst goodConnectionComponent = phet.paperLand.getModelComponent( 'BooleanGoodConnectionForX_D' );\nconst badConnectionComponent = phet.paperLand.getModelComponent( 'BooleanBadConnectionForX_D' );\n\n\nif ( goodConnectionComponent && badConnectionComponent ) {\n\n    // If this is the left or right whisker...\n    if ( direction === 'left' || direction === 'right' ) {\n\n        // These are the terms that this program is allowed to connect to.\n        const goodConnectionTerms = [ 'xSquared' ];\n       \n        // These are the terms that this program is NOT allowed to connect to.\n        const badConnectionTerms = [ 'ones' ];\n\n        // This connection is \"good\" if the other program has a term in the good list\n        goodConnectionComponent.value = goodConnectionTerms.includes(\n\n            // get the term from the other program\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\n        );\n        // This connection is \"bad\" if the other program has a term in the bad list\n        badConnectionComponent.value = badConnectionTerms.includes(\n\n            // get the term from the other program\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\n        );\n    }\n\n    phet.paperLand.console.log( direction );\n\n    // If this is the top or bottom whisker...\n    if ( direction === 'top' || direction === 'bottom' ) {\n        \n        // These are the terms that this program is allowed to connect to.\n        const goodConnectionTerms = [ 'ones' ];\n       \n        // These are the terms that this program is NOT allowed to connect to.\n        const badConnectionTerms = [ 'xSquared' ];\n\n        // This connection is \"good\" if the other program has a term in the good list\n        goodConnectionComponent.value = goodConnectionTerms.includes(\n\n            // get the term from the other program\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\n        );\n        // This connection is \"bad\" if the other program has a term in the bad list\n        badConnectionComponent.value = badConnectionTerms.includes(\n\n            // get the term from the other program\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\n        );\n    }\n}",
        "onProgramSeparatedCode": "\r\n// Get a reference to the model component and only update it if it exists.\r\nconst goodConnectionComponent = phet.paperLand.getModelComponent( 'BooleanGoodConnectionForX_D' );\r\nconst badConnectionComponent = phet.paperLand.getModelComponent( 'BooleanBadConnectionForX_D' );\r\n\r\n// Components must exit check\r\nif ( goodConnectionComponent && badConnectionComponent )  {\r\n\r\n    // If this is the left or right whisker...\r\n    if ( direction === 'left' || direction === 'right' ) {\r\n\r\n        // These are the terms that this program is allowed to connect to.\r\n        const goodConnectionTerms = [ 'xSquared' ];\r\n\r\n         // These are the terms that this program is NOT allowed to connect to.\r\n        const badConnectionTerms = [ 'ones' ];\r\n\r\n        // If detatching from another program where connection is \"good\",\r\n        // the connection is no longer there.\r\n        if ( goodConnectionTerms.includes(\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        ) ) {\r\n            goodConnectionComponent.value = false;\r\n        }\r\n        // If detatching from another program where connection is \"bad\",\r\n        // the connection is no longer there.\r\n        if ( badConnectionTerms.includes(\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        ) ) {\r\n            badConnectionComponent.value = false;\r\n        }\r\n    }\r\n\r\n    // If this is the top or bottom whisker...\r\n    if ( direction === 'top' || direction === 'bottom' ) {\r\n\r\n       // These are the terms that this program is allowed to connect to.\r\n       // TODO: Need to add top and bottom of X tiles\r\n        const goodConnectionTerms = [ 'ones' ];\r\n\r\n         // These are the terms that this program is NOT allowed to connect to.\r\n        // TODO: Need to add left and right of X tiles\r\n        const badConnectionTerms = [ 'xSquared' ];\r\n\r\n        // If detatching from another program where connection is \"good\",\r\n        // the connection is no longer there.\r\n        if ( goodConnectionTerms.includes(\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        ) ) {\r\n            goodConnectionComponent.value = false;\r\n        }\r\n        // If detatching from another program where connection is \"bad\",\r\n        // the connection is no longer there.\r\n        if ( badConnectionTerms.includes(\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        ) ) {\r\n            badConnectionComponent.value = false;\r\n        }\r\n    }\r\n}"
      }
    },
    {
      "number": 470,
      "title": "X Tiles E",
      "keywords": "NumberXCoefficient",
      "description": "A program that voices the number of x-tiles (the coefficient of x) and increments and decrements the coefficient using markers.  Note that current model range for the coefficient is 0-9, voicing strings range from x to 10x.",
      "expanded": false,
      "topWhiskerLength": 0.05,
      "rightWhiskerLength": 0.05,
      "bottomWhiskerLength": 0.05,
      "leftWhiskerLength": 0.05,
      "positionProperty": {
        "x": 590.3000183105469,
        "y": 318.7178466989953
      },
      "modelContainer": {
        "namedBooleanProperties": [
          {
            "name": "BooleanOnLeftSideForX_E",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          },
          {
            "name": "BooleanNegativeForX_E",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          },
          {
            "name": "BooleanGoodConnectionForX_E",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          },
          {
            "name": "BooleanBadConnectionForX_E",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          }
        ],
        "namedVector2Properties": [
          {
            "name": "PositionForXTiles_E",
            "propertyType": "Vector2Property",
            "defaultX": 0,
            "defaultY": 0
          }
        ],
        "namedNumberProperties": [
          {
            "name": "NumberXCoefficient_E",
            "propertyType": "NumberProperty",
            "min": 0,
            "max": "9",
            "defaultValue": "0"
          }
        ],
        "namedEnumerationProperties": [],
        "namedDerivedProperties": [],
        "namedBounds2Properties": [],
        "namedObservableArrays": [],
        "namedArrayItems": [],
        "namedArrayItemReferences": [],
        "namedStringProperties": []
      },
      "controllerContainer": {
        "vector2PropertyControllers": [
          {
            "name": "ControllerPositionForX_E",
            "controlledComponentName": "PositionForXTiles_E",
            "controlType": "MATCH_CENTER",
            "controlTypeFamily": ""
          }
        ],
        "boundsPropertyControllers": [],
        "booleanPropertyControllers": [
          {
            "name": "ControllerBooleanNegativeForX_E",
            "controlledComponentName": "BooleanNegativeForX_E",
            "controlType": "ROTATION",
            "controlTypeFamily": "",
            "whiskerConfiguration": {
              "topLength": 0.2,
              "rightLength": 0.2,
              "bottomLength": 0.2,
              "leftLength": 0.2,
              "otherPaperNumber": null
            },
            "markerColor": ""
          }
        ],
        "numberPropertyControllers": [
          {
            "name": "ControllerXCoefficient_E",
            "controlledComponentName": "NumberXCoefficient_E",
            "controlType": "MARKER_COUNT",
            "controlTypeFamily": "MARKERS",
            "markerColor": "all",
            "relationshipControlType": null
          }
        ],
        "enumerationPropertyControllers": []
      },
      "viewContainer": {
        "soundViews": [
          {
            "name": "ViewGoodConnectionSoundForX_E",
            "modelComponentNames": [
              "RectangleModelMode",
              "BooleanGoodConnectionForX_E"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "if ( BooleanGoodConnectionForX_E && RectangleModelMode ) {\r\n    play();\r\n}",
            "lazyLink": false,
            "soundFileName": "/uploads/SuccessSound.mp3",
            "loop": false,
            "autoplay": false
          },
          {
            "name": "ViewBadConnectionSoundForX_E",
            "modelComponentNames": [
              "RectangleModelMode",
              "BooleanBadConnectionForX_E"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "if ( BooleanBadConnectionForX_E && RectangleModelMode ) {\n    play();\n}",
            "lazyLink": false,
            "soundFileName": "/uploads/OutOfBalanceSound.mp3",
            "loop": false,
            "autoplay": false
          }
        ],
        "speechViews": [
          {
            "name": "ViewNumberOfX_E",
            "modelComponentNames": [
              "BooleanNegativeForX_E",
              "NumberXCoefficient_E"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "  // A paper with no markers represents a 1x tile or a -1x tile \n  // and not 0x. We need to add or minus 1, and \n  // for the case of 1x not voice the coefficient. \n  // I think it is ok to voice -1x rather than -x.\nif (Math.floor(NumberXCoefficient_E) === 0) {\n    if (BooleanNegativeForX_E) {\n        speak( 'minus x' );\n    }\n    else {\n        speak( 'x' );\n    }\n} else {\n    if (BooleanNegativeForX_E) {\n        speak( -Math.floor(NumberXCoefficient_E) - 1 + 'x' );\n    }\n    else {\n        speak( Math.floor(NumberXCoefficient_E) + 1 + 'x' );\n    }\n}",
            "lazyLink": false
          }
        ],
        "textViews": [
          {
            "name": "ViewTextTilesForXTiles_E",
            "modelComponentNames": [
              "BooleanNegativeForX_E",
              "PositionForXTiles_E",
              "NumberXCoefficient_E"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "if (Math.floor(NumberXCoefficient_E) === 0) {\n    if (BooleanNegativeForX_E) {\n        setString('] ' + '-x [');\n    }\n    else {\n        setString('[ ' + 'x ]');\n    }\n} \nelse {\n    if (BooleanNegativeForX_E) {\n        setString('] ' + (-NumberXCoefficient_E - 1) + 'x [');\n    }\n    else {\n        setString('[ ' + (NumberXCoefficient_E + 1) + 'x ]');\n    }\n}\nsetFontSize(20);\nsetCenterX( phet.paperLand.utils.paperToBoardX( PositionForXTiles_E.x, sharedData.displaySize.width ))\nsetCenterY( phet.paperLand.utils.paperToBoardY( PositionForXTiles_E.y, sharedData.displaySize.height ))\nphet.paperLand.console.log( phet.paperLand.utils.paperToBoardX( PositionForXTiles_E.x, sharedData.displaySize.width ));",
            "lazyLink": false,
            "defaultViewOptions": {
              "centerX": 0.5,
              "centerY": 0.5,
              "scale": 1,
              "rotation": 0,
              "opacity": 1,
              "visible": true,
              "viewUnits": "model"
            }
          }
        ],
        "shapeViews": [],
        "backgroundViews": [],
        "imageViews": []
      },
      "listenerContainer": {
        "linkListeners": [
          {
            "name": "ControllerBooleanLeftSideForX_E",
            "controlledPropertyNames": [
              "BooleanOnLeftSideForX_E"
            ],
            "controlFunctionString": "setBooleanOnLeftSideForX_E(BoundsLeftSideOfEquals.containsPoint( PositionForXTiles_E )); ",
            "dependencyNames": [
              "BoundsLeftSideOfEquals",
              "PositionForXTiles_E"
            ],
            "referenceComponentNames": []
          }
        ],
        "animationListeners": [],
        "bluetoothListeners": []
      },
      "customCodeContainer": {
        "onProgramAddedCode": "// Setting program data to the program for some sound design.\r\nphet.paperLand.setProgramData( paperNumber, 'term', 'x' );\r\n\r\n// Using addModelObserver lets us add the tiles/bounds programs in any order\r\nscratchpad.observerId = phet.paperLand.addModelObserver(\r\n  'tileData', // the bounds program will create this array when it is added\r\n  tileData => {\r\n\r\n    // as soon as the array is available, add this tile to it\r\n    scratchpad.thisTileData = {\r\n      onLeftSideProperty: phet.paperLand.getModelComponent( 'BooleanOnLeftSideForX_E' ),\r\n      negativeProperty: phet.paperLand.getModelComponent( 'BooleanNegativeForX_E' ),\r\n      countProperty: phet.paperLand.getModelComponent( 'NumberXCoefficient_E' ),\r\n      term: 'x'\r\n    }\r\n    tileData.push( scratchpad.thisTileData );\r\n  },\r\n  tileData => {\r\n\r\n    // Remove this tile from the array when the array is being removed\r\n    const index = tileData.indexOf( scratchpad.thisTileData );\r\n    if ( index > -1 ) {\r\n        tileData.splice( index, 1 );\r\n        delete scratchpad.tileData;\r\n    }\r\n  }\r\n);",
        "onProgramRemovedCode": "// Removes the term data from the model\r\nphet.paperLand.removeProgramData( paperNumber, 'term' );\r\n\r\nconst tileData = phet.paperLand.getModelComponent( 'tileData' );\r\nif ( tileData ) {\r\n\r\n    // Remove the tile from the array\r\n    const index = tileData.indexOf( scratchpad.thisTileData );\r\n    if ( index > -1 ) {\r\n        tileData.splice( index, 1 );\r\n        delete scratchpad.tileData;        \r\n    }\r\n}\r\n\r\n// remove the model observer\r\nphet.paperLand.removeModelObserver( 'tileData', scratchpad.observerId );\r\ndelete scratchpad.observerId;",
        "onProgramChangedPositionCode": "",
        "onProgramMarkersAddedCode": "",
        "onProgramMarkersRemovedCode": "",
        "onProgramMarkersChangedPositionCode": "",
        "onProgramAdjacentCode": "\n// Get a reference to the model component and only update it if it exists.\nconst goodConnectionComponent = phet.paperLand.getModelComponent( 'BooleanGoodConnectionForX_E' );\nconst badConnectionComponent = phet.paperLand.getModelComponent( 'BooleanBadConnectionForX_E' );\n\n\nif ( goodConnectionComponent && badConnectionComponent ) {\n\n    // If this is the left or right whisker...\n    if ( direction === 'left' || direction === 'right' ) {\n\n        // These are the terms that this program is allowed to connect to.\n        const goodConnectionTerms = [ 'xSquared' ];\n       \n        // These are the terms that this program is NOT allowed to connect to.\n        const badConnectionTerms = [ 'ones' ];\n\n        // This connection is \"good\" if the other program has a term in the good list\n        goodConnectionComponent.value = goodConnectionTerms.includes(\n\n            // get the term from the other program\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\n        );\n        // This connection is \"bad\" if the other program has a term in the bad list\n        badConnectionComponent.value = badConnectionTerms.includes(\n\n            // get the term from the other program\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\n        );\n    }\n\n    phet.paperLand.console.log( direction );\n\n    // If this is the top or bottom whisker...\n    if ( direction === 'top' || direction === 'bottom' ) {\n        \n        // These are the terms that this program is allowed to connect to.\n        const goodConnectionTerms = [ 'ones' ];\n       \n        // These are the terms that this program is NOT allowed to connect to.\n        const badConnectionTerms = [ 'xSquared' ];\n\n        // This connection is \"good\" if the other program has a term in the good list\n        goodConnectionComponent.value = goodConnectionTerms.includes(\n\n            // get the term from the other program\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\n        );\n        // This connection is \"bad\" if the other program has a term in the bad list\n        badConnectionComponent.value = badConnectionTerms.includes(\n\n            // get the term from the other program\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\n        );\n    }\n}",
        "onProgramSeparatedCode": "\r\n// Get a reference to the model component and only update it if it exists.\r\nconst goodConnectionComponent = phet.paperLand.getModelComponent( 'BooleanGoodConnectionForX_E' );\r\nconst badConnectionComponent = phet.paperLand.getModelComponent( 'BooleanBadConnectionForX_E' );\r\n\r\n// Components must exit check\r\nif ( goodConnectionComponent && badConnectionComponent )  {\r\n\r\n    // If this is the left or right whisker...\r\n    if ( direction === 'left' || direction === 'right' ) {\r\n\r\n        // These are the terms that this program is allowed to connect to.\r\n        const goodConnectionTerms = [ 'xSquared' ];\r\n\r\n         // These are the terms that this program is NOT allowed to connect to.\r\n        const badConnectionTerms = [ 'ones' ];\r\n\r\n        // If detatching from another program where connection is \"good\",\r\n        // the connection is no longer there.\r\n        if ( goodConnectionTerms.includes(\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        ) ) {\r\n            goodConnectionComponent.value = false;\r\n        }\r\n        // If detatching from another program where connection is \"bad\",\r\n        // the connection is no longer there.\r\n        if ( badConnectionTerms.includes(\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        ) ) {\r\n            badConnectionComponent.value = false;\r\n        }\r\n    }\r\n\r\n    // If this is the top or bottom whisker...\r\n    if ( direction === 'top' || direction === 'bottom' ) {\r\n\r\n       // These are the terms that this program is allowed to connect to.\r\n       // TODO: Need to add top and bottom of X tiles\r\n        const goodConnectionTerms = [ 'ones' ];\r\n\r\n         // These are the terms that this program is NOT allowed to connect to.\r\n        // TODO: Need to add left and right of X tiles\r\n        const badConnectionTerms = [ 'xSquared' ];\r\n\r\n        // If detatching from another program where connection is \"good\",\r\n        // the connection is no longer there.\r\n        if ( goodConnectionTerms.includes(\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        ) ) {\r\n            goodConnectionComponent.value = false;\r\n        }\r\n        // If detatching from another program where connection is \"bad\",\r\n        // the connection is no longer there.\r\n        if ( badConnectionTerms.includes(\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        ) ) {\r\n            badConnectionComponent.value = false;\r\n        }\r\n    }\r\n}"
      }
    },
    {
      "number": 1153,
      "title": "x Squared Tiles B",
      "keywords": "TacTiles, algebra, voicing, x^2, x, squared, x-squared",
      "description": "A program that voices the number of x-squared tiles (the coefficient of x-squared) and increments and decrements the coefficient using markers.  Note that current model range is 0-9, voicing strings range from x squared to 10x^2.",
      "expanded": false,
      "topWhiskerLength": 0.05,
      "rightWhiskerLength": 0.05,
      "bottomWhiskerLength": 0.05,
      "leftWhiskerLength": 0.05,
      "positionProperty": {
        "x": 480.8417709466311,
        "y": 302.4283685736528
      },
      "modelContainer": {
        "namedBooleanProperties": [
          {
            "name": "BooleanOnLeftSideForXSquared_B",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          },
          {
            "name": "BooleanNegativeForXSquared_B",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          }
        ],
        "namedVector2Properties": [
          {
            "name": "PositionForXSquaredTiles_B",
            "propertyType": "Vector2Property",
            "defaultX": 0,
            "defaultY": 0
          }
        ],
        "namedNumberProperties": [
          {
            "name": "NumberXSquaredCoefficient_B",
            "propertyType": "NumberProperty",
            "min": "0",
            "max": "9",
            "defaultValue": "0"
          }
        ],
        "namedEnumerationProperties": [],
        "namedDerivedProperties": [],
        "namedBounds2Properties": [],
        "namedObservableArrays": [],
        "namedArrayItems": [],
        "namedArrayItemReferences": [],
        "namedStringProperties": []
      },
      "controllerContainer": {
        "vector2PropertyControllers": [
          {
            "name": "ControllerPositionForXSquared_B",
            "controlledComponentName": "PositionForXSquaredTiles_B",
            "controlType": "MATCH_CENTER",
            "controlTypeFamily": ""
          }
        ],
        "boundsPropertyControllers": [],
        "booleanPropertyControllers": [
          {
            "name": "ControllerBooleanNegativeForXSquared_B",
            "controlledComponentName": "BooleanNegativeForXSquared_B",
            "controlType": "ROTATION",
            "controlTypeFamily": "",
            "whiskerConfiguration": {
              "topLength": 0.2,
              "rightLength": 0.2,
              "bottomLength": 0.2,
              "leftLength": 0.2,
              "otherPaperNumber": null
            },
            "markerColor": ""
          }
        ],
        "numberPropertyControllers": [
          {
            "name": "ControllerXSquareCoefficient_B",
            "controlledComponentName": "NumberXSquaredCoefficient_B",
            "controlType": "MARKER_COUNT",
            "controlTypeFamily": "MARKERS",
            "markerColor": "all",
            "relationshipControlType": null
          }
        ],
        "enumerationPropertyControllers": []
      },
      "viewContainer": {
        "soundViews": [],
        "speechViews": [
          {
            "name": "ViewNumberOfXSquared_B",
            "modelComponentNames": [
              "BooleanNegativeForXSquared_B",
              "NumberXSquaredCoefficient_B"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "phet.paperLand.console.log(NumberXSquaredCoefficient_B);\nif (Math.floor(NumberXSquaredCoefficient_B) === 0) {\n // A paper with no markers represents 1x^2 or -1x^2 and \n // in the case of 1x^2 the coefficient does not need to be voiced.\nif (BooleanNegativeForXSquared_B) {\n        speak( 'minus x squared' );\n    }\n    else {\n        speak( 'x squared' );\n    }\n} else {\n    if (BooleanNegativeForXSquared_B) {\n        speak( -Math.floor(NumberXSquaredCoefficient_B) - 1 + 'x squared' );\n    }\n    else {\n        speak( Math.floor(NumberXSquaredCoefficient_B) + 1 + 'x squared' );\n    }\n}",
            "lazyLink": false
          }
        ],
        "textViews": [
          {
            "name": "ViewTextTilesForXSquared_B",
            "modelComponentNames": [
              "BooleanNegativeForXSquared_B",
              "PositionForXSquaredTiles_B",
              "NumberXSquaredCoefficient_B"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "//\n//if (BooleanNegativeForXSquared_B) {\n//    setString('] ' + (-NumberXSquaredCoefficient_B - 1) + 'x^2 [');\n //   }\n //   else {\n//        setString('[ ' + (NumberXSquaredCoefficient_B + 1) + 'x^2 ]');\n //   }\n if (Math.floor(NumberXSquaredCoefficient_B) === 0) {\n    if (BooleanNegativeForXSquared_B) {\n        setString('] ' + '-x^2 [');\n    }\n    else {\n        setString('[ ' + 'x^2  ]');\n    }\n} \nelse {\n    if (BooleanNegativeForXSquared_B) {\n        setString('] ' + (-NumberXSquaredCoefficient_B - 1) + 'x^2 [');\n    }\n    else {\n        setString('[ ' + (NumberXSquaredCoefficient_B + 1) + 'x^2 ]');\n    }\n}\nsetFontSize(20);\nsetCenterX( phet.paperLand.utils.paperToBoardX( PositionForXSquaredTiles_B.x, sharedData.displaySize.width ))\nsetCenterY( phet.paperLand.utils.paperToBoardY( PositionForXSquaredTiles_B.y, sharedData.displaySize.height ))\nphet.paperLand.console.log( phet.paperLand.utils.paperToBoardX( PositionForXSquaredTiles_B.x, sharedData.displaySize.width ));",
            "lazyLink": false,
            "defaultViewOptions": {
              "centerX": 0.5,
              "centerY": 0.5,
              "scale": 1,
              "rotation": 0,
              "opacity": 1,
              "visible": true,
              "viewUnits": "model"
            }
          }
        ],
        "shapeViews": [],
        "backgroundViews": [],
        "imageViews": []
      },
      "listenerContainer": {
        "linkListeners": [
          {
            "name": "ControllerBooleanLeftSideForXSquared_B",
            "controlledPropertyNames": [
              "BooleanOnLeftSideForXSquared_B"
            ],
            "controlFunctionString": "setBooleanOnLeftSideForXSquared_B(BoundsLeftSideOfEquals.containsPoint( PositionForXSquaredTiles_B )); ",
            "dependencyNames": [
              "BoundsLeftSideOfEquals",
              "PositionForXSquaredTiles_B"
            ],
            "referenceComponentNames": []
          }
        ],
        "animationListeners": [],
        "bluetoothListeners": []
      },
      "customCodeContainer": {
        "onProgramAddedCode": "// Setting program data to the program for some sound design.\r\nphet.paperLand.setProgramData( paperNumber, 'term', 'xSquared' );\r\n\r\n// Using addModelObserver lets us add the tiles/bounds programs in any order\r\nscratchpad.observerId = phet.paperLand.addModelObserver(\r\n  'tileData', // the bounds program will create this array when it is added\r\n  tileData => {\r\n\r\n    // as soon as the array is available, add this tile to it\r\n    scratchpad.thisTileData = {\r\n      onLeftSideProperty: phet.paperLand.getModelComponent( 'BooleanOnLeftSideForXSquared_B' ),\r\n      negativeProperty: phet.paperLand.getModelComponent( 'BooleanNegativeForXSquared_B' ),\r\n      countProperty: phet.paperLand.getModelComponent( 'NumberXSquaredCoefficient_B' ),\r\n      term: 'xSquared'\r\n    }\r\n    tileData.push( scratchpad.thisTileData );\r\n  },\r\n  tileData => {\r\n\r\n    // Remove this tile from the array when the array is being removed\r\n    const index = tileData.indexOf( scratchpad.thisTileData );\r\n    if ( index > -1 ) {\r\n        tileData.splice( index, 1 );\r\n        delete scratchpad.tileData;\r\n    }\r\n  }\r\n);",
        "onProgramRemovedCode": "// Removes the term data from the model\r\nphet.paperLand.removeProgramData( paperNumber, 'term' );\r\n\r\nconst tileData = phet.paperLand.getModelComponent( 'tileData' );\r\nif ( tileData ) {\r\n\r\n    // Remove the tile from the array\r\n    const index = tileData.indexOf( scratchpad.thisTileData );\r\n    if ( index > -1 ) {\r\n        tileData.splice( index, 1 );\r\n        delete scratchpad.tileData;        \r\n    }\r\n}\r\n\r\n// remove the model observer\r\nphet.paperLand.removeModelObserver( 'tileData', scratchpad.observerId );\r\ndelete scratchpad.observerId;",
        "onProgramChangedPositionCode": "",
        "onProgramMarkersAddedCode": "",
        "onProgramMarkersRemovedCode": "",
        "onProgramMarkersChangedPositionCode": "",
        "onProgramAdjacentCode": "",
        "onProgramSeparatedCode": ""
      }
    },
    {
      "number": 351,
      "title": "x Squared Tiles C",
      "keywords": "TacTiles, algebra, voicing, x^2, x, squared, x-squared",
      "description": "A program that voices the number of x-squared tiles (the coefficient of x-squared) and increments and decrements the coefficient using markers.  Note that current model range is 0-9, voicing strings range from x squared to 10x^2.",
      "expanded": false,
      "topWhiskerLength": 0.05,
      "rightWhiskerLength": 0.05,
      "bottomWhiskerLength": 0.05,
      "leftWhiskerLength": 0.05,
      "positionProperty": {
        "x": 487.6493804401443,
        "y": 286.4335420767561
      },
      "modelContainer": {
        "namedBooleanProperties": [
          {
            "name": "BooleanOnLeftSideForXSquared_C",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          },
          {
            "name": "BooleanNegativeForXSquared_C",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          }
        ],
        "namedVector2Properties": [
          {
            "name": "PositionForXSquaredTiles_C",
            "propertyType": "Vector2Property",
            "defaultX": 0,
            "defaultY": 0
          }
        ],
        "namedNumberProperties": [
          {
            "name": "NumberXSquaredCoefficient_C",
            "propertyType": "NumberProperty",
            "min": "0",
            "max": "9",
            "defaultValue": "0"
          }
        ],
        "namedEnumerationProperties": [],
        "namedDerivedProperties": [],
        "namedBounds2Properties": [],
        "namedObservableArrays": [],
        "namedArrayItems": [],
        "namedArrayItemReferences": [],
        "namedStringProperties": []
      },
      "controllerContainer": {
        "vector2PropertyControllers": [
          {
            "name": "ControllerPositionForXSquared_C",
            "controlledComponentName": "PositionForXSquaredTiles_C",
            "controlType": "MATCH_CENTER",
            "controlTypeFamily": ""
          }
        ],
        "boundsPropertyControllers": [],
        "booleanPropertyControllers": [
          {
            "name": "ControllerBooleanNegativeForXSquared_C",
            "controlledComponentName": "BooleanNegativeForXSquared_C",
            "controlType": "ROTATION",
            "controlTypeFamily": "",
            "whiskerConfiguration": {
              "topLength": 0.2,
              "rightLength": 0.2,
              "bottomLength": 0.2,
              "leftLength": 0.2,
              "otherPaperNumber": null
            },
            "markerColor": ""
          }
        ],
        "numberPropertyControllers": [
          {
            "name": "ControllerXSquareCoefficient_C",
            "controlledComponentName": "NumberXSquaredCoefficient_C",
            "controlType": "MARKER_COUNT",
            "controlTypeFamily": "MARKERS",
            "markerColor": "all",
            "relationshipControlType": null
          }
        ],
        "enumerationPropertyControllers": []
      },
      "viewContainer": {
        "soundViews": [],
        "speechViews": [
          {
            "name": "ViewNumberOfXSquared_C",
            "modelComponentNames": [
              "BooleanNegativeForXSquared_C",
              "NumberXSquaredCoefficient_C"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "phet.paperLand.console.log(NumberXSquaredCoefficient_C);\nif (Math.floor(NumberXSquaredCoefficient_C) === 0) {\n // A paper with no markers represents 1x^2 or -1x^2 and \n // in the case of 1x^2 the coefficient does not need to be voiced.\nif (BooleanNegativeForXSquared_C) {\n        speak( 'minus x squared' );\n    }\n    else {\n        speak( 'x squared' );\n    }\n} else {\n    if (BooleanNegativeForXSquared_C) {\n        speak( -Math.floor(NumberXSquaredCoefficient_C) - 1 + 'x squared' );\n    }\n    else {\n        speak( Math.floor(NumberXSquaredCoefficient_C) + 1 + 'x squared' );\n    }\n}",
            "lazyLink": false
          }
        ],
        "textViews": [
          {
            "name": "ViewTextTilesForXSquared_C",
            "modelComponentNames": [
              "BooleanNegativeForXSquared_C",
              "PositionForXSquaredTiles_C",
              "NumberXSquaredCoefficient_C"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "//\n//if (BooleanNegativeForXSquared_C) {\n//    setString('] ' + (-NumberXSquaredCoefficient_C - 1) + 'x^2 [');\n //   }\n //   else {\n//        setString('[ ' + (NumberXSquaredCoefficient_C + 1) + 'x^2 ]');\n //   }\n if (Math.floor(NumberXSquaredCoefficient_C) === 0) {\n    if (BooleanNegativeForXSquared_C) {\n        setString('] ' + '-x^2 [');\n    }\n    else {\n        setString('[ ' + 'x^2  ]');\n    }\n} \nelse {\n    if (BooleanNegativeForXSquared_C) {\n        setString('] ' + (-NumberXSquaredCoefficient_C - 1) + 'x^2 [');\n    }\n    else {\n        setString('[ ' + (NumberXSquaredCoefficient_C + 1) + 'x^2 ]');\n    }\n}\nsetFontSize(20);\nsetCenterX( phet.paperLand.utils.paperToBoardX( PositionForXSquaredTiles_C.x, sharedData.displaySize.width ))\nsetCenterY( phet.paperLand.utils.paperToBoardY( PositionForXSquaredTiles_C.y, sharedData.displaySize.height ))\nphet.paperLand.console.log( phet.paperLand.utils.paperToBoardX( PositionForXSquaredTiles_C.x, sharedData.displaySize.width ));",
            "lazyLink": false,
            "defaultViewOptions": {
              "centerX": 0.5,
              "centerY": 0.5,
              "scale": 1,
              "rotation": 0,
              "opacity": 1,
              "visible": true,
              "viewUnits": "model"
            }
          }
        ],
        "shapeViews": [],
        "backgroundViews": [],
        "imageViews": []
      },
      "listenerContainer": {
        "linkListeners": [
          {
            "name": "ControllerBooleanLeftSideForXSquared_C",
            "controlledPropertyNames": [
              "BooleanOnLeftSideForXSquared_C"
            ],
            "controlFunctionString": "setBooleanOnLeftSideForXSquared_C(BoundsLeftSideOfEquals.containsPoint( PositionForXSquaredTiles_C )); ",
            "dependencyNames": [
              "BoundsLeftSideOfEquals",
              "PositionForXSquaredTiles_C"
            ],
            "referenceComponentNames": []
          }
        ],
        "animationListeners": [],
        "bluetoothListeners": []
      },
      "customCodeContainer": {
        "onProgramAddedCode": "// Setting program data to the program for some sound design.\r\nphet.paperLand.setProgramData( paperNumber, 'term', 'xSquared' );\r\n\r\n// Using addModelObserver lets us add the tiles/bounds programs in any order\r\nscratchpad.observerId = phet.paperLand.addModelObserver(\r\n  'tileData', // the bounds program will create this array when it is added\r\n  tileData => {\r\n\r\n    // as soon as the array is available, add this tile to it\r\n    scratchpad.thisTileData = {\r\n      onLeftSideProperty: phet.paperLand.getModelComponent( 'BooleanOnLeftSideForXSquared_C' ),\r\n      negativeProperty: phet.paperLand.getModelComponent( 'BooleanNegativeForXSquared_C' ),\r\n      countProperty: phet.paperLand.getModelComponent( 'NumberXSquaredCoefficient_C' ),\r\n      term: 'xSquared'\r\n    }\r\n    tileData.push( scratchpad.thisTileData );\r\n  },\r\n  tileData => {\r\n\r\n    // Remove this tile from the array when the array is being removed\r\n    const index = tileData.indexOf( scratchpad.thisTileData );\r\n    if ( index > -1 ) {\r\n        tileData.splice( index, 1 );\r\n        delete scratchpad.tileData;\r\n    }\r\n  }\r\n);",
        "onProgramRemovedCode": "// Removes the term data from the model\r\nphet.paperLand.removeProgramData( paperNumber, 'term' );\r\n\r\nconst tileData = phet.paperLand.getModelComponent( 'tileData' );\r\nif ( tileData ) {\r\n\r\n    // Remove the tile from the array\r\n    const index = tileData.indexOf( scratchpad.thisTileData );\r\n    if ( index > -1 ) {\r\n        tileData.splice( index, 1 );\r\n        delete scratchpad.tileData;        \r\n    }\r\n}\r\n\r\n// remove the model observer\r\nphet.paperLand.removeModelObserver( 'tileData', scratchpad.observerId );\r\ndelete scratchpad.observerId;",
        "onProgramChangedPositionCode": "",
        "onProgramMarkersAddedCode": "",
        "onProgramMarkersRemovedCode": "",
        "onProgramMarkersChangedPositionCode": "",
        "onProgramAdjacentCode": "",
        "onProgramSeparatedCode": ""
      }
    },
    {
      "number": 1014,
      "title": "x Squared Tiles D",
      "keywords": "TacTiles, algebra, voicing, x^2, x, squared, x-squared",
      "description": "A program that voices the number of x-squared tiles (the coefficient of x-squared) and increments and decrements the coefficient using markers.  Note that current model range is 0-9, voicing strings range from x squared to 10x^2.",
      "expanded": false,
      "topWhiskerLength": 0.05,
      "rightWhiskerLength": 0.05,
      "bottomWhiskerLength": 0.05,
      "leftWhiskerLength": 0.05,
      "positionProperty": {
        "x": 511.768998336275,
        "y": 270.2089970314878
      },
      "modelContainer": {
        "namedBooleanProperties": [
          {
            "name": "BooleanOnLeftSideForXSquared_D",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          },
          {
            "name": "BooleanNegativeForXSquared_D",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          }
        ],
        "namedVector2Properties": [
          {
            "name": "PositionForXSquaredTiles_D",
            "propertyType": "Vector2Property",
            "defaultX": 0,
            "defaultY": 0
          }
        ],
        "namedNumberProperties": [
          {
            "name": "NumberXSquaredCoefficient_D",
            "propertyType": "NumberProperty",
            "min": "0",
            "max": "9",
            "defaultValue": "0"
          }
        ],
        "namedEnumerationProperties": [],
        "namedDerivedProperties": [],
        "namedBounds2Properties": [],
        "namedObservableArrays": [],
        "namedArrayItems": [],
        "namedArrayItemReferences": [],
        "namedStringProperties": []
      },
      "controllerContainer": {
        "vector2PropertyControllers": [
          {
            "name": "ControllerPositionForXSquared_D",
            "controlledComponentName": "PositionForXSquaredTiles_D",
            "controlType": "MATCH_CENTER",
            "controlTypeFamily": ""
          }
        ],
        "boundsPropertyControllers": [],
        "booleanPropertyControllers": [
          {
            "name": "ControllerBooleanNegativeForXSquared_D",
            "controlledComponentName": "BooleanNegativeForXSquared_D",
            "controlType": "ROTATION",
            "controlTypeFamily": "",
            "whiskerConfiguration": {
              "topLength": 0.2,
              "rightLength": 0.2,
              "bottomLength": 0.2,
              "leftLength": 0.2,
              "otherPaperNumber": null
            },
            "markerColor": ""
          }
        ],
        "numberPropertyControllers": [
          {
            "name": "ControllerXSquareCoefficient_D",
            "controlledComponentName": "NumberXSquaredCoefficient_D",
            "controlType": "MARKER_COUNT",
            "controlTypeFamily": "MARKERS",
            "markerColor": "all",
            "relationshipControlType": null
          }
        ],
        "enumerationPropertyControllers": []
      },
      "viewContainer": {
        "soundViews": [],
        "speechViews": [
          {
            "name": "ViewNumberOfXSquared_D",
            "modelComponentNames": [
              "BooleanNegativeForXSquared_D",
              "NumberXSquaredCoefficient_D"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "phet.paperLand.console.log(NumberXSquaredCoefficient_D);\nif (Math.floor(NumberXSquaredCoefficient_D) === 0) {\n // A paper with no markers represents 1x^2 or -1x^2 and \n // in the case of 1x^2 the coefficient does not need to be voiced.\nif (BooleanNegativeForXSquared_D) {\n        speak( 'minus x squared' );\n    }\n    else {\n        speak( 'x squared' );\n    }\n} else {\n    if (BooleanNegativeForXSquared_D) {\n        speak( -Math.floor(NumberXSquaredCoefficient_D) - 1 + 'x squared' );\n    }\n    else {\n        speak( Math.floor(NumberXSquaredCoefficient_D) + 1 + 'x squared' );\n    }\n}",
            "lazyLink": false
          }
        ],
        "textViews": [
          {
            "name": "ViewTextTilesForXSquared_D",
            "modelComponentNames": [
              "BooleanNegativeForXSquared_D",
              "PositionForXSquaredTiles_D",
              "NumberXSquaredCoefficient_D"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "//\n//if (BooleanNegativeForXSquared_D) {\n//    setString('] ' + (-NumberXSquaredCoefficient_D - 1) + 'x^2 [');\n //   }\n //   else {\n//        setString('[ ' + (NumberXSquaredCoefficient_D + 1) + 'x^2 ]');\n //   }\n if (Math.floor(NumberXSquaredCoefficient_D) === 0) {\n    if (BooleanNegativeForXSquared_D) {\n        setString('] ' + '-x^2 [');\n    }\n    else {\n        setString('[ ' + 'x^2  ]');\n    }\n} \nelse {\n    if (BooleanNegativeForXSquared_D) {\n        setString('] ' + (-NumberXSquaredCoefficient_D - 1) + 'x^2 [');\n    }\n    else {\n        setString('[ ' + (NumberXSquaredCoefficient_D + 1) + 'x^2 ]');\n    }\n}\nsetFontSize(20);\nsetCenterX( phet.paperLand.utils.paperToBoardX( PositionForXSquaredTiles_D.x, sharedData.displaySize.width ))\nsetCenterY( phet.paperLand.utils.paperToBoardY( PositionForXSquaredTiles_D.y, sharedData.displaySize.height ))\nphet.paperLand.console.log( phet.paperLand.utils.paperToBoardX( PositionForXSquaredTiles_D.x, sharedData.displaySize.width ));",
            "lazyLink": false,
            "defaultViewOptions": {
              "centerX": 0.5,
              "centerY": 0.5,
              "scale": 1,
              "rotation": 0,
              "opacity": 1,
              "visible": true,
              "viewUnits": "model"
            }
          }
        ],
        "shapeViews": [],
        "backgroundViews": [],
        "imageViews": []
      },
      "listenerContainer": {
        "linkListeners": [
          {
            "name": "ControllerBooleanLeftSideForXSquared_D",
            "controlledPropertyNames": [
              "BooleanOnLeftSideForXSquared_D"
            ],
            "controlFunctionString": "setBooleanOnLeftSideForXSquared_D(BoundsLeftSideOfEquals.containsPoint( PositionForXSquaredTiles_D )); ",
            "dependencyNames": [
              "BoundsLeftSideOfEquals",
              "PositionForXSquaredTiles_D"
            ],
            "referenceComponentNames": []
          }
        ],
        "animationListeners": [],
        "bluetoothListeners": []
      },
      "customCodeContainer": {
        "onProgramAddedCode": "// Setting program data to the program for some sound design.\r\nphet.paperLand.setProgramData( paperNumber, 'term', 'xSquared' );\r\n\r\n// Using addModelObserver lets us add the tiles/bounds programs in any order\r\nscratchpad.observerId = phet.paperLand.addModelObserver(\r\n  'tileData', // the bounds program will create this array when it is added\r\n  tileData => {\r\n\r\n    // as soon as the array is available, add this tile to it\r\n    scratchpad.thisTileData = {\r\n      onLeftSideProperty: phet.paperLand.getModelComponent( 'BooleanOnLeftSideForXSquared_D' ),\r\n      negativeProperty: phet.paperLand.getModelComponent( 'BooleanNegativeForXSquared_D' ),\r\n      countProperty: phet.paperLand.getModelComponent( 'NumberXSquaredCoefficient_D' ),\r\n      term: 'xSquared'\r\n    }\r\n    tileData.push( scratchpad.thisTileData );\r\n  },\r\n  tileData => {\r\n\r\n    // Remove this tile from the array when the array is being removed\r\n    const index = tileData.indexOf( scratchpad.thisTileData );\r\n    if ( index > -1 ) {\r\n        tileData.splice( index, 1 );\r\n        delete scratchpad.tileData;\r\n    }\r\n  }\r\n);",
        "onProgramRemovedCode": "// Removes the term data from the model\r\nphet.paperLand.removeProgramData( paperNumber, 'term' );\r\n\r\nconst tileData = phet.paperLand.getModelComponent( 'tileData' );\r\nif ( tileData ) {\r\n\r\n    // Remove the tile from the array\r\n    const index = tileData.indexOf( scratchpad.thisTileData );\r\n    if ( index > -1 ) {\r\n        tileData.splice( index, 1 );\r\n        delete scratchpad.tileData;        \r\n    }\r\n}\r\n\r\n// remove the model observer\r\nphet.paperLand.removeModelObserver( 'tileData', scratchpad.observerId );\r\ndelete scratchpad.observerId;",
        "onProgramChangedPositionCode": "",
        "onProgramMarkersAddedCode": "",
        "onProgramMarkersRemovedCode": "",
        "onProgramMarkersChangedPositionCode": "",
        "onProgramAdjacentCode": "",
        "onProgramSeparatedCode": ""
      }
    },
    {
      "number": 1389,
      "title": "x Squared Tiles E",
      "keywords": "TacTiles, algebra, voicing, x^2, x, squared, x-squared",
      "description": "A program that voices the number of x-squared tiles (the coefficient of x-squared) and increments and decrements the coefficient using markers.  Note that current model range is 0-9, voicing strings range from x squared to 10x^2.",
      "expanded": false,
      "topWhiskerLength": 0.05,
      "rightWhiskerLength": 0.05,
      "bottomWhiskerLength": 0.05,
      "leftWhiskerLength": 0.05,
      "positionProperty": {
        "x": 480.224301195377,
        "y": 308.484648232802
      },
      "modelContainer": {
        "namedBooleanProperties": [
          {
            "name": "BooleanOnLeftSideForXSquared_E",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          },
          {
            "name": "BooleanNegativeForXSquared_E",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          }
        ],
        "namedVector2Properties": [
          {
            "name": "PositionForXSquaredTiles_E",
            "propertyType": "Vector2Property",
            "defaultX": 0,
            "defaultY": 0
          }
        ],
        "namedNumberProperties": [
          {
            "name": "NumberXSquaredCoefficient_E",
            "propertyType": "NumberProperty",
            "min": "0",
            "max": "9",
            "defaultValue": "0"
          }
        ],
        "namedEnumerationProperties": [],
        "namedDerivedProperties": [],
        "namedBounds2Properties": [],
        "namedObservableArrays": [],
        "namedArrayItems": [],
        "namedArrayItemReferences": [],
        "namedStringProperties": []
      },
      "controllerContainer": {
        "vector2PropertyControllers": [
          {
            "name": "ControllerPositionForXSquared_E",
            "controlledComponentName": "PositionForXSquaredTiles_E",
            "controlType": "MATCH_CENTER",
            "controlTypeFamily": ""
          }
        ],
        "boundsPropertyControllers": [],
        "booleanPropertyControllers": [
          {
            "name": "ControllerBooleanNegativeForXSquared_E",
            "controlledComponentName": "BooleanNegativeForXSquared_E",
            "controlType": "ROTATION",
            "controlTypeFamily": "",
            "whiskerConfiguration": {
              "topLength": 0.2,
              "rightLength": 0.2,
              "bottomLength": 0.2,
              "leftLength": 0.2,
              "otherPaperNumber": null
            },
            "markerColor": ""
          }
        ],
        "numberPropertyControllers": [
          {
            "name": "ControllerXSquareCoefficient_E",
            "controlledComponentName": "NumberXSquaredCoefficient_E",
            "controlType": "MARKER_COUNT",
            "controlTypeFamily": "MARKERS",
            "markerColor": "all",
            "relationshipControlType": null
          }
        ],
        "enumerationPropertyControllers": []
      },
      "viewContainer": {
        "soundViews": [],
        "speechViews": [
          {
            "name": "ViewNumberOfXSquared_E",
            "modelComponentNames": [
              "BooleanNegativeForXSquared_E",
              "NumberXSquaredCoefficient_E"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "phet.paperLand.console.log(NumberXSquaredCoefficient_E);\nif (Math.floor(NumberXSquaredCoefficient_E) === 0) {\n // A paper with no markers represents 1x^2 or -1x^2 and \n // in the case of 1x^2 the coefficient does not need to be voiced.\nif (BooleanNegativeForXSquared_E) {\n        speak( 'minus x squared' );\n    }\n    else {\n        speak( 'x squared' );\n    }\n} else {\n    if (BooleanNegativeForXSquared_E) {\n        speak( -Math.floor(NumberXSquaredCoefficient_E) - 1 + 'x squared' );\n    }\n    else {\n        speak( Math.floor(NumberXSquaredCoefficient_E) + 1 + 'x squared' );\n    }\n}",
            "lazyLink": false
          }
        ],
        "textViews": [
          {
            "name": "ViewTextTilesForXSquared_E",
            "modelComponentNames": [
              "BooleanNegativeForXSquared_E",
              "PositionForXSquaredTiles_E",
              "NumberXSquaredCoefficient_E"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "//\n//if (BooleanNegativeForXSquared_E) {\n//    setString('] ' + (-NumberXSquaredCoefficient_E - 1) + 'x^2 [');\n //   }\n //   else {\n//        setString('[ ' + (NumberXSquaredCoefficient_E + 1) + 'x^2 ]');\n //   }\n if (Math.floor(NumberXSquaredCoefficient_E) === 0) {\n    if (BooleanNegativeForXSquared_E) {\n        setString('] ' + '-x^2 [');\n    }\n    else {\n        setString('[ ' + 'x^2  ]');\n    }\n} \nelse {\n    if (BooleanNegativeForXSquared_E) {\n        setString('] ' + (-NumberXSquaredCoefficient_E - 1) + 'x^2 [');\n    }\n    else {\n        setString('[ ' + (NumberXSquaredCoefficient_E + 1) + 'x^2 ]');\n    }\n}\nsetFontSize(20);\nsetCenterX( phet.paperLand.utils.paperToBoardX( PositionForXSquaredTiles_E.x, sharedData.displaySize.width ))\nsetCenterY( phet.paperLand.utils.paperToBoardY( PositionForXSquaredTiles_E.y, sharedData.displaySize.height ))\nphet.paperLand.console.log( phet.paperLand.utils.paperToBoardX( PositionForXSquaredTiles_E.x, sharedData.displaySize.width ));",
            "lazyLink": false,
            "defaultViewOptions": {
              "centerX": 0.5,
              "centerY": 0.5,
              "scale": 1,
              "rotation": 0,
              "opacity": 1,
              "visible": true,
              "viewUnits": "model"
            }
          }
        ],
        "shapeViews": [],
        "backgroundViews": [],
        "imageViews": []
      },
      "listenerContainer": {
        "linkListeners": [
          {
            "name": "ControllerBooleanLeftSideForXSquared_E",
            "controlledPropertyNames": [
              "BooleanOnLeftSideForXSquared_E"
            ],
            "controlFunctionString": "setBooleanOnLeftSideForXSquared_E(BoundsLeftSideOfEquals.containsPoint( PositionForXSquaredTiles_E )); ",
            "dependencyNames": [
              "BoundsLeftSideOfEquals",
              "PositionForXSquaredTiles_E"
            ],
            "referenceComponentNames": []
          }
        ],
        "animationListeners": [],
        "bluetoothListeners": []
      },
      "customCodeContainer": {
        "onProgramAddedCode": "// Setting program data to the program for some sound design.\r\nphet.paperLand.setProgramData( paperNumber, 'term', 'xSquared' );\r\n\r\n// Using addModelObserver lets us add the tiles/bounds programs in any order\r\nscratchpad.observerId = phet.paperLand.addModelObserver(\r\n  'tileData', // the bounds program will create this array when it is added\r\n  tileData => {\r\n\r\n    // as soon as the array is available, add this tile to it\r\n    scratchpad.thisTileData = {\r\n      onLeftSideProperty: phet.paperLand.getModelComponent( 'BooleanOnLeftSideForXSquared_E' ),\r\n      negativeProperty: phet.paperLand.getModelComponent( 'BooleanNegativeForXSquared_E' ),\r\n      countProperty: phet.paperLand.getModelComponent( 'NumberXSquaredCoefficient_E' ),\r\n      term: 'xSquared'\r\n    }\r\n    tileData.push( scratchpad.thisTileData );\r\n  },\r\n  tileData => {\r\n\r\n    // Remove this tile from the array when the array is being removed\r\n    const index = tileData.indexOf( scratchpad.thisTileData );\r\n    if ( index > -1 ) {\r\n        tileData.splice( index, 1 );\r\n        delete scratchpad.tileData;\r\n    }\r\n  }\r\n);",
        "onProgramRemovedCode": "// Removes the term data from the model\r\nphet.paperLand.removeProgramData( paperNumber, 'term' );\r\n\r\nconst tileData = phet.paperLand.getModelComponent( 'tileData' );\r\nif ( tileData ) {\r\n\r\n    // Remove the tile from the array\r\n    const index = tileData.indexOf( scratchpad.thisTileData );\r\n    if ( index > -1 ) {\r\n        tileData.splice( index, 1 );\r\n        delete scratchpad.tileData;        \r\n    }\r\n}\r\n\r\n// remove the model observer\r\nphet.paperLand.removeModelObserver( 'tileData', scratchpad.observerId );\r\ndelete scratchpad.observerId;",
        "onProgramChangedPositionCode": "",
        "onProgramMarkersAddedCode": "",
        "onProgramMarkersRemovedCode": "",
        "onProgramMarkersChangedPositionCode": "",
        "onProgramAdjacentCode": "",
        "onProgramSeparatedCode": ""
      }
    },
    {
      "number": 1561,
      "title": "X Tiles B",
      "keywords": "NumberXCoefficient",
      "description": "A program that voices the number of x-tiles (the coefficient of x) and increments and decrements the coefficient using markers.  Note that current model range for the coefficient is 0-9, voicing strings range from x to 10x.",
      "expanded": false,
      "topWhiskerLength": 0.05,
      "rightWhiskerLength": 0.05,
      "bottomWhiskerLength": 0.05,
      "leftWhiskerLength": 0.05,
      "positionProperty": {
        "x": 581.3908486944543,
        "y": 284.33678827839674
      },
      "modelContainer": {
        "namedBooleanProperties": [
          {
            "name": "BooleanOnLeftSideForX_B",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          },
          {
            "name": "BooleanNegativeForX_B",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          },
          {
            "name": "BooleanGoodConnectionForX_B",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          },
          {
            "name": "BooleanBadConnectionForX_B",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          }
        ],
        "namedVector2Properties": [
          {
            "name": "PositionForXTiles_B",
            "propertyType": "Vector2Property",
            "defaultX": 0,
            "defaultY": 0
          }
        ],
        "namedNumberProperties": [
          {
            "name": "NumberXCoefficient_B",
            "propertyType": "NumberProperty",
            "min": 0,
            "max": "9",
            "defaultValue": "0"
          },
          {
            "name": "TermForXTile_B",
            "propertyType": "NumberProperty",
            "min": 0,
            "max": "2",
            "defaultValue": "1"
          }
        ],
        "namedEnumerationProperties": [],
        "namedDerivedProperties": [],
        "namedBounds2Properties": [],
        "namedObservableArrays": [],
        "namedArrayItems": [
          {
            "name": "xTileData_B",
            "arrayName": "tileData",
            "itemSchema": [
              {
                "entryName": "negative",
                "componentName": "BooleanNegativeForX_B"
              },
              {
                "entryName": "onLeftSide",
                "componentName": "BooleanOnLeftSideForX_B"
              },
              {
                "entryName": "count",
                "componentName": "NumberXCoefficient_B"
              },
              {
                "entryName": "term",
                "componentName": "TermForXTile_B"
              }
            ]
          }
        ],
        "namedArrayItemReferences": [],
        "namedStringProperties": []
      },
      "controllerContainer": {
        "vector2PropertyControllers": [
          {
            "name": "ControllerPositionForX_B",
            "controlledComponentName": "PositionForXTiles_B",
            "controlType": "MATCH_CENTER",
            "controlTypeFamily": ""
          }
        ],
        "boundsPropertyControllers": [],
        "booleanPropertyControllers": [
          {
            "name": "ControllerBooleanNegativeForX_B",
            "controlledComponentName": "BooleanNegativeForX_B",
            "controlType": "ROTATION",
            "controlTypeFamily": "",
            "whiskerConfiguration": {
              "topLength": 0.2,
              "rightLength": 0.2,
              "bottomLength": 0.2,
              "leftLength": 0.2,
              "otherPaperNumber": null
            },
            "markerColor": ""
          }
        ],
        "numberPropertyControllers": [
          {
            "name": "ControllerXCoefficient_B",
            "controlledComponentName": "NumberXCoefficient_B",
            "controlType": "MARKER_COUNT",
            "controlTypeFamily": "MARKERS",
            "markerColor": "all",
            "relationshipControlType": null
          }
        ],
        "enumerationPropertyControllers": []
      },
      "viewContainer": {
        "soundViews": [
          {
            "name": "ViewGoodConnectionSoundForX_B",
            "modelComponentNames": [
              "RectangleModelMode",
              "BooleanGoodConnectionForX_B"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "if ( BooleanGoodConnectionForX_B && RectangleModelMode ) {\r\n    play();\r\n}",
            "lazyLink": false,
            "soundFileName": "/uploads/SuccessSound.mp3",
            "loop": false,
            "autoplay": false
          },
          {
            "name": "ViewBadConnectionSoundForX_B",
            "modelComponentNames": [
              "RectangleModelMode",
              "BooleanBadConnectionForX_B"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "if ( BooleanBadConnectionForX_B && RectangleModelMode ) {\n    play();\n}",
            "lazyLink": false,
            "soundFileName": "/uploads/OutOfBalanceSound.mp3",
            "loop": false,
            "autoplay": false
          }
        ],
        "speechViews": [
          {
            "name": "ViewNumberOfX_B",
            "modelComponentNames": [
              "BooleanNegativeForX_B",
              "NumberXCoefficient_B"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "// A paper with no markers represent a potential stack of tiles\n// Adding or removing markers increments or decrements\n// the number of tiles of that type\nphet.paperLand.console.log(NumberXCoefficient_B);\nif (Math.floor(NumberXCoefficient_B) !== 0) {\n   // Test for negative tile value\n   if (BooleanNegativeForX_B) {\n       speak( -Math.floor(NumberXCoefficient_B) + 'x' );\n   }\n   // else assume positive value\n   else {\n       speak( Math.floor(NumberXCoefficient_B) + 'x' );\n   }\n}\n",
            "lazyLink": false
          }
        ],
        "textViews": [
          {
            "name": "ViewTextTilesForXTiles_B",
            "modelComponentNames": [
              "BooleanNegativeForX_B",
              "PositionForXTiles_B",
              "NumberXCoefficient_B"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "if ( BooleanNegativeForX_B )  {\n    if ( NumberXCoefficient_B === 0 ) {\n        setString('Add negative X-tiles.'); // empty tile\n    }\n    else {\n        setString('] ' + (-NumberXCoefficient_B) +  'x [');\n    }\n}\nelse {\n    if ( NumberXCoefficient_B === 0 ) {\n        setString('Add X-tiles.'); // empty tile\n    }\n    else {\n        if (NumberXCoefficient_B === 1) {\n            setString('[ x ]');\n        }\n        else {\n            setString('[ ' + (NumberXCoefficient_B) + 'x ]');\n        }\n    }\n}\nsetFontSize(20);\nsetCenterX( phet.paperLand.utils.paperToBoardX( PositionForXTiles_B.x, sharedData.displaySize.width ))\nsetCenterY( phet.paperLand.utils.paperToBoardY( PositionForXTiles_B.y, sharedData.displaySize.height ))",
            "lazyLink": false,
            "defaultViewOptions": {
              "centerX": 0.5,
              "centerY": 0.5,
              "scale": 1,
              "rotation": 0,
              "opacity": 1,
              "visible": true,
              "viewUnits": "model"
            }
          }
        ],
        "shapeViews": [
          {
            "name": "XTilesShape_B",
            "modelComponentNames": [
              "BooleanOnLeftSideForX_B",
              "BooleanNegativeForX_B",
              "PositionForXTiles_B",
              "NumberXCoefficient_B"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "// Set the square to the desired size\n const rectangleHeight = 0.36\n const rectangleWidth = 0.1\n\nsetRectBounds( new phet.dot.Bounds2( 0, 0, rectangleWidth, rectangleHeight * sharedData.displaySize.width / sharedData.displaySize.height ) );\n\nsetVisible(Math.floor(NumberXCoefficient_B) !== 0)\nif (BooleanNegativeForX_B) {\n    // If negative make a frame tile\n    // setRectBounds( new phet.dot.Bounds2( 0, 0, squareWidth, squareWidth * sharedData.displaySize.width / sharedData.displaySize.height ) );\n    setStroke('#ff0000'); // red\n    setFill('transparent');\t\t// fill\n    setLineWidth(4); // pixels\n}\nelse {\n    // Else assume positive and make a tile: stroke, fill\n    // setRectBounds( new phet.dot.Bounds2( 0, 0, squareWidth, squareWidth * sharedData.displaySize.width / sharedData.displaySize.height ) );\n    setStroke('#ff0000');\t// red\n    setLineWidth(4);\t\t// pixels\n    setFill('#ff0000');\t\t// fill\n    setOpacity( 0.6 );      // make tile transparent\n    // moveToFront();\t\t\t// keep in background behind any text\n}\n\nsetCenterX(PositionForXTiles_B.x);\nsetCenterY(PositionForXTiles_B.y);\n",
            "lazyLink": false,
            "defaultViewOptions": {
              "centerX": 0.5,
              "centerY": 0.5,
              "scale": 1,
              "rotation": 0,
              "opacity": 1,
              "visible": true,
              "viewUnits": "model"
            },
            "defaultShapeOptions": {
              "shapeType": "rectangle",
              "fill": "lightblue",
              "stroke": "red",
              "lineWidth": 1,
              "rectWidth": 0.5,
              "rectHeight": 0.5,
              "circleRadius": 0.05,
              "ellipseRadiusX": 0.3,
              "ellipseRadiusY": 0.15,
              "lineStartX": 0,
              "lineStartY": 0,
              "lineEndX": 0.3,
              "lineEndY": 0.3,
              "triangleBaseWidth": 0.1,
              "triangleHeight": 0.3,
              "polygonPoints": [
                [
                  0,
                  0
                ],
                [
                  0.1,
                  0
                ],
                [
                  0.1,
                  0.1
                ],
                [
                  0,
                  0.1
                ]
              ]
            }
          }
        ],
        "backgroundViews": [],
        "imageViews": []
      },
      "listenerContainer": {
        "linkListeners": [
          {
            "name": "ControllerBooleanLeftSideForX_B",
            "controlledPropertyNames": [
              "BooleanOnLeftSideForX_B"
            ],
            "controlFunctionString": "// Uncomment to voice side of equation - What does this comment mean?\nsetBooleanOnLeftSideForX_B(BoundsLeftSideOfEquals.containsPoint( PositionForXTiles_B )); \n\n",
            "dependencyNames": [
              "BoundsLeftSideOfEquals",
              "PositionForXTiles_B"
            ],
            "referenceComponentNames": []
          }
        ],
        "animationListeners": [],
        "bluetoothListeners": []
      },
      "customCodeContainer": {
        "onProgramAddedCode": "// Setting program data to the program for some sound design.\r\nphet.paperLand.setProgramData( paperNumber, 'term', 'x' );\r\n\r\n",
        "onProgramRemovedCode": "// Removes the term data from the model\r\nphet.paperLand.removeProgramData( paperNumber, 'term' );\r\n\r\n",
        "onProgramChangedPositionCode": "",
        "onProgramMarkersAddedCode": "",
        "onProgramMarkersRemovedCode": "",
        "onProgramMarkersChangedPositionCode": "",
        "onProgramAdjacentCode": "\n// Get a reference to the model component and only update it if it exists.\nconst goodConnectionComponent = phet.paperLand.getModelComponent( 'BooleanGoodConnectionForX_B' );\nconst badConnectionComponent = phet.paperLand.getModelComponent( 'BooleanBadConnectionForX_B' );\n\n\nif ( goodConnectionComponent && badConnectionComponent ) {\n\n    // If this is the left or right whisker...\n    if ( direction === 'left' || direction === 'right' ) {\n\n        // These are the terms that this program is allowed to connect to.\n        const goodConnectionTerms = [ 'xSquared' ];\n       \n        // These are the terms that this program is NOT allowed to connect to.\n        const badConnectionTerms = [ 'ones' ];\n\n        // This connection is \"good\" if the other program has a term in the good list\n        goodConnectionComponent.value = goodConnectionTerms.includes(\n\n            // get the term from the other program\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\n        );\n        // This connection is \"bad\" if the other program has a term in the bad list\n        badConnectionComponent.value = badConnectionTerms.includes(\n\n            // get the term from the other program\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\n        );\n    }\n\n    phet.paperLand.console.log( direction );\n\n    // If this is the top or bottom whisker...\n    if ( direction === 'top' || direction === 'bottom' ) {\n        \n        // These are the terms that this program is allowed to connect to.\n        const goodConnectionTerms = [ 'ones' ];\n       \n        // These are the terms that this program is NOT allowed to connect to.\n        const badConnectionTerms = [ 'xSquared' ];\n\n        // This connection is \"good\" if the other program has a term in the good list\n        goodConnectionComponent.value = goodConnectionTerms.includes(\n\n            // get the term from the other program\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\n        );\n        // This connection is \"bad\" if the other program has a term in the bad list\n        badConnectionComponent.value = badConnectionTerms.includes(\n\n            // get the term from the other program\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\n        );\n    }\n}",
        "onProgramSeparatedCode": "\r\n// Get a reference to the model component and only update it if it exists.\r\nconst goodConnectionComponent = phet.paperLand.getModelComponent( 'BooleanGoodConnectionForX_B' );\r\nconst badConnectionComponent = phet.paperLand.getModelComponent( 'BooleanBadConnectionForX_B' );\r\n\r\n// Components must exit check\r\nif ( goodConnectionComponent && badConnectionComponent )  {\r\n\r\n    // If this is the left or right whisker...\r\n    if ( direction === 'left' || direction === 'right' ) {\r\n\r\n        // These are the terms that this program is allowed to connect to.\r\n        const goodConnectionTerms = [ 'xSquared' ];\r\n\r\n         // These are the terms that this program is NOT allowed to connect to.\r\n        const badConnectionTerms = [ 'ones' ];\r\n\r\n        // If detatching from another program where connection is \"good\",\r\n        // the connection is no longer there.\r\n        if ( goodConnectionTerms.includes(\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        ) ) {\r\n            goodConnectionComponent.value = false;\r\n        }\r\n        // If detatching from another program where connection is \"bad\",\r\n        // the connection is no longer there.\r\n        if ( badConnectionTerms.includes(\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        ) ) {\r\n            badConnectionComponent.value = false;\r\n        }\r\n    }\r\n\r\n    // If this is the top or bottom whisker...\r\n    if ( direction === 'top' || direction === 'bottom' ) {\r\n\r\n       // These are the terms that this program is allowed to connect to.\r\n       // TODO: Need to add top and bottom of X tiles\r\n        const goodConnectionTerms = [ 'ones' ];\r\n\r\n         // These are the terms that this program is NOT allowed to connect to.\r\n        // TODO: Need to add left and right of X tiles\r\n        const badConnectionTerms = [ 'xSquared' ];\r\n\r\n        // If detatching from another program where connection is \"good\",\r\n        // the connection is no longer there.\r\n        if ( goodConnectionTerms.includes(\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        ) ) {\r\n            goodConnectionComponent.value = false;\r\n        }\r\n        // If detatching from another program where connection is \"bad\",\r\n        // the connection is no longer there.\r\n        if ( badConnectionTerms.includes(\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        ) ) {\r\n            badConnectionComponent.value = false;\r\n        }\r\n    }\r\n}"
      }
    },
    {
      "number": 210,
      "title": "Ones Tiles A",
      "keywords": "TacTiles, algebra, voicing, ones, one, numbers",
      "description": "A program that voices the number of one-tiles and increments and decrements the number of ones using markers. Note that current model range is 0-9, and the voicing strings range from 1-10.",
      "expanded": false,
      "topWhiskerLength": 0.05,
      "rightWhiskerLength": 0.05,
      "bottomWhiskerLength": 0.05,
      "leftWhiskerLength": 0.05,
      "positionProperty": {
        "x": 617,
        "y": 356.79460896690847
      },
      "modelContainer": {
        "namedBooleanProperties": [
          {
            "name": "BooleanOnLeftSideForOnes_A",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          },
          {
            "name": "BooleanNegativeForOnes_A",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          },
          {
            "name": "BooleanGoodConnectionForOnes_A",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          },
          {
            "name": "BooleanBadConnectionForOnes_A",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          }
        ],
        "namedVector2Properties": [
          {
            "name": "PositionForOnesTiles_A",
            "propertyType": "Vector2Property",
            "defaultX": 0,
            "defaultY": 0
          }
        ],
        "namedNumberProperties": [
          {
            "name": "NumberOfOnes_A",
            "propertyType": "NumberProperty",
            "min": 0,
            "max": "9",
            "defaultValue": "0"
          },
          {
            "name": "TermForOnesTile_A",
            "propertyType": "NumberProperty",
            "min": 0,
            "max": "2",
            "defaultValue": "0"
          }
        ],
        "namedEnumerationProperties": [],
        "namedDerivedProperties": [],
        "namedBounds2Properties": [],
        "namedObservableArrays": [],
        "namedArrayItems": [
          {
            "name": "onesTileData_A",
            "arrayName": "tileData",
            "itemSchema": [
              {
                "entryName": "onLeftSide",
                "componentName": "BooleanOnLeftSideForOnes_A"
              },
              {
                "entryName": "negative",
                "componentName": "BooleanNegativeForOnes_A"
              },
              {
                "entryName": "count",
                "componentName": "NumberOfOnes_A"
              },
              {
                "entryName": "term",
                "componentName": "TermForOnesTile_A"
              }
            ]
          }
        ],
        "namedArrayItemReferences": [],
        "namedStringProperties": []
      },
      "controllerContainer": {
        "vector2PropertyControllers": [
          {
            "name": "ControllerPositionForOnes_A",
            "controlledComponentName": "PositionForOnesTiles_A",
            "controlType": "MATCH_CENTER",
            "controlTypeFamily": ""
          }
        ],
        "boundsPropertyControllers": [],
        "booleanPropertyControllers": [
          {
            "name": "ControllerBooleanNegativeForOnes_A",
            "controlledComponentName": "BooleanNegativeForOnes_A",
            "controlType": "ROTATION",
            "controlTypeFamily": "",
            "whiskerConfiguration": {
              "topLength": 0.2,
              "rightLength": 0.2,
              "bottomLength": 0.2,
              "leftLength": 0.2,
              "otherPaperNumber": null
            },
            "markerColor": ""
          }
        ],
        "numberPropertyControllers": [
          {
            "name": "ControllerForOnes_A",
            "controlledComponentName": "NumberOfOnes_A",
            "controlType": "MARKER_COUNT",
            "controlTypeFamily": "MARKERS",
            "markerColor": "all",
            "relationshipControlType": null
          }
        ],
        "enumerationPropertyControllers": []
      },
      "viewContainer": {
        "soundViews": [
          {
            "name": "ViewGoodConnectionSoundForOnes_A",
            "modelComponentNames": [
              "RectangleModelMode",
              "BooleanGoodConnectionForOnes_A"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "if ( BooleanGoodConnectionForOnes_A && RectangleModelMode ) {\r\n    play();\r\n}",
            "lazyLink": false,
            "soundFileName": "/uploads/SuccessSound.mp3",
            "loop": false,
            "autoplay": false
          },
          {
            "name": "ViewBadConnectionSoundForOnes_A",
            "modelComponentNames": [
              "RectangleModelMode",
              "BooleanBadConnectionForOnes_A"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "if ( BooleanBadConnectionForOnes_A && RectangleModelMode) {\r\n    play();\r\n}",
            "lazyLink": false,
            "soundFileName": "/uploads/OutOfBalanceSound.mp3",
            "loop": false,
            "autoplay": false
          }
        ],
        "speechViews": [
          {
            "name": "ViewNumberOfOnes_A",
            "modelComponentNames": [
              "BooleanNegativeForOnes_A",
              "NumberOfOnes_A"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "// A paper with no markers represent a potential stack of tiles\n// Adding or removing markers increments or decrements\n// the number of tiles of that tile type - ONES, x or x-squared.\nphet.paperLand.console.log(NumberOfOnes_A);\nif (Math.floor(NumberOfOnes_A) !== 0) {\n   // Test for negative tile value\n   if (BooleanNegativeForOnes_A) {\n       speak( -Math.floor(NumberOfOnes_A) );\n   }\n   // else assume positive value\n   else {\n       speak( Math.floor(NumberOfOnes_A) );\n   }\n}",
            "lazyLink": false
          }
        ],
        "textViews": [
          {
            "name": "ViewTextTilesForOnes_A",
            "modelComponentNames": [
              "BooleanNegativeForOnes_A",
              "PositionForOnesTiles_A",
              "NumberOfOnes_A"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "if ( BooleanNegativeForOnes_A )  {\n    if ( NumberOfOnes_A === 0 ) {\n        setString('Add negative ones.'); // empty negative tile\n    }\n    else {\n        setString('] ' + (-NumberOfOnes_A) +  ' [');\n    }\n}\nelse {\n    if ( NumberOfOnes_A === 0 ) {\n        setString('Add ones.'); // empty tile\n    }\n    else {\n    setString('[ ' + ( NumberOfOnes_A ) + ' ]');\n    }\n}\nsetFontSize(20);\nsetCenterX( phet.paperLand.utils.paperToBoardX( PositionForOnesTiles_A.x, sharedData.displaySize.width ))\nsetCenterY( phet.paperLand.utils.paperToBoardY( PositionForOnesTiles_A.y, sharedData.displaySize.height ))",
            "lazyLink": false,
            "defaultViewOptions": {
              "centerX": 0.5,
              "centerY": 0.5,
              "scale": 1,
              "rotation": 0,
              "opacity": 1,
              "visible": true,
              "viewUnits": "model"
            }
          }
        ],
        "shapeViews": [
          {
            "name": "OnesTilesShape_A",
            "modelComponentNames": [
              "BooleanOnLeftSideForOnes_A",
              "BooleanNegativeForOnes_A",
              "PositionForOnesTiles_A",
              "NumberOfOnes_A"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "// Set the rectangle/square to the desired size\n const rectangleHeight = 0.1\n const rectangleWidth = 0.1\n\nsetRectBounds( new phet.dot.Bounds2( 0, 0, rectangleWidth, rectangleHeight * sharedData.displaySize.width / sharedData.displaySize.height ) );\n\nsetVisible(Math.floor(NumberOfOnes_A) !== 0)\nif (BooleanNegativeForOnes_A) {\n    // If negative make a frame tile\n    // setRectBounds( new phet.dot.Bounds2( 0, 0, squareWidth, squareWidth * sharedData.displaySize.width / sharedData.displaySize.height ) );\n    setStroke('#ff0000'); // red\n    setFill('transparent');\t\t// fill\n    setLineWidth(4); // pixels\n}\nelse {\n    // Else assume positive and make a tile: stroke, fill\n    // setRectBounds( new phet.dot.Bounds2( 0, 0, squareWidth, squareWidth * sharedData.displaySize.width / sharedData.displaySize.height ) );\n    setStroke('#ff0000');\t// red\n    setLineWidth(4);\t\t// pixels\n    setFill('#ff0000');\t\t// fill\n    setOpacity( 0.6 );      // make tile transparent\n    // moveToFront();\t\t\t// keep in background behind any text\n}\n\nsetCenterX(PositionForOnesTiles_A.x);\nsetCenterY(PositionForOnesTiles_A.y);\n",
            "lazyLink": false,
            "defaultViewOptions": {
              "centerX": 0.5,
              "centerY": 0.5,
              "scale": 1,
              "rotation": 0,
              "opacity": 1,
              "visible": true,
              "viewUnits": "model"
            },
            "defaultShapeOptions": {
              "shapeType": "rectangle",
              "fill": "lightblue",
              "stroke": "red",
              "lineWidth": 1,
              "rectWidth": 0.5,
              "rectHeight": 0.5,
              "circleRadius": 0.05,
              "ellipseRadiusX": 0.3,
              "ellipseRadiusY": 0.15,
              "lineStartX": 0,
              "lineStartY": 0,
              "lineEndX": 0.3,
              "lineEndY": 0.3,
              "triangleBaseWidth": 0.1,
              "triangleHeight": 0.3,
              "polygonPoints": [
                [
                  0,
                  0
                ],
                [
                  0.1,
                  0
                ],
                [
                  0.1,
                  0.1
                ],
                [
                  0,
                  0.1
                ]
              ]
            }
          }
        ],
        "backgroundViews": [],
        "imageViews": []
      },
      "listenerContainer": {
        "linkListeners": [
          {
            "name": "ControllerBooleanLeftSideForOnes_A",
            "controlledPropertyNames": [
              "BooleanOnLeftSideForOnes_A"
            ],
            "controlFunctionString": "// Uncomment to voice side of equation\nsetBooleanOnLeftSideForOnes_A(BoundsLeftSideOfEquals.containsPoint( PositionForOnesTiles_A )); ",
            "dependencyNames": [
              "BoundsLeftSideOfEquals",
              "PositionForOnesTiles_A"
            ],
            "referenceComponentNames": []
          }
        ],
        "animationListeners": [],
        "bluetoothListeners": []
      },
      "customCodeContainer": {
        "onProgramAddedCode": "// Setting program data to the program for some sound design.\r\nphet.paperLand.setProgramData( paperNumber, 'term', 'ones' );",
        "onProgramRemovedCode": "// Removes the term data from the model\r\nphet.paperLand.removeProgramData( paperNumber, 'term' );\r\n\r\n",
        "onProgramChangedPositionCode": "",
        "onProgramMarkersAddedCode": "",
        "onProgramMarkersRemovedCode": "",
        "onProgramMarkersChangedPositionCode": "",
        "onProgramAdjacentCode": "\r\n// Get a reference to the model component and only update it if it exists.\r\nconst goodConnectionComponent = phet.paperLand.getModelComponent( 'BooleanGoodConnectionForOnes_A' );\r\nconst badConnectionComponent = phet.paperLand.getModelComponent( 'BooleanBadConnectionForOnes_A' );\r\n\r\n\r\nif ( goodConnectionComponent && badConnectionComponent ) {\r\n\r\n    // If this is the left or right whisker...\r\n    if ( direction === 'left' || direction === 'right' ) {\r\n\r\n        // These are the terms that this program is allowed to connect to.\r\n        const goodConnectionTerms = [ 'ones' ];\r\n       \r\n        // These are the terms that this program is NOT allowed to connect to.\r\n        const badConnectionTerms = [ 'x', 'xSquared' ];\r\n\r\n        // This connection is \"good\" if the other program has a term in the good list\r\n        goodConnectionComponent.value = goodConnectionTerms.includes(\r\n\r\n            // get the term from the other program\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        );\r\n        // This connection is \"bad\" if the other program has a term in the bad list\r\n        badConnectionComponent.value = badConnectionTerms.includes(\r\n\r\n            // get the term from the other program\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        );\r\n    }\r\n\r\n    phet.paperLand.console.log( direction );\r\n\r\n    // If this is the top or bottom whisker...\r\n    if ( direction === 'top' || direction === 'bottom' ) {\r\n        \r\n        // These are the terms that this program is allowed to connect to.\r\n        // TODO: Add top and bottom of X tiles\r\n        const goodConnectionTerms = [ 'ones' ];\r\n       \r\n        // These are the terms that this program is NOT allowed to connect to.\r\n        // TODO: Add left and right of X tiles\r\n        const badConnectionTerms = [ 'xSquared' ];\r\n\r\n        // This connection is \"good\" if the other program has a term in the good list\r\n        goodConnectionComponent.value = goodConnectionTerms.includes(\r\n\r\n            // get the term from the other program\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        );\r\n        // This connection is \"bad\" if the other program has a term in the bad list\r\n        badConnectionComponent.value = badConnectionTerms.includes(\r\n\r\n            // get the term from the other program\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        );\r\n    }\r\n}",
        "onProgramSeparatedCode": "\r\n// Get a reference to the model component and only update it if it exists.\r\nconst goodConnectionComponent = phet.paperLand.getModelComponent( 'BooleanGoodConnectionForOnes_A' );\r\nconst badConnectionComponent = phet.paperLand.getModelComponent( 'BooleanBadConnectionForOnes_A' );\r\n\r\n// Components must exit check\r\nif ( goodConnectionComponent && badConnectionComponent )  {\r\n\r\n    // If this is the left or right whisker...\r\n    if ( direction === 'left' || direction === 'right' ) {\r\n\r\n        // These are the terms that this program is allowed to connect to.\r\n        const goodConnectionTerms = [ 'ones' ];\r\n\r\n         // These are the terms that this program is NOT allowed to connect to.\r\n        const badConnectionTerms = [ 'x', 'xSquared' ];\r\n\r\n        // If detatching from another program where connection is \"good\",\r\n        // the connection is no longer there.\r\n        if ( goodConnectionTerms.includes(\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        ) ) {\r\n            goodConnectionComponent.value = false;\r\n        }\r\n        // If detatching from another program where connection is \"bad\",\r\n        // the connection is no longer there.\r\n        if ( badConnectionTerms.includes(\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        ) ) {\r\n            badConnectionComponent.value = false;\r\n        }\r\n    }\r\n\r\n    // If this is the top or bottom whisker...\r\n    if ( direction === 'top' || direction === 'bottom' ) {\r\n\r\n       // These are the terms that this program is allowed to connect to.\r\n       // TODO: top and bottom of X tiles need to be added\r\n        const goodConnectionTerms = [ 'ones' ];\r\n\r\n         // These are the terms that this program is NOT allowed to connect to.\r\n         // TODO: left and right of X tiles need to be added\r\n        const badConnectionTerms = [ 'xSquared' ];\r\n\r\n        // If detatching from another program where connection is \"good\",\r\n        // the connection is no longer there.\r\n        if ( goodConnectionTerms.includes(\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        ) ) {\r\n            goodConnectionComponent.value = false;\r\n        }\r\n        // If detatching from another program where connection is \"bad\",\r\n        // the connection is no longer there.\r\n        if ( badConnectionTerms.includes(\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        ) ) {\r\n            badConnectionComponent.value = false;\r\n        }\r\n    }\r\n}"
      }
    },
    {
      "number": 447,
      "title": "Ones Tiles B",
      "keywords": "TacTiles, algebra, voicing, ones, one, numbers",
      "description": "A program that voices the number of one-tiles and increments and decrements the number of ones using markers. Note that current model range is 0-9, and the voicing strings range from 1-10.",
      "expanded": false,
      "topWhiskerLength": 0.05,
      "rightWhiskerLength": 0.05,
      "bottomWhiskerLength": 0.05,
      "leftWhiskerLength": 0.05,
      "positionProperty": {
        "x": 591.1689976142477,
        "y": 373
      },
      "modelContainer": {
        "namedBooleanProperties": [
          {
            "name": "BooleanOnLeftSideForOnes_B",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          },
          {
            "name": "BooleanNegativeForOnes_B",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          },
          {
            "name": "BooleanGoodConnectionForOnes_B",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          },
          {
            "name": "BooleanBadConnectionForOnes_B",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          }
        ],
        "namedVector2Properties": [
          {
            "name": "PositionForOnesTiles_B",
            "propertyType": "Vector2Property",
            "defaultX": 0,
            "defaultY": 0
          }
        ],
        "namedNumberProperties": [
          {
            "name": "NumberOfOnes_B",
            "propertyType": "NumberProperty",
            "min": 0,
            "max": "9",
            "defaultValue": "0"
          },
          {
            "name": "TermForOnesTile_B",
            "propertyType": "NumberProperty",
            "min": 0,
            "max": "2",
            "defaultValue": "0"
          }
        ],
        "namedEnumerationProperties": [],
        "namedDerivedProperties": [],
        "namedBounds2Properties": [],
        "namedObservableArrays": [],
        "namedArrayItems": [
          {
            "name": "onesTileData_B",
            "arrayName": "tileData",
            "itemSchema": [
              {
                "entryName": "onLeftSide",
                "componentName": "BooleanOnLeftSideForOnes_B"
              },
              {
                "entryName": "negative",
                "componentName": "BooleanNegativeForOnes_B"
              },
              {
                "entryName": "count",
                "componentName": "NumberOfOnes_B"
              },
              {
                "entryName": "term",
                "componentName": "TermForOnesTile_B"
              }
            ]
          }
        ],
        "namedArrayItemReferences": [],
        "namedStringProperties": []
      },
      "controllerContainer": {
        "vector2PropertyControllers": [
          {
            "name": "ControllerPositionForOnes_B",
            "controlledComponentName": "PositionForOnesTiles_B",
            "controlType": "MATCH_CENTER",
            "controlTypeFamily": ""
          }
        ],
        "boundsPropertyControllers": [],
        "booleanPropertyControllers": [
          {
            "name": "ControllerBooleanNegativeForOnes_B",
            "controlledComponentName": "BooleanNegativeForOnes_B",
            "controlType": "ROTATION",
            "controlTypeFamily": "",
            "whiskerConfiguration": {
              "topLength": 0.2,
              "rightLength": 0.2,
              "bottomLength": 0.2,
              "leftLength": 0.2,
              "otherPaperNumber": null
            },
            "markerColor": ""
          }
        ],
        "numberPropertyControllers": [
          {
            "name": "ControllerForOnes_B",
            "controlledComponentName": "NumberOfOnes_B",
            "controlType": "MARKER_COUNT",
            "controlTypeFamily": "MARKERS",
            "markerColor": "all",
            "relationshipControlType": null
          }
        ],
        "enumerationPropertyControllers": []
      },
      "viewContainer": {
        "soundViews": [
          {
            "name": "ViewGoodConnectionSoundForOnes_B",
            "modelComponentNames": [
              "RectangleModelMode",
              "BooleanGoodConnectionForOnes_B"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "if ( BooleanGoodConnectionForOnes_B && RectangleModelMode ) {\r\n    play();\r\n}",
            "lazyLink": false,
            "soundFileName": "/uploads/SuccessSound.mp3",
            "loop": false,
            "autoplay": false
          },
          {
            "name": "ViewBadConnectionSoundForOnes_B",
            "modelComponentNames": [
              "RectangleModelMode",
              "BooleanBadConnectionForOnes_B"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "if ( BooleanBadConnectionForOnes_B && RectangleModelMode) {\r\n    play();\r\n}",
            "lazyLink": false,
            "soundFileName": "/uploads/OutOfBalanceSound.mp3",
            "loop": false,
            "autoplay": false
          }
        ],
        "speechViews": [
          {
            "name": "ViewNumberOfOnes_B",
            "modelComponentNames": [
              "BooleanNegativeForOnes_B",
              "NumberOfOnes_B"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "// A paper with no markers represent a potential stack of tiles\n// Adding or removing markers increments or decrements\n// the number of tiles of that tile type - ONES, x or x-squared.\nphet.paperLand.console.log(NumberOfOnes_B);\nif (Math.floor(NumberOfOnes_B) !== 0) {\n   // Test for negative tile value\n   if (BooleanNegativeForOnes_B) {\n       speak( -Math.floor(NumberOfOnes_B) );\n   }\n   // else assume positive value\n   else {\n       speak( Math.floor(NumberOfOnes_B) );\n   }\n}",
            "lazyLink": false
          }
        ],
        "textViews": [
          {
            "name": "ViewTextTilesForOnes_B",
            "modelComponentNames": [
              "BooleanNegativeForOnes_B",
              "PositionForOnesTiles_B",
              "NumberOfOnes_B"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "if ( BooleanNegativeForOnes_B )  {\n    if ( NumberOfOnes_B === 0 ) {\n        setString('Add negative ones.'); // empty tile\n    }\n    else {\n        setString('] ' + (-NumberOfOnes_B) +  ' [');\n    }\n}\nelse {\n    if ( NumberOfOnes_B === 0 ) {\n        setString('Add ones.'); // empty tile\n    }\n    else {\n    setString('[ ' + ( NumberOfOnes_B ) + ' ]');\n    }\n}\nsetFontSize(20);\nsetCenterX( phet.paperLand.utils.paperToBoardX( PositionForOnesTiles_B.x, sharedData.displaySize.width ))\nsetCenterY( phet.paperLand.utils.paperToBoardY( PositionForOnesTiles_B.y, sharedData.displaySize.height ))",
            "lazyLink": false,
            "defaultViewOptions": {
              "centerX": 0.5,
              "centerY": 0.5,
              "scale": 1,
              "rotation": 0,
              "opacity": 1,
              "visible": true,
              "viewUnits": "model"
            }
          }
        ],
        "shapeViews": [
          {
            "name": "OnesTilesShape_B",
            "modelComponentNames": [
              "BooleanOnLeftSideForOnes_B",
              "BooleanNegativeForOnes_B",
              "PositionForOnesTiles_B",
              "NumberOfOnes_B"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "// Set the rectangle/square to the desired size\n const rectangleHeight = 0.1\n const rectangleWidth = 0.1\n\nsetRectBounds( new phet.dot.Bounds2( 0, 0, rectangleWidth, rectangleHeight * sharedData.displaySize.width / sharedData.displaySize.height ) );\n\nsetVisible(Math.floor(NumberOfOnes_B) !== 0)\nif (BooleanNegativeForOnes_B) {\n    // If negative make a frame tile\n    // setRectBounds( new phet.dot.Bounds2( 0, 0, squareWidth, squareWidth * sharedData.displaySize.width / sharedData.displaySize.height ) );\n    setStroke('#ff0000'); // red\n    setFill('transparent');\t\t// fill\n    setLineWidth(4); // pixels\n}\nelse {\n    // Else assume positive and make a tile: stroke, fill\n    // setRectBounds( new phet.dot.Bounds2( 0, 0, squareWidth, squareWidth * sharedData.displaySize.width / sharedData.displaySize.height ) );\n    setStroke('#ff0000');\t// red\n    setLineWidth(4);\t\t// pixels\n    setFill('#ff0000');\t\t// fill\n    setOpacity( 0.6 );      // make tile transparent\n    // moveToFront();\t\t\t// keep in background behind any text\n}\n\nsetCenterX(PositionForOnesTiles_B.x);\nsetCenterY(PositionForOnesTiles_B.y);\n",
            "lazyLink": false,
            "defaultViewOptions": {
              "centerX": 0.5,
              "centerY": 0.5,
              "scale": 1,
              "rotation": 0,
              "opacity": 1,
              "visible": true,
              "viewUnits": "model"
            },
            "defaultShapeOptions": {
              "shapeType": "rectangle",
              "fill": "lightblue",
              "stroke": "red",
              "lineWidth": 1,
              "rectWidth": 0.5,
              "rectHeight": 0.5,
              "circleRadius": 0.05,
              "ellipseRadiusX": 0.3,
              "ellipseRadiusY": 0.15,
              "lineStartX": 0,
              "lineStartY": 0,
              "lineEndX": 0.3,
              "lineEndY": 0.3,
              "triangleBaseWidth": 0.1,
              "triangleHeight": 0.3,
              "polygonPoints": [
                [
                  0,
                  0
                ],
                [
                  0.1,
                  0
                ],
                [
                  0.1,
                  0.1
                ],
                [
                  0,
                  0.1
                ]
              ]
            }
          }
        ],
        "backgroundViews": [],
        "imageViews": []
      },
      "listenerContainer": {
        "linkListeners": [
          {
            "name": "ControllerBooleanLeftSideForOnes_B",
            "controlledPropertyNames": [
              "BooleanOnLeftSideForOnes_B"
            ],
            "controlFunctionString": "// Uncomment to voice side of equation\nsetBooleanOnLeftSideForOnes_B(BoundsLeftSideOfEquals.containsPoint( PositionForOnesTiles_B )); ",
            "dependencyNames": [
              "BoundsLeftSideOfEquals",
              "PositionForOnesTiles_B"
            ],
            "referenceComponentNames": []
          }
        ],
        "animationListeners": [],
        "bluetoothListeners": []
      },
      "customCodeContainer": {
        "onProgramAddedCode": "// Setting program data to the program for some sound design.\r\nphet.paperLand.setProgramData( paperNumber, 'term', 'ones' );",
        "onProgramRemovedCode": "// Removes the term data from the model\r\nphet.paperLand.removeProgramData( paperNumber, 'term' );\r\n\r\n",
        "onProgramChangedPositionCode": "",
        "onProgramMarkersAddedCode": "",
        "onProgramMarkersRemovedCode": "",
        "onProgramMarkersChangedPositionCode": "",
        "onProgramAdjacentCode": "\r\n// Get a reference to the model component and only update it if it exists.\r\nconst goodConnectionComponent = phet.paperLand.getModelComponent( 'BooleanGoodConnectionForOnes_B' );\r\nconst badConnectionComponent = phet.paperLand.getModelComponent( 'BooleanBadConnectionForOnes_B' );\r\n\r\n\r\nif ( goodConnectionComponent && badConnectionComponent ) {\r\n\r\n    // If this is the left or right whisker...\r\n    if ( direction === 'left' || direction === 'right' ) {\r\n\r\n        // These are the terms that this program is allowed to connect to.\r\n        const goodConnectionTerms = [ 'ones' ];\r\n       \r\n        // These are the terms that this program is NOT allowed to connect to.\r\n        const badConnectionTerms = [ 'x', 'xSquared' ];\r\n\r\n        // This connection is \"good\" if the other program has a term in the good list\r\n        goodConnectionComponent.value = goodConnectionTerms.includes(\r\n\r\n            // get the term from the other program\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        );\r\n        // This connection is \"bad\" if the other program has a term in the bad list\r\n        badConnectionComponent.value = badConnectionTerms.includes(\r\n\r\n            // get the term from the other program\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        );\r\n    }\r\n\r\n    phet.paperLand.console.log( direction );\r\n\r\n    // If this is the top or bottom whisker...\r\n    if ( direction === 'top' || direction === 'bottom' ) {\r\n        \r\n        // These are the terms that this program is allowed to connect to.\r\n        // TODO: Add top and bottom of X tiles\r\n        const goodConnectionTerms = [ 'ones' ];\r\n       \r\n        // These are the terms that this program is NOT allowed to connect to.\r\n        // TODO: Add left and right of X tiles\r\n        const badConnectionTerms = [ 'xSquared' ];\r\n\r\n        // This connection is \"good\" if the other program has a term in the good list\r\n        goodConnectionComponent.value = goodConnectionTerms.includes(\r\n\r\n            // get the term from the other program\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        );\r\n        // This connection is \"bad\" if the other program has a term in the bad list\r\n        badConnectionComponent.value = badConnectionTerms.includes(\r\n\r\n            // get the term from the other program\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        );\r\n    }\r\n}",
        "onProgramSeparatedCode": "\r\n// Get a reference to the model component and only update it if it exists.\r\nconst goodConnectionComponent = phet.paperLand.getModelComponent( 'BooleanGoodConnectionForOnes_B' );\r\nconst badConnectionComponent = phet.paperLand.getModelComponent( 'BooleanBadConnectionForOnes_B' );\r\n\r\n// Components must exit check\r\nif ( goodConnectionComponent && badConnectionComponent )  {\r\n\r\n    // If this is the left or right whisker...\r\n    if ( direction === 'left' || direction === 'right' ) {\r\n\r\n        // These are the terms that this program is allowed to connect to.\r\n        const goodConnectionTerms = [ 'ones' ];\r\n\r\n         // These are the terms that this program is NOT allowed to connect to.\r\n        const badConnectionTerms = [ 'x', 'xSquared' ];\r\n\r\n        // If detatching from another program where connection is \"good\",\r\n        // the connection is no longer there.\r\n        if ( goodConnectionTerms.includes(\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        ) ) {\r\n            goodConnectionComponent.value = false;\r\n        }\r\n        // If detatching from another program where connection is \"bad\",\r\n        // the connection is no longer there.\r\n        if ( badConnectionTerms.includes(\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        ) ) {\r\n            badConnectionComponent.value = false;\r\n        }\r\n    }\r\n\r\n    // If this is the top or bottom whisker...\r\n    if ( direction === 'top' || direction === 'bottom' ) {\r\n\r\n       // These are the terms that this program is allowed to connect to.\r\n       // TODO: top and bottom of X tiles need to be added\r\n        const goodConnectionTerms = [ 'ones' ];\r\n\r\n         // These are the terms that this program is NOT allowed to connect to.\r\n         // TODO: left and right of X tiles need to be added\r\n        const badConnectionTerms = [ 'xSquared' ];\r\n\r\n        // If detatching from another program where connection is \"good\",\r\n        // the connection is no longer there.\r\n        if ( goodConnectionTerms.includes(\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        ) ) {\r\n            goodConnectionComponent.value = false;\r\n        }\r\n        // If detatching from another program where connection is \"bad\",\r\n        // the connection is no longer there.\r\n        if ( badConnectionTerms.includes(\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        ) ) {\r\n            badConnectionComponent.value = false;\r\n        }\r\n    }\r\n}"
      }
    },
    {
      "number": 1616,
      "title": "Ones Tiles C",
      "keywords": "TacTiles, algebra, voicing, ones, one, numbers",
      "description": "A program that voices the number of one-tiles and increments and decrements the number of ones using markers. Note that current model range is 0-9, and the voicing strings range from 1-10.",
      "expanded": false,
      "topWhiskerLength": 0.05,
      "rightWhiskerLength": 0.05,
      "bottomWhiskerLength": 0.05,
      "leftWhiskerLength": 0.05,
      "positionProperty": {
        "x": 617,
        "y": 293.2734051605219
      },
      "modelContainer": {
        "namedBooleanProperties": [
          {
            "name": "BooleanOnLeftSideForOnes_C",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          },
          {
            "name": "BooleanNegativeForOnes_C",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          },
          {
            "name": "BooleanGoodConnectionForOnes_C",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          },
          {
            "name": "BooleanBadConnectionForOnes_C",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          }
        ],
        "namedVector2Properties": [
          {
            "name": "PositionForOnesTiles_C",
            "propertyType": "Vector2Property",
            "defaultX": 0,
            "defaultY": 0
          }
        ],
        "namedNumberProperties": [
          {
            "name": "NumberOfOnes_C",
            "propertyType": "NumberProperty",
            "min": 0,
            "max": "9",
            "defaultValue": "0"
          },
          {
            "name": "TermForOnesTile_C",
            "propertyType": "NumberProperty",
            "min": 0,
            "max": "2",
            "defaultValue": "0"
          }
        ],
        "namedEnumerationProperties": [],
        "namedDerivedProperties": [],
        "namedBounds2Properties": [],
        "namedObservableArrays": [],
        "namedArrayItems": [
          {
            "name": "onesTileData_C",
            "arrayName": "tileData",
            "itemSchema": [
              {
                "entryName": "onLeftSide",
                "componentName": "BooleanOnLeftSideForOnes_C"
              },
              {
                "entryName": "negative",
                "componentName": "BooleanNegativeForOnes_C"
              },
              {
                "entryName": "count",
                "componentName": "NumberOfOnes_C"
              },
              {
                "entryName": "term",
                "componentName": "TermForOnesTile_C"
              }
            ]
          }
        ],
        "namedArrayItemReferences": [],
        "namedStringProperties": []
      },
      "controllerContainer": {
        "vector2PropertyControllers": [
          {
            "name": "ControllerPositionForOnes_C",
            "controlledComponentName": "PositionForOnesTiles_C",
            "controlType": "MATCH_CENTER",
            "controlTypeFamily": ""
          }
        ],
        "boundsPropertyControllers": [],
        "booleanPropertyControllers": [
          {
            "name": "ControllerBooleanNegativeForOnes_C",
            "controlledComponentName": "BooleanNegativeForOnes_C",
            "controlType": "ROTATION",
            "controlTypeFamily": "",
            "whiskerConfiguration": {
              "topLength": 0.2,
              "rightLength": 0.2,
              "bottomLength": 0.2,
              "leftLength": 0.2,
              "otherPaperNumber": null
            },
            "markerColor": ""
          }
        ],
        "numberPropertyControllers": [
          {
            "name": "ControllerForOnes_C",
            "controlledComponentName": "NumberOfOnes_C",
            "controlType": "MARKER_COUNT",
            "controlTypeFamily": "MARKERS",
            "markerColor": "all",
            "relationshipControlType": null
          }
        ],
        "enumerationPropertyControllers": []
      },
      "viewContainer": {
        "soundViews": [
          {
            "name": "ViewGoodConnectionSoundForOnes_C",
            "modelComponentNames": [
              "RectangleModelMode",
              "BooleanGoodConnectionForOnes_C"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "if ( BooleanGoodConnectionForOnes_C && RectangleModelMode ) {\r\n    play();\r\n}",
            "lazyLink": false,
            "soundFileName": "/uploads/SuccessSound.mp3",
            "loop": false,
            "autoplay": false
          },
          {
            "name": "ViewBadConnectionSoundForOnes_C",
            "modelComponentNames": [
              "RectangleModelMode",
              "BooleanBadConnectionForOnes_C"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "if ( BooleanBadConnectionForOnes_C && RectangleModelMode) {\r\n    play();\r\n}",
            "lazyLink": false,
            "soundFileName": "/uploads/OutOfBalanceSound.mp3",
            "loop": false,
            "autoplay": false
          }
        ],
        "speechViews": [
          {
            "name": "ViewNumberOfOnes_C",
            "modelComponentNames": [
              "BooleanNegativeForOnes_C",
              "NumberOfOnes_C"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "// A paper with no markers represent a potential stack of tiles\n// Adding or removing markers increments or decrements\n// the number of tiles of that tile type - ONES, x or x-squared.\nphet.paperLand.console.log(NumberOfOnes_C);\nif (Math.floor(NumberOfOnes_C) !== 0) {\n   // Test for negative tile value\n   if (BooleanNegativeForOnes_C) {\n       speak( -Math.floor(NumberOfOnes_C) );\n   }\n   // else assume positive value\n   else {\n       speak( Math.floor(NumberOfOnes_C) );\n   }\n}",
            "lazyLink": false
          }
        ],
        "textViews": [
          {
            "name": "ViewTextTilesForOnes_C",
            "modelComponentNames": [
              "BooleanNegativeForOnes_C",
              "PositionForOnesTiles_C",
              "NumberOfOnes_C"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "if ( BooleanNegativeForOnes_C )  {\n    if ( NumberOfOnes_C === 0 ) {\n        setString('Add negative ones.'); // empty tile\n    }\n    else {\n        setString('] ' + (-NumberOfOnes_C) +  ' [');\n    }\n}\nelse {\n    if ( NumberOfOnes_C === 0 ) {\n        setString('Add ones.'); // empty tile\n    }\n    else {\n    setString('[ ' + ( NumberOfOnes_C ) + ' ]');\n    }\n}\nsetFontSize(20);\nsetCenterX( phet.paperLand.utils.paperToBoardX( PositionForOnesTiles_C.x, sharedData.displaySize.width ))\nsetCenterY( phet.paperLand.utils.paperToBoardY( PositionForOnesTiles_C.y, sharedData.displaySize.height ))",
            "lazyLink": false,
            "defaultViewOptions": {
              "centerX": 0.5,
              "centerY": 0.5,
              "scale": 1,
              "rotation": 0,
              "opacity": 1,
              "visible": true,
              "viewUnits": "model"
            }
          }
        ],
        "shapeViews": [
          {
            "name": "OnesTilesShape_C",
            "modelComponentNames": [
              "BooleanOnLeftSideForOnes_C",
              "BooleanNegativeForOnes_C",
              "PositionForOnesTiles_C",
              "NumberOfOnes_C"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "// Set the rectangle/square to the desired size\n const rectangleHeight = 0.1\n const rectangleWidth = 0.1\n\nsetRectBounds( new phet.dot.Bounds2( 0, 0, rectangleWidth, rectangleHeight * sharedData.displaySize.width / sharedData.displaySize.height ) );\n\nsetVisible(Math.floor(NumberOfOnes_C) !== 0)\nif (BooleanNegativeForOnes_C) {\n    // If negative make a frame tile\n    // setRectBounds( new phet.dot.Bounds2( 0, 0, squareWidth, squareWidth * sharedData.displaySize.width / sharedData.displaySize.height ) );\n    setStroke('#ff0000'); // red\n    setFill('transparent');\t\t// fill\n    setLineWidth(4); // pixels\n}\nelse {\n    // Else assume positive and make a tile: stroke, fill\n    // setRectBounds( new phet.dot.Bounds2( 0, 0, squareWidth, squareWidth * sharedData.displaySize.width / sharedData.displaySize.height ) );\n    setStroke('#ff0000');\t// red\n    setLineWidth(4);\t\t// pixels\n    setFill('#ff0000');\t\t// fill\n    setOpacity( 0.6 );      // make tile transparent\n    // moveToFront();\t\t\t// keep in background behind any text\n}\n\nsetCenterX(PositionForOnesTiles_C.x);\nsetCenterY(PositionForOnesTiles_C.y);\n",
            "lazyLink": false,
            "defaultViewOptions": {
              "centerX": 0.5,
              "centerY": 0.5,
              "scale": 1,
              "rotation": 0,
              "opacity": 1,
              "visible": true,
              "viewUnits": "model"
            },
            "defaultShapeOptions": {
              "shapeType": "rectangle",
              "fill": "lightblue",
              "stroke": "red",
              "lineWidth": 1,
              "rectWidth": 0.5,
              "rectHeight": 0.5,
              "circleRadius": 0.05,
              "ellipseRadiusX": 0.3,
              "ellipseRadiusY": 0.15,
              "lineStartX": 0,
              "lineStartY": 0,
              "lineEndX": 0.3,
              "lineEndY": 0.3,
              "triangleBaseWidth": 0.1,
              "triangleHeight": 0.3,
              "polygonPoints": [
                [
                  0,
                  0
                ],
                [
                  0.1,
                  0
                ],
                [
                  0.1,
                  0.1
                ],
                [
                  0,
                  0.1
                ]
              ]
            }
          }
        ],
        "backgroundViews": [],
        "imageViews": []
      },
      "listenerContainer": {
        "linkListeners": [
          {
            "name": "ControllerBooleanLeftSideForOnes_C",
            "controlledPropertyNames": [
              "BooleanOnLeftSideForOnes_C"
            ],
            "controlFunctionString": "// Uncomment to voice side of equation\nsetBooleanOnLeftSideForOnes_C(BoundsLeftSideOfEquals.containsPoint( PositionForOnesTiles_C )); ",
            "dependencyNames": [
              "BoundsLeftSideOfEquals",
              "PositionForOnesTiles_C"
            ],
            "referenceComponentNames": []
          }
        ],
        "animationListeners": [],
        "bluetoothListeners": []
      },
      "customCodeContainer": {
        "onProgramAddedCode": "// Setting program data to the program for some sound design.\r\nphet.paperLand.setProgramData( paperNumber, 'term', 'ones' );",
        "onProgramRemovedCode": "// Removes the term data from the model\r\nphet.paperLand.removeProgramData( paperNumber, 'term' );\r\n\r\n",
        "onProgramChangedPositionCode": "",
        "onProgramMarkersAddedCode": "",
        "onProgramMarkersRemovedCode": "",
        "onProgramMarkersChangedPositionCode": "",
        "onProgramAdjacentCode": "\r\n// Get a reference to the model component and only update it if it exists.\r\nconst goodConnectionComponent = phet.paperLand.getModelComponent( 'BooleanGoodConnectionForOnes_C' );\r\nconst badConnectionComponent = phet.paperLand.getModelComponent( 'BooleanBadConnectionForOnes_C' );\r\n\r\n\r\nif ( goodConnectionComponent && badConnectionComponent ) {\r\n\r\n    // If this is the left or right whisker...\r\n    if ( direction === 'left' || direction === 'right' ) {\r\n\r\n        // These are the terms that this program is allowed to connect to.\r\n        const goodConnectionTerms = [ 'ones' ];\r\n       \r\n        // These are the terms that this program is NOT allowed to connect to.\r\n        const badConnectionTerms = [ 'x', 'xSquared' ];\r\n\r\n        // This connection is \"good\" if the other program has a term in the good list\r\n        goodConnectionComponent.value = goodConnectionTerms.includes(\r\n\r\n            // get the term from the other program\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        );\r\n        // This connection is \"bad\" if the other program has a term in the bad list\r\n        badConnectionComponent.value = badConnectionTerms.includes(\r\n\r\n            // get the term from the other program\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        );\r\n    }\r\n\r\n    phet.paperLand.console.log( direction );\r\n\r\n    // If this is the top or bottom whisker...\r\n    if ( direction === 'top' || direction === 'bottom' ) {\r\n        \r\n        // These are the terms that this program is allowed to connect to.\r\n        // TODO: Add top and bottom of X tiles\r\n        const goodConnectionTerms = [ 'ones' ];\r\n       \r\n        // These are the terms that this program is NOT allowed to connect to.\r\n        // TODO: Add left and right of X tiles\r\n        const badConnectionTerms = [ 'xSquared' ];\r\n\r\n        // This connection is \"good\" if the other program has a term in the good list\r\n        goodConnectionComponent.value = goodConnectionTerms.includes(\r\n\r\n            // get the term from the other program\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        );\r\n        // This connection is \"bad\" if the other program has a term in the bad list\r\n        badConnectionComponent.value = badConnectionTerms.includes(\r\n\r\n            // get the term from the other program\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        );\r\n    }\r\n}",
        "onProgramSeparatedCode": "\r\n// Get a reference to the model component and only update it if it exists.\r\nconst goodConnectionComponent = phet.paperLand.getModelComponent( 'BooleanGoodConnectionForOnes_C' );\r\nconst badConnectionComponent = phet.paperLand.getModelComponent( 'BooleanBadConnectionForOnes_C' );\r\n\r\n// Components must exit check\r\nif ( goodConnectionComponent && badConnectionComponent )  {\r\n\r\n    // If this is the left or right whisker...\r\n    if ( direction === 'left' || direction === 'right' ) {\r\n\r\n        // These are the terms that this program is allowed to connect to.\r\n        const goodConnectionTerms = [ 'ones' ];\r\n\r\n         // These are the terms that this program is NOT allowed to connect to.\r\n        const badConnectionTerms = [ 'x', 'xSquared' ];\r\n\r\n        // If detatching from another program where connection is \"good\",\r\n        // the connection is no longer there.\r\n        if ( goodConnectionTerms.includes(\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        ) ) {\r\n            goodConnectionComponent.value = false;\r\n        }\r\n        // If detatching from another program where connection is \"bad\",\r\n        // the connection is no longer there.\r\n        if ( badConnectionTerms.includes(\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        ) ) {\r\n            badConnectionComponent.value = false;\r\n        }\r\n    }\r\n\r\n    // If this is the top or bottom whisker...\r\n    if ( direction === 'top' || direction === 'bottom' ) {\r\n\r\n       // These are the terms that this program is allowed to connect to.\r\n       // TODO: top and bottom of X tiles need to be added\r\n        const goodConnectionTerms = [ 'ones' ];\r\n\r\n         // These are the terms that this program is NOT allowed to connect to.\r\n         // TODO: left and right of X tiles need to be added\r\n        const badConnectionTerms = [ 'xSquared' ];\r\n\r\n        // If detatching from another program where connection is \"good\",\r\n        // the connection is no longer there.\r\n        if ( goodConnectionTerms.includes(\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        ) ) {\r\n            goodConnectionComponent.value = false;\r\n        }\r\n        // If detatching from another program where connection is \"bad\",\r\n        // the connection is no longer there.\r\n        if ( badConnectionTerms.includes(\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        ) ) {\r\n            badConnectionComponent.value = false;\r\n        }\r\n    }\r\n}"
      }
    },
    {
      "number": 795,
      "title": "Ones Tiles D",
      "keywords": "TacTiles, algebra, voicing, ones, one, numbers",
      "description": "A program that voices the number of one-tiles and increments and decrements the number of ones using markers. Note that current model range is 0-9, and the voicing strings range from 1-10.",
      "expanded": false,
      "topWhiskerLength": 0.05,
      "rightWhiskerLength": 0.05,
      "bottomWhiskerLength": 0.05,
      "leftWhiskerLength": 0.05,
      "positionProperty": {
        "x": 535.3714888688085,
        "y": 231.80001525878902
      },
      "modelContainer": {
        "namedBooleanProperties": [
          {
            "name": "BooleanOnLeftSideForOnes_D",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          },
          {
            "name": "BooleanNegativeForOnes_D",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          },
          {
            "name": "BooleanGoodConnectionForOnes_D",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          },
          {
            "name": "BooleanBadConnectionForOnes_D",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          }
        ],
        "namedVector2Properties": [
          {
            "name": "PositionForOnesTiles_D",
            "propertyType": "Vector2Property",
            "defaultX": 0,
            "defaultY": 0
          }
        ],
        "namedNumberProperties": [
          {
            "name": "NumberOfOnes_D",
            "propertyType": "NumberProperty",
            "min": 0,
            "max": "9",
            "defaultValue": "0"
          },
          {
            "name": "TermForOnesTile_D",
            "propertyType": "NumberProperty",
            "min": 0,
            "max": "2",
            "defaultValue": "0"
          }
        ],
        "namedEnumerationProperties": [],
        "namedDerivedProperties": [],
        "namedBounds2Properties": [],
        "namedObservableArrays": [],
        "namedArrayItems": [
          {
            "name": "onesTileData_D",
            "arrayName": "tileData",
            "itemSchema": [
              {
                "entryName": "onLeftSide",
                "componentName": "BooleanOnLeftSideForOnes_D"
              },
              {
                "entryName": "negative",
                "componentName": "BooleanNegativeForOnes_D"
              },
              {
                "entryName": "count",
                "componentName": "NumberOfOnes_D"
              },
              {
                "entryName": "term",
                "componentName": "TermForOnesTile_D"
              }
            ]
          }
        ],
        "namedArrayItemReferences": [],
        "namedStringProperties": []
      },
      "controllerContainer": {
        "vector2PropertyControllers": [
          {
            "name": "ControllerPositionForOnes_D",
            "controlledComponentName": "PositionForOnesTiles_D",
            "controlType": "MATCH_CENTER",
            "controlTypeFamily": ""
          }
        ],
        "boundsPropertyControllers": [],
        "booleanPropertyControllers": [
          {
            "name": "ControllerBooleanNegativeForOnes_D",
            "controlledComponentName": "BooleanNegativeForOnes_D",
            "controlType": "ROTATION",
            "controlTypeFamily": "",
            "whiskerConfiguration": {
              "topLength": 0.2,
              "rightLength": 0.2,
              "bottomLength": 0.2,
              "leftLength": 0.2,
              "otherPaperNumber": null
            },
            "markerColor": ""
          }
        ],
        "numberPropertyControllers": [
          {
            "name": "ControllerForOnes_D",
            "controlledComponentName": "NumberOfOnes_D",
            "controlType": "MARKER_COUNT",
            "controlTypeFamily": "MARKERS",
            "markerColor": "all",
            "relationshipControlType": null
          }
        ],
        "enumerationPropertyControllers": []
      },
      "viewContainer": {
        "soundViews": [
          {
            "name": "ViewGoodConnectionSoundForOnes_D",
            "modelComponentNames": [
              "RectangleModelMode",
              "BooleanGoodConnectionForOnes_D"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "if ( BooleanGoodConnectionForOnes_D && RectangleModelMode ) {\r\n    play();\r\n}",
            "lazyLink": false,
            "soundFileName": "/uploads/SuccessSound.mp3",
            "loop": false,
            "autoplay": false
          },
          {
            "name": "ViewBadConnectionSoundForOnes_D",
            "modelComponentNames": [
              "RectangleModelMode",
              "BooleanBadConnectionForOnes_D"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "if ( BooleanBadConnectionForOnes_D && RectangleModelMode) {\r\n    play();\r\n}",
            "lazyLink": false,
            "soundFileName": "/uploads/OutOfBalanceSound.mp3",
            "loop": false,
            "autoplay": false
          }
        ],
        "speechViews": [
          {
            "name": "ViewNumberOfOnes_D",
            "modelComponentNames": [
              "BooleanNegativeForOnes_D",
              "NumberOfOnes_D"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "// A paper with no markers represent a potential stack of tiles\n// Adding or removing markers increments or decrements\n// the number of tiles of that tile type - ONES, x or x-squared.\nphet.paperLand.console.log(NumberOfOnes_D);\nif (Math.floor(NumberOfOnes_D) !== 0) {\n   // Test for negative tile value\n   if (BooleanNegativeForOnes_D) {\n       speak( -Math.floor(NumberOfOnes_D) );\n   }\n   // else assume positive value\n   else {\n       speak( Math.floor(NumberOfOnes_D) );\n   }\n}",
            "lazyLink": false
          }
        ],
        "textViews": [
          {
            "name": "ViewTextTilesForOnes_D",
            "modelComponentNames": [
              "BooleanNegativeForOnes_D",
              "PositionForOnesTiles_D",
              "NumberOfOnes_D"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "if ( BooleanNegativeForOnes_D )  {\n    if ( NumberOfOnes_D === 0 ) {\n        setString('Add negative ones.'); // empty tile\n    }\n    else {\n        setString('] ' + (-NumberOfOnes_D) +  ' [');\n    }\n}\nelse {\n    if ( NumberOfOnes_D === 0 ) {\n        setString('Add ones.'); // empty tile\n    }\n    else {\n    setString('[ ' + ( NumberOfOnes_D ) + ' ]');\n    }\n}\nsetFontSize(20);\nsetCenterX( phet.paperLand.utils.paperToBoardX( PositionForOnesTiles_D.x, sharedData.displaySize.width ))\nsetCenterY( phet.paperLand.utils.paperToBoardY( PositionForOnesTiles_D.y, sharedData.displaySize.height ))",
            "lazyLink": false,
            "defaultViewOptions": {
              "centerX": 0.5,
              "centerY": 0.5,
              "scale": 1,
              "rotation": 0,
              "opacity": 1,
              "visible": true,
              "viewUnits": "model"
            }
          }
        ],
        "shapeViews": [
          {
            "name": "OnesTilesShape_D",
            "modelComponentNames": [
              "BooleanOnLeftSideForOnes_D",
              "BooleanNegativeForOnes_D",
              "PositionForOnesTiles_D",
              "NumberOfOnes_D"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "// Set the rectangle/square to the desired size\n const rectangleHeight = 0.1\n const rectangleWidth = 0.1\n\nsetRectBounds( new phet.dot.Bounds2( 0, 0, rectangleWidth, rectangleHeight * sharedData.displaySize.width / sharedData.displaySize.height ) );\n\nsetVisible(Math.floor(NumberOfOnes_D) !== 0)\nif (BooleanNegativeForOnes_D) {\n    // If negative make a frame tile\n    // setRectBounds( new phet.dot.Bounds2( 0, 0, squareWidth, squareWidth * sharedData.displaySize.width / sharedData.displaySize.height ) );\n    setStroke('#ff0000'); // red\n    setFill('transparent');\t\t// fill\n    setLineWidth(4); // pixels\n}\nelse {\n    // Else assume positive and make a tile: stroke, fill\n    // setRectBounds( new phet.dot.Bounds2( 0, 0, squareWidth, squareWidth * sharedData.displaySize.width / sharedData.displaySize.height ) );\n    setStroke('#ff0000');\t// red\n    setLineWidth(4);\t\t// pixels\n    setFill('#ff0000');\t\t// fill\n    setOpacity( 0.6 );      // make tile transparent\n    // moveToFront();\t\t\t// keep in background behind any text\n}\n\nsetCenterX(PositionForOnesTiles_D.x);\nsetCenterY(PositionForOnesTiles_D.y);\n",
            "lazyLink": false,
            "defaultViewOptions": {
              "centerX": 0.5,
              "centerY": 0.5,
              "scale": 1,
              "rotation": 0,
              "opacity": 1,
              "visible": true,
              "viewUnits": "model"
            },
            "defaultShapeOptions": {
              "shapeType": "rectangle",
              "fill": "lightblue",
              "stroke": "red",
              "lineWidth": 1,
              "rectWidth": 0.5,
              "rectHeight": 0.5,
              "circleRadius": 0.05,
              "ellipseRadiusX": 0.3,
              "ellipseRadiusY": 0.15,
              "lineStartX": 0,
              "lineStartY": 0,
              "lineEndX": 0.3,
              "lineEndY": 0.3,
              "triangleBaseWidth": 0.1,
              "triangleHeight": 0.3,
              "polygonPoints": [
                [
                  0,
                  0
                ],
                [
                  0.1,
                  0
                ],
                [
                  0.1,
                  0.1
                ],
                [
                  0,
                  0.1
                ]
              ]
            }
          }
        ],
        "backgroundViews": [],
        "imageViews": []
      },
      "listenerContainer": {
        "linkListeners": [
          {
            "name": "ControllerBooleanLeftSideForOnes_D",
            "controlledPropertyNames": [
              "BooleanOnLeftSideForOnes_D"
            ],
            "controlFunctionString": "// Uncomment to voice side of equation\nsetBooleanOnLeftSideForOnes_D(BoundsLeftSideOfEquals.containsPoint( PositionForOnesTiles_D )); ",
            "dependencyNames": [
              "BoundsLeftSideOfEquals",
              "PositionForOnesTiles_D"
            ],
            "referenceComponentNames": []
          }
        ],
        "animationListeners": [],
        "bluetoothListeners": []
      },
      "customCodeContainer": {
        "onProgramAddedCode": "// Setting program data to the program for some sound design.\r\nphet.paperLand.setProgramData( paperNumber, 'term', 'ones' );",
        "onProgramRemovedCode": "// Removes the term data from the model\r\nphet.paperLand.removeProgramData( paperNumber, 'term' );\r\n\r\n",
        "onProgramChangedPositionCode": "",
        "onProgramMarkersAddedCode": "",
        "onProgramMarkersRemovedCode": "",
        "onProgramMarkersChangedPositionCode": "",
        "onProgramAdjacentCode": "\r\n// Get a reference to the model component and only update it if it exists.\r\nconst goodConnectionComponent = phet.paperLand.getModelComponent( 'BooleanGoodConnectionForOnes_D' );\r\nconst badConnectionComponent = phet.paperLand.getModelComponent( 'BooleanBadConnectionForOnes_D' );\r\n\r\n\r\nif ( goodConnectionComponent && badConnectionComponent ) {\r\n\r\n    // If this is the left or right whisker...\r\n    if ( direction === 'left' || direction === 'right' ) {\r\n\r\n        // These are the terms that this program is allowed to connect to.\r\n        const goodConnectionTerms = [ 'ones' ];\r\n       \r\n        // These are the terms that this program is NOT allowed to connect to.\r\n        const badConnectionTerms = [ 'x', 'xSquared' ];\r\n\r\n        // This connection is \"good\" if the other program has a term in the good list\r\n        goodConnectionComponent.value = goodConnectionTerms.includes(\r\n\r\n            // get the term from the other program\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        );\r\n        // This connection is \"bad\" if the other program has a term in the bad list\r\n        badConnectionComponent.value = badConnectionTerms.includes(\r\n\r\n            // get the term from the other program\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        );\r\n    }\r\n\r\n    phet.paperLand.console.log( direction );\r\n\r\n    // If this is the top or bottom whisker...\r\n    if ( direction === 'top' || direction === 'bottom' ) {\r\n        \r\n        // These are the terms that this program is allowed to connect to.\r\n        // TODO: Add top and bottom of X tiles\r\n        const goodConnectionTerms = [ 'ones' ];\r\n       \r\n        // These are the terms that this program is NOT allowed to connect to.\r\n        // TODO: Add left and right of X tiles\r\n        const badConnectionTerms = [ 'xSquared' ];\r\n\r\n        // This connection is \"good\" if the other program has a term in the good list\r\n        goodConnectionComponent.value = goodConnectionTerms.includes(\r\n\r\n            // get the term from the other program\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        );\r\n        // This connection is \"bad\" if the other program has a term in the bad list\r\n        badConnectionComponent.value = badConnectionTerms.includes(\r\n\r\n            // get the term from the other program\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        );\r\n    }\r\n}",
        "onProgramSeparatedCode": "\r\n// Get a reference to the model component and only update it if it exists.\r\nconst goodConnectionComponent = phet.paperLand.getModelComponent( 'BooleanGoodConnectionForOnes_D' );\r\nconst badConnectionComponent = phet.paperLand.getModelComponent( 'BooleanBadConnectionForOnes_D' );\r\n\r\n// Components must exit check\r\nif ( goodConnectionComponent && badConnectionComponent )  {\r\n\r\n    // If this is the left or right whisker...\r\n    if ( direction === 'left' || direction === 'right' ) {\r\n\r\n        // These are the terms that this program is allowed to connect to.\r\n        const goodConnectionTerms = [ 'ones' ];\r\n\r\n         // These are the terms that this program is NOT allowed to connect to.\r\n        const badConnectionTerms = [ 'x', 'xSquared' ];\r\n\r\n        // If detatching from another program where connection is \"good\",\r\n        // the connection is no longer there.\r\n        if ( goodConnectionTerms.includes(\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        ) ) {\r\n            goodConnectionComponent.value = false;\r\n        }\r\n        // If detatching from another program where connection is \"bad\",\r\n        // the connection is no longer there.\r\n        if ( badConnectionTerms.includes(\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        ) ) {\r\n            badConnectionComponent.value = false;\r\n        }\r\n    }\r\n\r\n    // If this is the top or bottom whisker...\r\n    if ( direction === 'top' || direction === 'bottom' ) {\r\n\r\n       // These are the terms that this program is allowed to connect to.\r\n       // TODO: top and bottom of X tiles need to be added\r\n        const goodConnectionTerms = [ 'ones' ];\r\n\r\n         // These are the terms that this program is NOT allowed to connect to.\r\n         // TODO: left and right of X tiles need to be added\r\n        const badConnectionTerms = [ 'xSquared' ];\r\n\r\n        // If detatching from another program where connection is \"good\",\r\n        // the connection is no longer there.\r\n        if ( goodConnectionTerms.includes(\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        ) ) {\r\n            goodConnectionComponent.value = false;\r\n        }\r\n        // If detatching from another program where connection is \"bad\",\r\n        // the connection is no longer there.\r\n        if ( badConnectionTerms.includes(\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        ) ) {\r\n            badConnectionComponent.value = false;\r\n        }\r\n    }\r\n}"
      }
    }
  ]
}