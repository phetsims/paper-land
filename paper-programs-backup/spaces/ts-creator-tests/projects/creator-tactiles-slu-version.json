{
  "programs": [
    {
      "number": 183,
      "title": "x Squared Tiles A",
      "keywords": "TacTiles, algebra, voicing, x^2, x, squared, x-squared",
      "description": "A program that voices the number of x-squared tiles (the coefficient of x-squared) and increments and decrements the coefficient using markers.  Note that current model range is 0-9, voicing strings range from x squared to 10x^2.",
      "expanded": false,
      "topWhiskerLength": 0.05,
      "rightWhiskerLength": 0.05,
      "bottomWhiskerLength": 0.05,
      "leftWhiskerLength": 0.05,
      "positionProperty": {
        "x": 295,
        "y": 271.48976383644225
      },
      "modelContainer": {
        "namedBooleanProperties": [
          {
            "name": "BooleanOnLeftSideForXSquared_A",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          },
          {
            "name": "BooleanNegativeForXSquared_A",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          }
        ],
        "namedVector2Properties": [
          {
            "name": "PositionForXSquaredTiles_A",
            "propertyType": "Vector2Property",
            "defaultX": 0,
            "defaultY": 0
          }
        ],
        "namedNumberProperties": [
          {
            "name": "NumberXSquaredCoefficient_A",
            "propertyType": "NumberProperty",
            "min": "0",
            "max": "9",
            "defaultValue": "0"
          }
        ],
        "namedEnumerationProperties": [],
        "namedDerivedProperties": [],
        "namedBounds2Properties": [],
        "namedObservableArrays": [],
        "namedArrayItems": [],
        "namedArrayItemReferences": [],
        "namedStringProperties": []
      },
      "controllerContainer": {
        "vector2PropertyControllers": [
          {
            "name": "ControllerPositionForXSquared_A",
            "controlledComponentName": "PositionForXSquaredTiles_A",
            "controlType": "MATCH_CENTER",
            "controlTypeFamily": ""
          }
        ],
        "boundsPropertyControllers": [],
        "booleanPropertyControllers": [
          {
            "name": "ControllerBooleanNegativeForXSquared_A",
            "controlledComponentName": "BooleanNegativeForXSquared_A",
            "controlType": "ROTATION",
            "controlTypeFamily": "",
            "whiskerConfiguration": {
              "topLength": 0.2,
              "rightLength": 0.2,
              "bottomLength": 0.2,
              "leftLength": 0.2,
              "otherPaperNumber": null
            },
            "markerColor": ""
          }
        ],
        "numberPropertyControllers": [
          {
            "name": "ControllerXSquareCoefficient_A",
            "controlledComponentName": "NumberXSquaredCoefficient_A",
            "controlType": "MARKER_COUNT",
            "controlTypeFamily": "MARKERS",
            "markerColor": "all",
            "relationshipControlType": null
          }
        ],
        "enumerationPropertyControllers": []
      },
      "viewContainer": {
        "soundViews": [],
        "speechViews": [
          {
            "name": "ViewNumberOfXSquared_A",
            "modelComponentNames": [
              "BooleanNegativeForXSquared_A",
              "NumberXSquaredCoefficient_A"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "phet.paperLand.console.log(NumberXSquaredCoefficient_A);\nif (Math.floor(NumberXSquaredCoefficient_A) === 0) {\n // A paper with no markers represents 1x^2 or -1x^2 and \n // in the case of 1x^2 the coefficient does not need to be voiced.\nif (BooleanNegativeForXSquared_A) {\n        speak( 'minus x squared' );\n    }\n    else {\n        speak( 'x squared' );\n    }\n} else {\n    if (BooleanNegativeForXSquared_A) {\n        speak( -Math.floor(NumberXSquaredCoefficient_A) - 1 + 'x squared' );\n    }\n    else {\n        speak( Math.floor(NumberXSquaredCoefficient_A) + 1 + 'x squared' );\n    }\n}",
            "lazyLink": false
          }
        ],
        "textViews": [
          {
            "name": "ViewTextTilesForXSquared_A",
            "modelComponentNames": [
              "BooleanNegativeForXSquared_A",
              "PositionForXSquaredTiles_A",
              "NumberXSquaredCoefficient_A"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "//\n//if (BooleanNegativeForXSquared_A) {\n//    setString('] ' + (-NumberXSquaredCoefficient_A - 1) + 'x^2 [');\n //   }\n //   else {\n//        setString('[ ' + (NumberXSquaredCoefficient_A + 1) + 'x^2 ]');\n //   }\n if (Math.floor(NumberXSquaredCoefficient_A) === 0) {\n    if (BooleanNegativeForXSquared_A) {\n        setString('] ' + '-x^2 [');\n    }\n    else {\n        setString('[ ' + 'x^2  ]');\n    }\n} \nelse {\n    if (BooleanNegativeForXSquared_A) {\n        setString('] ' + (-NumberXSquaredCoefficient_A - 1) + 'x^2 [');\n    }\n    else {\n        setString('[ ' + (NumberXSquaredCoefficient_A + 1) + 'x^2 ]');\n    }\n}\nsetFontSize(20);\nsetCenterX( phet.paperLand.utils.paperToBoardX( PositionForXSquaredTiles_A.x, sharedData.displaySize.width ))\nsetCenterY( phet.paperLand.utils.paperToBoardY( PositionForXSquaredTiles_A.y, sharedData.displaySize.height ))\nphet.paperLand.console.log( phet.paperLand.utils.paperToBoardX( PositionForXSquaredTiles_A.x, sharedData.displaySize.width ));",
            "lazyLink": false,
            "defaultViewOptions": {
              "centerX": 0.5,
              "centerY": 0.5,
              "scale": 1,
              "rotation": 0,
              "opacity": 1,
              "visible": true,
              "viewUnits": "model"
            }
          }
        ],
        "shapeViews": [],
        "backgroundViews": [],
        "imageViews": []
      },
      "listenerContainer": {
        "linkListeners": [
          {
            "name": "ControllerBooleanLeftSideForXSquared_A",
            "controlledPropertyNames": [
              "BooleanOnLeftSideForXSquared_A"
            ],
            "controlFunctionString": "setBooleanOnLeftSideForXSquared_A(BoundsLeftSideOfEquals.containsPoint( PositionForXSquaredTiles_A )); ",
            "dependencyNames": [
              "PositionForXSquaredTiles_A",
              "BoundsLeftSideOfEquals"
            ],
            "referenceComponentNames": []
          }
        ],
        "animationListeners": [],
        "bluetoothListeners": []
      },
      "customCodeContainer": {
        "onProgramAddedCode": "// Setting program data to the program for some sound design.\r\nphet.paperLand.setProgramData( paperNumber, 'term', 'xSquared' );\r\n\r\n// Using addModelObserver lets us add the tiles/bounds programs in any order\r\nscratchpad.observerId = phet.paperLand.addModelObserver(\r\n  'tileData', // the bounds program will create this array when it is added\r\n  tileDataArray => {\r\n\r\n    // as soon as the array is available, add this tile to it\r\n    scratchpad.thisTileData = {\r\n      onLeftSideProperty: phet.paperLand.getModelComponent( 'BooleanOnLeftSideForXSquared_A' ),\r\n      negativeProperty: phet.paperLand.getModelComponent( 'BooleanNegativeForXSquared_A' ),\r\n      countProperty: phet.paperLand.getModelComponent( 'NumberXSquaredCoefficient_A' ),\r\n      term: 'xSquared'\r\n    }\r\n    tileDataArray.push( scratchpad.thisTileData );\r\n  },\r\n  tileDataArray => {\r\n\r\n    // Remove this tile from the array when the array is being removed\r\n    const index = tileDataArray.indexOf( scratchpad.thisTileData );\r\n    if ( index > -1 ) {\r\n        tileDataArray.splice( index, 1 );\r\n        delete scratchpad.tileData;\r\n    }\r\n  }\r\n);",
        "onProgramRemovedCode": "// Removes the term data from the model\r\nphet.paperLand.removeProgramData( paperNumber, 'term' );\r\n\r\nconst tileData = phet.paperLand.getModelComponent( 'tileData' );\r\nif ( tileData ) {\r\n\r\n    // Remove the tile from the array\r\n    const index = tileData.indexOf( scratchpad.thisTileData );\r\n    if ( index > -1 ) {\r\n        tileData.splice( index, 1 );\r\n        delete scratchpad.tileData;        \r\n    }\r\n}\r\n\r\n// remove the model observer\r\nphet.paperLand.removeModelObserver( 'tileData', scratchpad.observerId );\r\ndelete scratchpad.observerId;",
        "onProgramChangedPositionCode": "",
        "onProgramMarkersAddedCode": "",
        "onProgramMarkersRemovedCode": "",
        "onProgramMarkersChangedPositionCode": "",
        "onProgramAdjacentCode": "",
        "onProgramSeparatedCode": ""
      }
    },
    {
      "number": 983,
      "title": "X Tiles A",
      "keywords": "NumberXCoefficient",
      "description": "A program that voices the number of x-tiles (the coefficient of x) and increments and decrements the coefficient using markers.  Note that current model range for the coefficient is 0-9, voicing strings range from x to 10x.",
      "expanded": false,
      "topWhiskerLength": 0.05,
      "rightWhiskerLength": 0.05,
      "bottomWhiskerLength": 0.05,
      "leftWhiskerLength": 0.05,
      "positionProperty": {
        "x": 363.1000061035156,
        "y": 317.74375610351564
      },
      "modelContainer": {
        "namedBooleanProperties": [
          {
            "name": "BooleanOnLeftSideForX",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          },
          {
            "name": "BooleanNegativeForX",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          },
          {
            "name": "BooleanGoodConnectionForX",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          },
          {
            "name": "BooleanBadConnectionForX",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          }
        ],
        "namedVector2Properties": [
          {
            "name": "PositionForXTiles",
            "propertyType": "Vector2Property",
            "defaultX": 0,
            "defaultY": 0
          }
        ],
        "namedNumberProperties": [
          {
            "name": "NumberXCoefficient",
            "propertyType": "NumberProperty",
            "min": 0,
            "max": "9",
            "defaultValue": "0"
          }
        ],
        "namedEnumerationProperties": [],
        "namedDerivedProperties": [],
        "namedBounds2Properties": [],
        "namedObservableArrays": [],
        "namedArrayItems": [],
        "namedArrayItemReferences": [],
        "namedStringProperties": []
      },
      "controllerContainer": {
        "vector2PropertyControllers": [
          {
            "name": "ControllerPositionForX",
            "controlledComponentName": "PositionForXTiles",
            "controlType": "MATCH_CENTER",
            "controlTypeFamily": ""
          }
        ],
        "boundsPropertyControllers": [],
        "booleanPropertyControllers": [
          {
            "name": "ControllerBooleanNegativeForX",
            "controlledComponentName": "BooleanNegativeForX",
            "controlType": "ROTATION",
            "controlTypeFamily": "",
            "whiskerConfiguration": {
              "topLength": 0.2,
              "rightLength": 0.2,
              "bottomLength": 0.2,
              "leftLength": 0.2,
              "otherPaperNumber": null
            },
            "markerColor": ""
          }
        ],
        "numberPropertyControllers": [
          {
            "name": "ControllerXCoefficient",
            "controlledComponentName": "NumberXCoefficient",
            "controlType": "MARKER_COUNT",
            "controlTypeFamily": "MARKERS",
            "markerColor": "all",
            "relationshipControlType": null
          }
        ],
        "enumerationPropertyControllers": []
      },
      "viewContainer": {
        "soundViews": [
          {
            "name": "ViewGoodConnectionSoundForX",
            "modelComponentNames": [
              "BooleanGoodConnectionForX",
              "RectangleModelMode"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "if ( BooleanGoodConnectionForX && RectangleModelMode ) {\r\n    play();\r\n}",
            "lazyLink": false,
            "soundFileName": "/uploads/SuccessSound.mp3",
            "loop": false,
            "autoplay": false
          },
          {
            "name": "ViewBadConnectionSoundForX",
            "modelComponentNames": [
              "BooleanBadConnectionForX",
              "RectangleModelMode"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "if ( BooleanBadConnectionForX && RectangleModelMode ) {\n    play();\n}",
            "lazyLink": false,
            "soundFileName": "/uploads/OutOfBalanceSound.mp3",
            "loop": false,
            "autoplay": false
          }
        ],
        "speechViews": [
          {
            "name": "ViewNumberOfX",
            "modelComponentNames": [
              "BooleanNegativeForX",
              "NumberXCoefficient"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "  // A paper with no markers represents a 1x tile or a -1x tile \n  // and not 0x. We need to add or minus 1, and \n  // for the case of 1x not voice the coefficient. \n  // I think it is ok to voice -1x rather than -x.\nif (Math.floor(NumberXCoefficient) === 0) {\n    if (BooleanNegativeForX) {\n        speak( 'minus x' );\n    }\n    else {\n        speak( 'x' );\n    }\n} else {\n    if (BooleanNegativeForX) {\n        speak( -Math.floor(NumberXCoefficient) - 1 + 'x' );\n    }\n    else {\n        speak( Math.floor(NumberXCoefficient) + 1 + 'x' );\n    }\n}",
            "lazyLink": false
          }
        ],
        "textViews": [
          {
            "name": "ViewTextTilesForXTiles",
            "modelComponentNames": [
              "BooleanNegativeForX",
              "PositionForXTiles",
              "NumberXCoefficient"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "if (Math.floor(NumberXCoefficient) === 0) {\n    if (BooleanNegativeForX) {\n        setString('] ' + '-x [');\n    }\n    else {\n        setString('[ ' + 'x ]');\n    }\n} \nelse {\n    if (BooleanNegativeForX) {\n        setString('] ' + (-NumberXCoefficient - 1) + 'x [');\n    }\n    else {\n        setString('[ ' + (NumberXCoefficient + 1) + 'x ]');\n    }\n}\nsetFontSize(20);\nsetCenterX( phet.paperLand.utils.paperToBoardX( PositionForXTiles.x, sharedData.displaySize.width ))\nsetCenterY( phet.paperLand.utils.paperToBoardY( PositionForXTiles.y, sharedData.displaySize.height ))\nphet.paperLand.console.log( phet.paperLand.utils.paperToBoardX( PositionForXTiles.x, sharedData.displaySize.width ));",
            "lazyLink": false,
            "defaultViewOptions": {
              "centerX": 0.5,
              "centerY": 0.5,
              "scale": 1,
              "rotation": 0,
              "opacity": 1,
              "visible": true,
              "viewUnits": "model"
            }
          }
        ],
        "shapeViews": [],
        "backgroundViews": [],
        "imageViews": []
      },
      "listenerContainer": {
        "linkListeners": [
          {
            "name": "ControllerBooleanLeftSideForX",
            "controlledPropertyNames": [
              "BooleanOnLeftSideForX"
            ],
            "controlFunctionString": "setBooleanOnLeftSideForX(BoundsLeftSideOfEquals.containsPoint( PositionForXTiles )); ",
            "dependencyNames": [
              "PositionForXTiles",
              "BoundsLeftSideOfEquals"
            ],
            "referenceComponentNames": []
          }
        ],
        "animationListeners": [],
        "bluetoothListeners": []
      },
      "customCodeContainer": {
        "onProgramAddedCode": "// Setting program data to the program for some sound design.\r\nphet.paperLand.setProgramData( paperNumber, 'term', 'x' );\r\n\r\n// Using addModelObserver lets us add the tiles/bounds programs in any order\r\nscratchpad.observerId = phet.paperLand.addModelObserver(\r\n  'tileData', // the bounds program will create this array when it is added\r\n  tileDataArray => {\r\n\r\n    // as soon as the array is available, add this tile to it\r\n    scratchpad.thisTileData = {\r\n      onLeftSideProperty: phet.paperLand.getModelComponent( 'BooleanOnLeftSideForX' ),\r\n      negativeProperty: phet.paperLand.getModelComponent( 'BooleanNegativeForX' ),\r\n      countProperty: phet.paperLand.getModelComponent( 'NumberXCoefficient' ),\r\n      term: 'x'\r\n    }\r\n    tileDataArray.push( scratchpad.thisTileData );\r\n  },\r\n  tileDataArray => {\r\n\r\n    // Remove this tile from the array when the array is being removed\r\n    const index = tileDataArray.indexOf( scratchpad.thisTileData );\r\n    if ( index > -1 ) {\r\n        tileDataArray.splice( index, 1 );\r\n        delete scratchpad.tileData;\r\n    }\r\n  }\r\n);",
        "onProgramRemovedCode": "// Removes the term data from the model\r\nphet.paperLand.removeProgramData( paperNumber, 'term' );\r\n\r\nconst tileData = phet.paperLand.getModelComponent( 'tileData' );\r\nif ( tileData ) {\r\n\r\n    // Remove the tile from the array\r\n    const index = tileData.indexOf( scratchpad.thisTileData );\r\n    if ( index > -1 ) {\r\n        tileData.splice( index, 1 );\r\n        delete scratchpad.tileData;        \r\n    }\r\n}\r\n\r\n// remove the model observer\r\nphet.paperLand.removeModelObserver( 'tileData', scratchpad.observerId );\r\ndelete scratchpad.observerId;",
        "onProgramChangedPositionCode": "",
        "onProgramMarkersAddedCode": "",
        "onProgramMarkersRemovedCode": "",
        "onProgramMarkersChangedPositionCode": "",
        "onProgramAdjacentCode": "\n// Get a reference to the model component and only update it if it exists.\nconst goodConnectionComponent = phet.paperLand.getModelComponent( 'BooleanGoodConnectionForX' );\nconst badConnectionComponent = phet.paperLand.getModelComponent( 'BooleanBadConnectionForX' );\n\n\nif ( goodConnectionComponent && badConnectionComponent ) {\n\n    // If this is the left or right whisker...\n    if ( direction === 'left' || direction === 'right' ) {\n\n        // These are the terms that this program is allowed to connect to.\n        const goodConnectionTerms = [ 'xSquared' ];\n       \n        // These are the terms that this program is NOT allowed to connect to.\n        const badConnectionTerms = [ 'ones' ];\n\n        // This connection is \"good\" if the other program has a term in the good list\n        goodConnectionComponent.value = goodConnectionTerms.includes(\n\n            // get the term from the other program\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\n        );\n        // This connection is \"bad\" if the other program has a term in the bad list\n        badConnectionComponent.value = badConnectionTerms.includes(\n\n            // get the term from the other program\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\n        );\n    }\n\n    phet.paperLand.console.log( direction );\n\n    // If this is the top or bottom whisker...\n    if ( direction === 'top' || direction === 'bottom' ) {\n        \n        // These are the terms that this program is allowed to connect to.\n        const goodConnectionTerms = [ 'ones' ];\n       \n        // These are the terms that this program is NOT allowed to connect to.\n        const badConnectionTerms = [ 'xSquared' ];\n\n        // This connection is \"good\" if the other program has a term in the good list\n        goodConnectionComponent.value = goodConnectionTerms.includes(\n\n            // get the term from the other program\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\n        );\n        // This connection is \"bad\" if the other program has a term in the bad list\n        badConnectionComponent.value = badConnectionTerms.includes(\n\n            // get the term from the other program\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\n        );\n    }\n}",
        "onProgramSeparatedCode": "\r\n// Get a reference to the model component and only update it if it exists.\r\nconst goodConnectionComponent = phet.paperLand.getModelComponent( 'BooleanGoodConnectionForX' );\r\nconst badConnectionComponent = phet.paperLand.getModelComponent( 'BooleanBadConnectionForX' );\r\n\r\n// Components must exit check\r\nif ( goodConnectionComponent && badConnectionComponent )  {\r\n\r\n    // If this is the left or right whisker...\r\n    if ( direction === 'left' || direction === 'right' ) {\r\n\r\n        // These are the terms that this program is allowed to connect to.\r\n        const goodConnectionTerms = [ 'xSquared' ];\r\n\r\n         // These are the terms that this program is NOT allowed to connect to.\r\n        const badConnectionTerms = [ 'ones' ];\r\n\r\n        // If detatching from another program where connection is \"good\",\r\n        // the connection is no longer there.\r\n        if ( goodConnectionTerms.includes(\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        ) ) {\r\n            goodConnectionComponent.value = false;\r\n        }\r\n        // If detatching from another program where connection is \"bad\",\r\n        // the connection is no longer there.\r\n        if ( badConnectionTerms.includes(\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        ) ) {\r\n            badConnectionComponent.value = false;\r\n        }\r\n    }\r\n\r\n    // If this is the top or bottom whisker...\r\n    if ( direction === 'top' || direction === 'bottom' ) {\r\n\r\n       // These are the terms that this program is allowed to connect to.\r\n       // TODO: Need to add top and bottom of X tiles\r\n        const goodConnectionTerms = [ 'ones' ];\r\n\r\n         // These are the terms that this program is NOT allowed to connect to.\r\n        // TODO: Need to add left and right of X tiles\r\n        const badConnectionTerms = [ 'xSquared' ];\r\n\r\n        // If detatching from another program where connection is \"good\",\r\n        // the connection is no longer there.\r\n        if ( goodConnectionTerms.includes(\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        ) ) {\r\n            goodConnectionComponent.value = false;\r\n        }\r\n        // If detatching from another program where connection is \"bad\",\r\n        // the connection is no longer there.\r\n        if ( badConnectionTerms.includes(\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        ) ) {\r\n            badConnectionComponent.value = false;\r\n        }\r\n    }\r\n}"
      }
    },
    {
      "number": 673,
      "title": "Ones Tiles A",
      "keywords": "TacTiles, algebra, voicing, ones, one, numbers",
      "description": "A program that voices the number of one-tiles and increments and decrements the number of ones using markers. Note that current model range is 0-9, and the voicing strings range from 1-10.",
      "expanded": false,
      "topWhiskerLength": 0.05,
      "rightWhiskerLength": 0.05,
      "bottomWhiskerLength": 0.05,
      "leftWhiskerLength": 0.05,
      "positionProperty": {
        "x": 371.7960968060974,
        "y": 167.55140039292223
      },
      "modelContainer": {
        "namedBooleanProperties": [
          {
            "name": "BooleanOnLeftSideForOnes",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          },
          {
            "name": "BooleanNegativeForOnes_A",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          },
          {
            "name": "BooleanGoodConnectionForOnes_A",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          },
          {
            "name": "BooleanBadConnectionForOnes_A",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          }
        ],
        "namedVector2Properties": [
          {
            "name": "PositionForOnesTiles_A",
            "propertyType": "Vector2Property",
            "defaultX": 0,
            "defaultY": 0
          }
        ],
        "namedNumberProperties": [
          {
            "name": "NumberOfOnes_A",
            "propertyType": "NumberProperty",
            "min": 0,
            "max": "9",
            "defaultValue": "0"
          }
        ],
        "namedEnumerationProperties": [],
        "namedDerivedProperties": [],
        "namedBounds2Properties": [],
        "namedObservableArrays": [],
        "namedArrayItems": [],
        "namedArrayItemReferences": [],
        "namedStringProperties": []
      },
      "controllerContainer": {
        "vector2PropertyControllers": [
          {
            "name": "ControllerPositionForOnes_A",
            "controlledComponentName": "PositionForOnesTiles_A",
            "controlType": "MATCH_CENTER",
            "controlTypeFamily": ""
          }
        ],
        "boundsPropertyControllers": [],
        "booleanPropertyControllers": [
          {
            "name": "ControllerBooleanNegativeForOnes_A",
            "controlledComponentName": "BooleanNegativeForOnes_A",
            "controlType": "ROTATION",
            "controlTypeFamily": "",
            "whiskerConfiguration": {
              "topLength": 0.2,
              "rightLength": 0.2,
              "bottomLength": 0.2,
              "leftLength": 0.2,
              "otherPaperNumber": null
            },
            "markerColor": ""
          }
        ],
        "numberPropertyControllers": [
          {
            "name": "ControllerForOnes_A",
            "controlledComponentName": "NumberOfOnes_A",
            "controlType": "MARKER_COUNT",
            "controlTypeFamily": "MARKERS",
            "markerColor": "all",
            "relationshipControlType": null
          }
        ],
        "enumerationPropertyControllers": []
      },
      "viewContainer": {
        "soundViews": [
          {
            "name": "ViewGoodConnectionSoundForOnes_A",
            "modelComponentNames": [
              "BooleanGoodConnectionForOnes_A",
              "RectangleModelMode"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "if ( BooleanGoodConnectionForOnes_A && RectangleModelMode ) {\r\n    play();\r\n}",
            "lazyLink": false,
            "soundFileName": "/uploads/SuccessSound.mp3",
            "loop": false,
            "autoplay": false
          },
          {
            "name": "ViewBadConnectionSoundForOnes_A",
            "modelComponentNames": [
              "BooleanBadConnectionForOnes_A",
              "RectangleModelMode"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "if ( BooleanBadConnectionForOnes_A && RectangleModelMode) {\r\n    play();\r\n}",
            "lazyLink": false,
            "soundFileName": "/uploads/OutOfBalanceSound.mp3",
            "loop": false,
            "autoplay": false
          }
        ],
        "speechViews": [
          {
            "name": "ViewNumberOfOnes_A",
            "modelComponentNames": [
              "BooleanNegativeForOnes_A",
              "NumberOfOnes_A"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "phet.paperLand.console.log(NumberOfOnes_A);\nif (Math.floor(NumberOfOnes_A) === 0) {\n// A paper with no markers represents a single 1 tile, so \n// we need to add 1 or -1 to the min value of 0. \n    if (BooleanNegativeForOnes_A) {\n        speak( -1 );\n    }\n    else {\n        speak( 1 );\n    }\n} else {\n    if (BooleanNegativeForOnes_A) {\n        speak( -Math.floor(NumberOfOnes_A) - 1 );\n    }\n    else {\n        speak( Math.floor(NumberOfOnes_A) + 1 );\n    }\n}",
            "lazyLink": false
          }
        ],
        "textViews": [
          {
            "name": "ViewTextTilesForOnes_A",
            "modelComponentNames": [
              "BooleanNegativeForOnes_A",
              "PositionForOnesTiles_A",
              "NumberOfOnes_A"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "if (BooleanNegativeForOnes_A) {\n        setString('] ' + (-NumberOfOnes_A - 1) + ' [');\n    }\n    else {\n        setString('[ ' + (NumberOfOnes_A + 1) + ' ]');\n    }\nsetFontSize(20);\nsetCenterX( phet.paperLand.utils.paperToBoardX( PositionForOnesTiles_A.x, sharedData.displaySize.width ))\nsetCenterY( phet.paperLand.utils.paperToBoardY( PositionForOnesTiles_A.y, sharedData.displaySize.height ))",
            "lazyLink": false,
            "defaultViewOptions": {
              "centerX": 0.5,
              "centerY": 0.5,
              "scale": 1,
              "rotation": 0,
              "opacity": 1,
              "visible": true,
              "viewUnits": "model"
            }
          }
        ],
        "shapeViews": [],
        "backgroundViews": [],
        "imageViews": []
      },
      "listenerContainer": {
        "linkListeners": [
          {
            "name": "ControllerBooleanLeftSideForOnes_A",
            "controlledPropertyNames": [
              "BooleanOnLeftSideForOnes"
            ],
            "controlFunctionString": "// Uncomment to voice side of equation\nsetBooleanOnLeftSideForOnes(BoundsLeftSideOfEquals.containsPoint( PositionForOnesTiles_A )); ",
            "dependencyNames": [
              "PositionForOnesTiles_A",
              "BoundsLeftSideOfEquals"
            ],
            "referenceComponentNames": []
          }
        ],
        "animationListeners": [],
        "bluetoothListeners": []
      },
      "customCodeContainer": {
        "onProgramAddedCode": "// Setting program data to the program for some sound design.\r\nphet.paperLand.setProgramData( paperNumber, 'term', 'ones' );\r\n\r\n// Using addModelObserver lets us add the tiles/bounds programs in any order\r\nscratchpad.observerId = phet.paperLand.addModelObserver(\r\n  'tileData', // the bounds program will create this array when it is added\r\n  tileDataArray => {\r\n\r\n    // as soon as the array is available, add this tile to it\r\n    scratchpad.thisTileData = {\r\n      onLeftSideProperty: phet.paperLand.getModelComponent( 'BooleanOnLeftSideForOnes' ),\r\n      negativeProperty: phet.paperLand.getModelComponent( 'BooleanNegativeForOnes_A' ),\r\n      countProperty: phet.paperLand.getModelComponent( 'NumberOfOnes_A' ),\r\n      term: 'ones'\r\n    }\r\n    tileDataArray.push( scratchpad.thisTileData );\r\n  },\r\n  tileDataArray => {\r\n\r\n    // Remove this tile from the array when the array is being removed\r\n    const index = tileDataArray.indexOf( scratchpad.thisTileData );\r\n    if ( index > -1 ) {\r\n        tileDataArray.splice( index, 1 );\r\n        delete scratchpad.tileData;\r\n    }\r\n  }\r\n);",
        "onProgramRemovedCode": "// Removes the term data from the model\r\nphet.paperLand.removeProgramData( paperNumber, 'term' );\r\n\r\nconst tileData = phet.paperLand.getModelComponent( 'tileData' );\r\nif ( tileData ) {\r\n\r\n    // Remove the tile from the array\r\n    const index = tileData.indexOf( scratchpad.thisTileData );\r\n    if ( index > -1 ) {\r\n        tileData.splice( index, 1 );\r\n        delete scratchpad.tileData;        \r\n    }\r\n}\r\n\r\n// remove the model observer\r\nphet.paperLand.removeModelObserver( 'tileData', scratchpad.observerId );\r\ndelete scratchpad.observerId;",
        "onProgramChangedPositionCode": "",
        "onProgramMarkersAddedCode": "",
        "onProgramMarkersRemovedCode": "",
        "onProgramMarkersChangedPositionCode": "",
        "onProgramAdjacentCode": "\r\n// Get a reference to the model component and only update it if it exists.\r\nconst goodConnectionComponent = phet.paperLand.getModelComponent( 'BooleanGoodConnectionForOnes_A' );\r\nconst badConnectionComponent = phet.paperLand.getModelComponent( 'BooleanBadConnectionForOnes_A' );\r\n\r\n\r\nif ( goodConnectionComponent && badConnectionComponent ) {\r\n\r\n    // If this is the left or right whisker...\r\n    if ( direction === 'left' || direction === 'right' ) {\r\n\r\n        // These are the terms that this program is allowed to connect to.\r\n        const goodConnectionTerms = [ 'ones' ];\r\n       \r\n        // These are the terms that this program is NOT allowed to connect to.\r\n        const badConnectionTerms = [ 'x', 'xSquared' ];\r\n\r\n        // This connection is \"good\" if the other program has a term in the good list\r\n        goodConnectionComponent.value = goodConnectionTerms.includes(\r\n\r\n            // get the term from the other program\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        );\r\n        // This connection is \"bad\" if the other program has a term in the bad list\r\n        badConnectionComponent.value = badConnectionTerms.includes(\r\n\r\n            // get the term from the other program\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        );\r\n    }\r\n\r\n    phet.paperLand.console.log( direction );\r\n\r\n    // If this is the top or bottom whisker...\r\n    if ( direction === 'top' || direction === 'bottom' ) {\r\n        \r\n        // These are the terms that this program is allowed to connect to.\r\n        // TODO: Add top and bottom of X tiles\r\n        const goodConnectionTerms = [ 'ones' ];\r\n       \r\n        // These are the terms that this program is NOT allowed to connect to.\r\n        // TODO: Add left and right of X tiles\r\n        const badConnectionTerms = [ 'xSquared' ];\r\n\r\n        // This connection is \"good\" if the other program has a term in the good list\r\n        goodConnectionComponent.value = goodConnectionTerms.includes(\r\n\r\n            // get the term from the other program\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        );\r\n        // This connection is \"bad\" if the other program has a term in the bad list\r\n        badConnectionComponent.value = badConnectionTerms.includes(\r\n\r\n            // get the term from the other program\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        );\r\n    }\r\n}",
        "onProgramSeparatedCode": "\r\n// Get a reference to the model component and only update it if it exists.\r\nconst goodConnectionComponent = phet.paperLand.getModelComponent( 'BooleanGoodConnectionForOnes_A' );\r\nconst badConnectionComponent = phet.paperLand.getModelComponent( 'BooleanBadConnectionForOnes_A' );\r\n\r\n// Components must exit check\r\nif ( goodConnectionComponent && badConnectionComponent )  {\r\n\r\n    // If this is the left or right whisker...\r\n    if ( direction === 'left' || direction === 'right' ) {\r\n\r\n        // These are the terms that this program is allowed to connect to.\r\n        const goodConnectionTerms = [ 'ones' ];\r\n\r\n         // These are the terms that this program is NOT allowed to connect to.\r\n        const badConnectionTerms = [ 'x', 'xSquared' ];\r\n\r\n        // If detatching from another program where connection is \"good\",\r\n        // the connection is no longer there.\r\n        if ( goodConnectionTerms.includes(\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        ) ) {\r\n            goodConnectionComponent.value = false;\r\n        }\r\n        // If detatching from another program where connection is \"bad\",\r\n        // the connection is no longer there.\r\n        if ( badConnectionTerms.includes(\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        ) ) {\r\n            badConnectionComponent.value = false;\r\n        }\r\n    }\r\n\r\n    // If this is the top or bottom whisker...\r\n    if ( direction === 'top' || direction === 'bottom' ) {\r\n\r\n       // These are the terms that this program is allowed to connect to.\r\n       // TODO: top and bottom of X tiles need to be added\r\n        const goodConnectionTerms = [ 'ones' ];\r\n\r\n         // These are the terms that this program is NOT allowed to connect to.\r\n         // TODO: left and right of X tiles need to be added\r\n        const badConnectionTerms = [ 'xSquared' ];\r\n\r\n        // If detatching from another program where connection is \"good\",\r\n        // the connection is no longer there.\r\n        if ( goodConnectionTerms.includes(\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        ) ) {\r\n            goodConnectionComponent.value = false;\r\n        }\r\n        // If detatching from another program where connection is \"bad\",\r\n        // the connection is no longer there.\r\n        if ( badConnectionTerms.includes(\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        ) ) {\r\n            badConnectionComponent.value = false;\r\n        }\r\n    }\r\n}"
      }
    },
    {
      "number": 802,
      "title": "Equation Bounds TacTiles",
      "keywords": "TactTiles, algebra, voicing, balanced equations",
      "description": "A program that defines the bounds of an algebraic equation, so that the other programs representing tiles can be placed on the left and right sides of the camera's view and which can be interpreted as being on the left and right sides an the equal sign. ",
      "expanded": false,
      "topWhiskerLength": 0.2,
      "rightWhiskerLength": 0.2,
      "bottomWhiskerLength": 0.2,
      "leftWhiskerLength": 0.2,
      "positionProperty": {
        "x": 463.4179336387593,
        "y": 351.1000061035156
      },
      "modelContainer": {
        "namedBooleanProperties": [],
        "namedVector2Properties": [
          {
            "name": "BoundsPositionModel",
            "propertyType": "Vector2Property",
            "defaultX": 0,
            "defaultY": 0
          }
        ],
        "namedNumberProperties": [
          {
            "name": "BoundsRotationModel",
            "propertyType": "NumberProperty",
            "min": 0,
            "max": 10,
            "defaultValue": 5
          }
        ],
        "namedEnumerationProperties": [],
        "namedDerivedProperties": [],
        "namedBounds2Properties": [
          {
            "name": "BoundsLeftSideOfEquals",
            "propertyType": "Bounds2Property",
            "defaultMinX": 0,
            "defaultMinY": "0.1",
            "defaultMaxX": "0.5",
            "defaultMaxY": 1
          },
          {
            "name": "BoundsRightSideOfEquals",
            "propertyType": "Bounds2Property",
            "defaultMinX": "0.5",
            "defaultMinY": "0.1",
            "defaultMaxX": "1",
            "defaultMaxY": 1
          }
        ],
        "namedObservableArrays": [],
        "namedArrayItems": [],
        "namedArrayItemReferences": [],
        "namedStringProperties": []
      },
      "controllerContainer": {
        "vector2PropertyControllers": [
          {
            "name": "ControllerBoundsPosition",
            "controlledComponentName": "BoundsPositionModel",
            "controlType": "MATCH_CENTER",
            "controlTypeFamily": ""
          }
        ],
        "boundsPropertyControllers": [],
        "booleanPropertyControllers": [],
        "numberPropertyControllers": [
          {
            "name": "ControllerBoundsRotationVoicer",
            "controlledComponentName": "BoundsRotationModel",
            "controlType": "ROTATION",
            "controlTypeFamily": "PAPER_MOVEMENT",
            "markerColor": "all",
            "relationshipControlType": "LINEAR"
          }
        ],
        "enumerationPropertyControllers": []
      },
      "viewContainer": {
        "soundViews": [],
        "speechViews": [
          {
            "name": "ViewVoiceBoundsRotation",
            "modelComponentNames": [
              "BoundsRotationModel"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "// tileData is created in custom code for this program so we know it exists\nconst tileData = phet.paperLand.getModelComponent( 'tileData' );\n\nif ( BoundsRotationModel >= 1 && BoundsRotationModel <= 4 ) {\n\n    // find all of the entries of tile data that are on the left side\n    const rightTiles = tileData.filter( data => !data.onLeftSideProperty.value );\n    speak( scratchpad.getTermDescriptionForSide( rightTiles, 'right' ) );\n\n} else if ( BoundsRotationModel >= 6 && BoundsRotationModel <= 9 ) {\n\n    // find all of the entries of tile data that are on the left side\n    const leftTiles = tileData.filter( data => data.onLeftSideProperty.value );\n    speak( scratchpad.getTermDescriptionForSide( leftTiles, 'left' ) );\n}\n\n\n\n\n\n\n\n\n\n",
            "lazyLink": false
          }
        ],
        "textViews": [],
        "shapeViews": [
          {
            "name": "ViewLeftBackground",
            "modelComponentNames": [
              "BoundsLeftSideOfEquals"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "setRectBounds(BoundsLeftSideOfEquals);",
            "lazyLink": false,
            "defaultViewOptions": {
              "centerX": null,
              "centerY": null,
              "scale": 1,
              "rotation": 0,
              "opacity": "0.5",
              "visible": true,
              "viewUnits": "model"
            },
            "defaultShapeOptions": {
              "shapeType": "rectangle",
              "fill": "#007BFF",
              "stroke": "#000000",
              "lineWidth": 1,
              "rectWidth": 100,
              "rectHeight": 50,
              "circleRadius": 50,
              "ellipseRadiusX": 100,
              "ellipseRadiusY": 50,
              "lineStartX": 0,
              "lineStartY": 0,
              "lineEndX": 100,
              "lineEndY": 100,
              "triangleBaseWidth": 100,
              "triangleHeight": 100,
              "polygonPoints": [
                [
                  0,
                  0
                ],
                [
                  100,
                  0
                ],
                [
                  100,
                  100
                ],
                [
                  0,
                  100
                ]
              ]
            }
          },
          {
            "name": "ViewRightBackground",
            "modelComponentNames": [
              "BoundsRightSideOfEquals"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "setRectBounds(BoundsRightSideOfEquals);",
            "lazyLink": false,
            "defaultViewOptions": {
              "centerX": null,
              "centerY": null,
              "scale": 1,
              "rotation": 0,
              "opacity": "0.5",
              "visible": true,
              "viewUnits": "model"
            },
            "defaultShapeOptions": {
              "shapeType": "rectangle",
              "fill": "#87CEEB",
              "stroke": "#000000",
              "lineWidth": 1,
              "rectWidth": 100,
              "rectHeight": 50,
              "circleRadius": 50,
              "ellipseRadiusX": 100,
              "ellipseRadiusY": 50,
              "lineStartX": 0,
              "lineStartY": 0,
              "lineEndX": 100,
              "lineEndY": 100,
              "triangleBaseWidth": 100,
              "triangleHeight": 100,
              "polygonPoints": [
                [
                  0,
                  0
                ],
                [
                  100,
                  0
                ],
                [
                  100,
                  100
                ],
                [
                  0,
                  100
                ]
              ]
            }
          }
        ],
        "backgroundViews": [],
        "imageViews": []
      },
      "listenerContainer": {
        "linkListeners": [],
        "animationListeners": [],
        "bluetoothListeners": []
      },
      "customCodeContainer": {
        "onProgramAddedCode": "// A collection of tile data will be placed here so that we can inspect all existing tiles\r\n// in the model.\r\nphet.paperLand.addModelComponent( 'tileData', [] );\r\n\r\n// A function to generate a description for a particular side.\r\nscratchpad.getTermDescriptionForSide = ( tileData, leftOrRightString ) => {\r\n    const xSquaredTiles = tileData.filter( data => data.term === 'xSquared' );\r\n    const xTiles = tileData.filter( data => data.term === 'x' );\r\n    const onesTiles = tileData.filter( data => data.term === 'ones' );\r\n\r\n    let description= '';\r\n\r\n    const handleTile = ( tile, term, includeOne ) => {\r\n        if ( tile.negativeProperty.value ) {\r\n\r\n            // always describe if it is a negative operation\r\n            description += 'minus';\r\n        }\r\n        else if ( description.length > 0 ) {\r\n\r\n            // if there are terms before this one, include the operation\r\n            description += 'plus';\r\n        }\r\n        if ( includeOne || tile.countProperty.value > 0 ) {\r\n\r\n            // if we include the 'one' description OR there are more than one\r\n            // in the count, include the number\r\n            description += ` ${tile.countProperty.value + 1}`; \r\n        }\r\n        description += `${term}`;\r\n    }\r\n\r\n    xSquaredTiles.forEach( tile => handleTile( tile, 'x squared', false ) );\r\n    xTiles.forEach( tile => handleTile( tile, 'x', false ) );\r\n    onesTiles.forEach( tile => handleTile( tile, '', true ) );\r\n\r\n    if ( description ) {\r\n        return description + leftOrRightString + ' of equals.';\r\n    }\r\n    else {\r\n        return 'No tiles ' + leftOrRightString + ' of equals.';\r\n    }\r\n};\r\n",
        "onProgramRemovedCode": "phet.paperLand.removeModelComponent( 'tileData' )",
        "onProgramChangedPositionCode": "",
        "onProgramMarkersAddedCode": "",
        "onProgramMarkersRemovedCode": "",
        "onProgramMarkersChangedPositionCode": "",
        "onProgramAdjacentCode": "",
        "onProgramSeparatedCode": ""
      }
    },
    {
      "number": 1413,
      "title": "Equation01",
      "keywords": "TacTiles, equation, example, simple",
      "description": "Program to print and voice equation 1 at top of display.",
      "expanded": false,
      "topWhiskerLength": 0.2,
      "rightWhiskerLength": 0.2,
      "bottomWhiskerLength": 0.2,
      "leftWhiskerLength": 0.2,
      "positionProperty": {
        "x": 62.60157012939453,
        "y": 84.33329696101227
      },
      "modelContainer": {
        "namedBooleanProperties": [
          {
            "name": "BooleanIsRotatedEquation01",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          }
        ],
        "namedVector2Properties": [
          {
            "name": "Equation01Position",
            "propertyType": "Vector2Property",
            "defaultX": "0.5",
            "defaultY": "0.05"
          }
        ],
        "namedNumberProperties": [],
        "namedEnumerationProperties": [],
        "namedDerivedProperties": [],
        "namedBounds2Properties": [],
        "namedObservableArrays": [],
        "namedArrayItems": [],
        "namedArrayItemReferences": [],
        "namedStringProperties": []
      },
      "controllerContainer": {
        "vector2PropertyControllers": [],
        "boundsPropertyControllers": [],
        "booleanPropertyControllers": [
          {
            "name": "ControllerReVoiceEquation01",
            "controlledComponentName": "BooleanIsRotatedEquation01",
            "controlType": "ROTATION",
            "controlTypeFamily": "",
            "whiskerConfiguration": {
              "topLength": 0.2,
              "rightLength": 0.2,
              "bottomLength": 0.2,
              "leftLength": 0.2,
              "otherPaperNumber": null
            },
            "markerColor": ""
          }
        ],
        "numberPropertyControllers": [],
        "enumerationPropertyControllers": []
      },
      "viewContainer": {
        "soundViews": [],
        "speechViews": [
          {
            "name": "ViewVoiceEquation01",
            "modelComponentNames": [
              "BooleanIsRotatedEquation01"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "// 3x  = 2x - 3\nspeak( \"3x equals 2x minus 3\" );",
            "lazyLink": false
          }
        ],
        "textViews": [
          {
            "name": "ViewTextEquation01",
            "modelComponentNames": [
              "Equation01Position"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "setString( '3x  = 2x - 3' );\nsetFontSize(40);\nsetFontFamily('serif');\nsetCenterX( phet.paperLand.utils.paperToBoardX( Equation01Position.x, sharedData.displaySize.width ));\nsetCenterY( phet.paperLand.utils.paperToBoardY( Equation01Position.y, sharedData.displaySize.height ));",
            "lazyLink": false,
            "defaultViewOptions": {
              "centerX": 0.5,
              "centerY": 0.5,
              "scale": 1,
              "rotation": 0,
              "opacity": 1,
              "visible": true,
              "viewUnits": "model"
            }
          }
        ],
        "shapeViews": [],
        "backgroundViews": [],
        "imageViews": []
      },
      "listenerContainer": {
        "linkListeners": [],
        "animationListeners": [],
        "bluetoothListeners": []
      },
      "customCodeContainer": {
        "onProgramAddedCode": "",
        "onProgramRemovedCode": "",
        "onProgramChangedPositionCode": "",
        "onProgramMarkersAddedCode": "",
        "onProgramMarkersRemovedCode": "",
        "onProgramMarkersChangedPositionCode": "",
        "onProgramAdjacentCode": "",
        "onProgramSeparatedCode": ""
      }
    },
    {
      "number": 1802,
      "title": "Rectangle Model",
      "keywords": "",
      "description": "Adding this program will enable connection sounds between tiles.",
      "expanded": false,
      "topWhiskerLength": 0.2,
      "rightWhiskerLength": 0.2,
      "bottomWhiskerLength": 0.2,
      "leftWhiskerLength": 0.2,
      "positionProperty": {
        "x": 27.49609375,
        "y": 568
      },
      "modelContainer": {
        "namedBooleanProperties": [
          {
            "name": "RectangleModelMode",
            "defaultValue": true,
            "propertyType": "BooleanProperty"
          }
        ],
        "namedVector2Properties": [],
        "namedNumberProperties": [],
        "namedEnumerationProperties": [],
        "namedDerivedProperties": [],
        "namedBounds2Properties": [],
        "namedObservableArrays": [],
        "namedArrayItems": [],
        "namedArrayItemReferences": [],
        "namedStringProperties": []
      },
      "controllerContainer": {
        "vector2PropertyControllers": [],
        "boundsPropertyControllers": [],
        "booleanPropertyControllers": [],
        "numberPropertyControllers": [],
        "enumerationPropertyControllers": []
      },
      "viewContainer": {
        "soundViews": [],
        "speechViews": [
          {
            "name": "ViewVoiceRectangleModelHelpText",
            "modelComponentNames": [
              "RectangleModelMode"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "return ( 'Make a rectangle with your tiles. Keep long sides on long sides and short sides on short sides.' );",
            "lazyLink": false
          }
        ],
        "textViews": [],
        "shapeViews": [],
        "backgroundViews": [],
        "imageViews": []
      },
      "listenerContainer": {
        "linkListeners": [],
        "animationListeners": [],
        "bluetoothListeners": []
      },
      "customCodeContainer": {
        "onProgramAddedCode": "",
        "onProgramRemovedCode": "",
        "onProgramChangedPositionCode": "",
        "onProgramMarkersAddedCode": "",
        "onProgramMarkersRemovedCode": "",
        "onProgramMarkersChangedPositionCode": "",
        "onProgramAdjacentCode": "",
        "onProgramSeparatedCode": ""
      }
    },
    {
      "number": 264,
      "title": "Equation02",
      "keywords": "TacTiles, equation, example, simple",
      "description": "Program to print and voice equation 1 at top of display.",
      "expanded": false,
      "topWhiskerLength": 0.2,
      "rightWhiskerLength": 0.2,
      "bottomWhiskerLength": 0.2,
      "leftWhiskerLength": 0.2,
      "positionProperty": {
        "x": 54.65703582763672,
        "y": 134.26297683161772
      },
      "modelContainer": {
        "namedBooleanProperties": [
          {
            "name": "BooleanIsRotatedEquation02",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          }
        ],
        "namedVector2Properties": [
          {
            "name": "Equation02Position",
            "propertyType": "Vector2Property",
            "defaultX": "0.5",
            "defaultY": "0.05"
          }
        ],
        "namedNumberProperties": [],
        "namedEnumerationProperties": [],
        "namedDerivedProperties": [],
        "namedBounds2Properties": [],
        "namedObservableArrays": [],
        "namedArrayItems": [],
        "namedArrayItemReferences": [],
        "namedStringProperties": []
      },
      "controllerContainer": {
        "vector2PropertyControllers": [],
        "boundsPropertyControllers": [],
        "booleanPropertyControllers": [
          {
            "name": "ControllerReVoiceEquation02",
            "controlledComponentName": "BooleanIsRotatedEquation02",
            "controlType": "ROTATION",
            "controlTypeFamily": "",
            "whiskerConfiguration": {
              "topLength": 0.2,
              "rightLength": 0.2,
              "bottomLength": 0.2,
              "leftLength": 0.2,
              "otherPaperNumber": null
            },
            "markerColor": ""
          }
        ],
        "numberPropertyControllers": [],
        "enumerationPropertyControllers": []
      },
      "viewContainer": {
        "soundViews": [],
        "speechViews": [
          {
            "name": "ViewVoiceEquation02",
            "modelComponentNames": [
              "BooleanIsRotatedEquation02"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "// 3x  = 2x - 3\nspeak( \"3x^2 equals x^2 plus 8\" );",
            "lazyLink": false
          }
        ],
        "textViews": [
          {
            "name": "ViewTextEquation02",
            "modelComponentNames": [
              "Equation02Position"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "setString( '3x^2 = x^2 + 8' );\nsetFontSize(40);\nsetFontFamily('serif');\nsetCenterX( phet.paperLand.utils.paperToBoardX( Equation02Position.x, sharedData.displaySize.width ));\nsetCenterY( phet.paperLand.utils.paperToBoardY( Equation02Position.y, sharedData.displaySize.height ));",
            "lazyLink": false,
            "defaultViewOptions": {
              "centerX": 0.5,
              "centerY": 0.5,
              "scale": 1,
              "rotation": 0,
              "opacity": 1,
              "visible": true,
              "viewUnits": "model"
            }
          }
        ],
        "shapeViews": [],
        "backgroundViews": [],
        "imageViews": []
      },
      "listenerContainer": {
        "linkListeners": [],
        "animationListeners": [],
        "bluetoothListeners": []
      },
      "customCodeContainer": {
        "onProgramAddedCode": "",
        "onProgramRemovedCode": "",
        "onProgramChangedPositionCode": "",
        "onProgramMarkersAddedCode": "",
        "onProgramMarkersRemovedCode": "",
        "onProgramMarkersChangedPositionCode": "",
        "onProgramAdjacentCode": "",
        "onProgramSeparatedCode": ""
      }
    },
    {
      "number": 1394,
      "title": "Equation03",
      "keywords": "TacTiles, equation, example, simple",
      "description": "Program to print and voice equation 1 at top of display.",
      "expanded": false,
      "topWhiskerLength": 0.2,
      "rightWhiskerLength": 0.2,
      "bottomWhiskerLength": 0.2,
      "leftWhiskerLength": 0.2,
      "positionProperty": {
        "x": 7.42578125,
        "y": 185.44188613337553
      },
      "modelContainer": {
        "namedBooleanProperties": [
          {
            "name": "BooleanIsRotatedEquation03",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          }
        ],
        "namedVector2Properties": [
          {
            "name": "Equation03Position",
            "propertyType": "Vector2Property",
            "defaultX": "0.5",
            "defaultY": "0.05"
          }
        ],
        "namedNumberProperties": [],
        "namedEnumerationProperties": [],
        "namedDerivedProperties": [],
        "namedBounds2Properties": [],
        "namedObservableArrays": [],
        "namedArrayItems": [],
        "namedArrayItemReferences": [],
        "namedStringProperties": []
      },
      "controllerContainer": {
        "vector2PropertyControllers": [],
        "boundsPropertyControllers": [],
        "booleanPropertyControllers": [
          {
            "name": "ControllerReVoiceEquation03",
            "controlledComponentName": "BooleanIsRotatedEquation03",
            "controlType": "ROTATION",
            "controlTypeFamily": "",
            "whiskerConfiguration": {
              "topLength": 0.2,
              "rightLength": 0.2,
              "bottomLength": 0.2,
              "leftLength": 0.2,
              "otherPaperNumber": null
            },
            "markerColor": ""
          }
        ],
        "numberPropertyControllers": [],
        "enumerationPropertyControllers": []
      },
      "viewContainer": {
        "soundViews": [],
        "speechViews": [
          {
            "name": "ViewVoiceEquation03",
            "modelComponentNames": [
              "BooleanIsRotatedEquation03"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "// 3x  = 2x - 3\nspeak( \"2x plus 3 equals 7 \" );",
            "lazyLink": false
          }
        ],
        "textViews": [
          {
            "name": "ViewTextEquation03",
            "modelComponentNames": [
              "Equation03Position"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "setString( '2x + 3 = 7' );\nsetFontSize(40);\nsetFontFamily('serif');\nsetCenterX( phet.paperLand.utils.paperToBoardX( Equation03Position.x, sharedData.displaySize.width ));\nsetCenterY( phet.paperLand.utils.paperToBoardY( Equation03Position.y, sharedData.displaySize.height ));",
            "lazyLink": false,
            "defaultViewOptions": {
              "centerX": 0.5,
              "centerY": 0.5,
              "scale": 1,
              "rotation": 0,
              "opacity": 1,
              "visible": true,
              "viewUnits": "model"
            }
          }
        ],
        "shapeViews": [],
        "backgroundViews": [],
        "imageViews": []
      },
      "listenerContainer": {
        "linkListeners": [],
        "animationListeners": [],
        "bluetoothListeners": []
      },
      "customCodeContainer": {
        "onProgramAddedCode": "",
        "onProgramRemovedCode": "",
        "onProgramChangedPositionCode": "",
        "onProgramMarkersAddedCode": "",
        "onProgramMarkersRemovedCode": "",
        "onProgramMarkersChangedPositionCode": "",
        "onProgramAdjacentCode": "",
        "onProgramSeparatedCode": ""
      }
    },
    {
      "number": 505,
      "title": "Equation04",
      "keywords": "TacTiles, equation, example, simple",
      "description": "Program to print and voice equation at top of display.",
      "expanded": false,
      "topWhiskerLength": 0.2,
      "rightWhiskerLength": 0.2,
      "bottomWhiskerLength": 0.2,
      "leftWhiskerLength": 0.2,
      "positionProperty": {
        "x": 45.840092216981645,
        "y": 144.12001723689116
      },
      "modelContainer": {
        "namedBooleanProperties": [
          {
            "name": "BooleanIsRotatedEquation04",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          }
        ],
        "namedVector2Properties": [
          {
            "name": "Equation04Position",
            "propertyType": "Vector2Property",
            "defaultX": "0.5",
            "defaultY": "0.05"
          }
        ],
        "namedNumberProperties": [],
        "namedEnumerationProperties": [],
        "namedDerivedProperties": [],
        "namedBounds2Properties": [],
        "namedObservableArrays": [],
        "namedArrayItems": [],
        "namedArrayItemReferences": [],
        "namedStringProperties": []
      },
      "controllerContainer": {
        "vector2PropertyControllers": [],
        "boundsPropertyControllers": [],
        "booleanPropertyControllers": [
          {
            "name": "ControllerReVoiceEquation04",
            "controlledComponentName": "BooleanIsRotatedEquation04",
            "controlType": "ROTATION",
            "controlTypeFamily": "",
            "whiskerConfiguration": {
              "topLength": 0.2,
              "rightLength": 0.2,
              "bottomLength": 0.2,
              "leftLength": 0.2,
              "otherPaperNumber": null
            },
            "markerColor": ""
          }
        ],
        "numberPropertyControllers": [],
        "enumerationPropertyControllers": []
      },
      "viewContainer": {
        "soundViews": [],
        "speechViews": [
          {
            "name": "ViewVoiceEquation04",
            "modelComponentNames": [
              "BooleanIsRotatedEquation04"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "// 3x  = 2x - 3\nspeak( \"4x plus 4 equals 2x\" );",
            "lazyLink": false
          }
        ],
        "textViews": [
          {
            "name": "ViewTextEquation04",
            "modelComponentNames": [
              "Equation04Position"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "setString( '4x + 4 = 2x' );\nsetFontSize(40);\nsetFontFamily('serif');\nsetCenterX( phet.paperLand.utils.paperToBoardX( Equation04Position.x, sharedData.displaySize.width ));\nsetCenterY( phet.paperLand.utils.paperToBoardY( Equation04Position.y, sharedData.displaySize.height ));",
            "lazyLink": false,
            "defaultViewOptions": {
              "centerX": 0.5,
              "centerY": 0.5,
              "scale": 1,
              "rotation": 0,
              "opacity": 1,
              "visible": true,
              "viewUnits": "model"
            }
          }
        ],
        "shapeViews": [],
        "backgroundViews": [],
        "imageViews": []
      },
      "listenerContainer": {
        "linkListeners": [],
        "animationListeners": [],
        "bluetoothListeners": []
      },
      "customCodeContainer": {
        "onProgramAddedCode": "",
        "onProgramRemovedCode": "",
        "onProgramChangedPositionCode": "",
        "onProgramMarkersAddedCode": "",
        "onProgramMarkersRemovedCode": "",
        "onProgramMarkersChangedPositionCode": "",
        "onProgramAdjacentCode": "",
        "onProgramSeparatedCode": ""
      }
    },
    {
      "number": 1461,
      "title": "Equation05",
      "keywords": "TacTiles, equation, example, simple",
      "description": "Program to print and voice equation at top of display.",
      "expanded": false,
      "topWhiskerLength": 0.2,
      "rightWhiskerLength": 0.2,
      "bottomWhiskerLength": 0.2,
      "leftWhiskerLength": 0.2,
      "positionProperty": {
        "x": 45.38540319110274,
        "y": 228.66063613337553
      },
      "modelContainer": {
        "namedBooleanProperties": [
          {
            "name": "BooleanIsRotatedEquation05",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          }
        ],
        "namedVector2Properties": [
          {
            "name": "Equation05Position",
            "propertyType": "Vector2Property",
            "defaultX": "0.5",
            "defaultY": "0.05"
          }
        ],
        "namedNumberProperties": [],
        "namedEnumerationProperties": [],
        "namedDerivedProperties": [],
        "namedBounds2Properties": [],
        "namedObservableArrays": [],
        "namedArrayItems": [],
        "namedArrayItemReferences": [],
        "namedStringProperties": []
      },
      "controllerContainer": {
        "vector2PropertyControllers": [],
        "boundsPropertyControllers": [],
        "booleanPropertyControllers": [
          {
            "name": "ControllerReVoiceEquation05",
            "controlledComponentName": "BooleanIsRotatedEquation05",
            "controlType": "ROTATION",
            "controlTypeFamily": "",
            "whiskerConfiguration": {
              "topLength": 0.2,
              "rightLength": 0.2,
              "bottomLength": 0.2,
              "leftLength": 0.2,
              "otherPaperNumber": null
            },
            "markerColor": ""
          }
        ],
        "numberPropertyControllers": [],
        "enumerationPropertyControllers": []
      },
      "viewContainer": {
        "soundViews": [],
        "speechViews": [
          {
            "name": "ViewVoiceEquation05",
            "modelComponentNames": [
              "BooleanIsRotatedEquation05"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "// 3x  = 2x - 3\nspeak( \"4x minus 4 equals 3x\" );",
            "lazyLink": false
          }
        ],
        "textViews": [
          {
            "name": "ViewTextEquation05",
            "modelComponentNames": [
              "Equation05Position"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "setString( '4x - 4 = 3x' );\nsetFontSize(40);\nsetFontFamily('serif');\nsetCenterX( phet.paperLand.utils.paperToBoardX( Equation05Position.x, sharedData.displaySize.width ));\nsetCenterY( phet.paperLand.utils.paperToBoardY( Equation05Position.y, sharedData.displaySize.height ));",
            "lazyLink": false,
            "defaultViewOptions": {
              "centerX": 0.5,
              "centerY": 0.5,
              "scale": 1,
              "rotation": 0,
              "opacity": 1,
              "visible": true,
              "viewUnits": "model"
            }
          }
        ],
        "shapeViews": [],
        "backgroundViews": [],
        "imageViews": []
      },
      "listenerContainer": {
        "linkListeners": [],
        "animationListeners": [],
        "bluetoothListeners": []
      },
      "customCodeContainer": {
        "onProgramAddedCode": "",
        "onProgramRemovedCode": "",
        "onProgramChangedPositionCode": "",
        "onProgramMarkersAddedCode": "",
        "onProgramMarkersRemovedCode": "",
        "onProgramMarkersChangedPositionCode": "",
        "onProgramAdjacentCode": "",
        "onProgramSeparatedCode": ""
      }
    },
    {
      "number": 620,
      "title": "Equation06",
      "keywords": "TacTiles, equation, example, simple",
      "description": "Program to print and voice equation at top of display.",
      "expanded": false,
      "topWhiskerLength": 0.2,
      "rightWhiskerLength": 0.2,
      "bottomWhiskerLength": 0.2,
      "leftWhiskerLength": 0.2,
      "positionProperty": {
        "x": 10.04165319110274,
        "y": 271.66063613337553
      },
      "modelContainer": {
        "namedBooleanProperties": [
          {
            "name": "BooleanIsRotatedEquation06",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          }
        ],
        "namedVector2Properties": [
          {
            "name": "Equation06Position",
            "propertyType": "Vector2Property",
            "defaultX": "0.5",
            "defaultY": "0.05"
          }
        ],
        "namedNumberProperties": [],
        "namedEnumerationProperties": [],
        "namedDerivedProperties": [],
        "namedBounds2Properties": [],
        "namedObservableArrays": [],
        "namedArrayItems": [],
        "namedArrayItemReferences": [],
        "namedStringProperties": []
      },
      "controllerContainer": {
        "vector2PropertyControllers": [],
        "boundsPropertyControllers": [],
        "booleanPropertyControllers": [
          {
            "name": "ControllerReVoiceEquation06",
            "controlledComponentName": "BooleanIsRotatedEquation06",
            "controlType": "ROTATION",
            "controlTypeFamily": "",
            "whiskerConfiguration": {
              "topLength": 0.2,
              "rightLength": 0.2,
              "bottomLength": 0.2,
              "leftLength": 0.2,
              "otherPaperNumber": null
            },
            "markerColor": ""
          }
        ],
        "numberPropertyControllers": [],
        "enumerationPropertyControllers": []
      },
      "viewContainer": {
        "soundViews": [],
        "speechViews": [
          {
            "name": "ViewVoiceEquation06",
            "modelComponentNames": [
              "BooleanIsRotatedEquation06"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "// 3x  = 2x - 3\nspeak( \"2x minus 4 equals 3x\" );",
            "lazyLink": false
          }
        ],
        "textViews": [
          {
            "name": "ViewTextEquation06",
            "modelComponentNames": [
              "Equation06Position"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "setString( '2x - 4 = 3x' );\nsetFontSize(40);\nsetFontFamily('serif');\nsetCenterX( phet.paperLand.utils.paperToBoardX( Equation06Position.x, sharedData.displaySize.width ));\nsetCenterY( phet.paperLand.utils.paperToBoardY( Equation06Position.y, sharedData.displaySize.height ));",
            "lazyLink": false,
            "defaultViewOptions": {
              "centerX": 0.5,
              "centerY": 0.5,
              "scale": 1,
              "rotation": 0,
              "opacity": 1,
              "visible": true,
              "viewUnits": "model"
            }
          }
        ],
        "shapeViews": [],
        "backgroundViews": [],
        "imageViews": []
      },
      "listenerContainer": {
        "linkListeners": [],
        "animationListeners": [],
        "bluetoothListeners": []
      },
      "customCodeContainer": {
        "onProgramAddedCode": "",
        "onProgramRemovedCode": "",
        "onProgramChangedPositionCode": "",
        "onProgramMarkersAddedCode": "",
        "onProgramMarkersRemovedCode": "",
        "onProgramMarkersChangedPositionCode": "",
        "onProgramAdjacentCode": "",
        "onProgramSeparatedCode": ""
      }
    },
    {
      "number": 1295,
      "title": "Equation07",
      "keywords": "TacTiles, equation, example, simple",
      "description": "Program to print and voice equation at top of display.",
      "expanded": false,
      "topWhiskerLength": 0.2,
      "rightWhiskerLength": 0.2,
      "bottomWhiskerLength": 0.2,
      "leftWhiskerLength": 0.2,
      "positionProperty": {
        "x": 38.57993749286055,
        "y": 304.19969863337553
      },
      "modelContainer": {
        "namedBooleanProperties": [
          {
            "name": "BooleanIsRotatedEquation07",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          }
        ],
        "namedVector2Properties": [
          {
            "name": "Equation07Position",
            "propertyType": "Vector2Property",
            "defaultX": "0.5",
            "defaultY": "0.05"
          }
        ],
        "namedNumberProperties": [],
        "namedEnumerationProperties": [],
        "namedDerivedProperties": [],
        "namedBounds2Properties": [],
        "namedObservableArrays": [],
        "namedArrayItems": [],
        "namedArrayItemReferences": [],
        "namedStringProperties": []
      },
      "controllerContainer": {
        "vector2PropertyControllers": [],
        "boundsPropertyControllers": [],
        "booleanPropertyControllers": [
          {
            "name": "ControllerReVoiceEquation07",
            "controlledComponentName": "BooleanIsRotatedEquation07",
            "controlType": "ROTATION",
            "controlTypeFamily": "",
            "whiskerConfiguration": {
              "topLength": 0.2,
              "rightLength": 0.2,
              "bottomLength": 0.2,
              "leftLength": 0.2,
              "otherPaperNumber": null
            },
            "markerColor": ""
          }
        ],
        "numberPropertyControllers": [],
        "enumerationPropertyControllers": []
      },
      "viewContainer": {
        "soundViews": [],
        "speechViews": [
          {
            "name": "ViewVoiceEquation07",
            "modelComponentNames": [
              "BooleanIsRotatedEquation07"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "speak( \"2x squared plus 4 equals 3x squared\" );",
            "lazyLink": false
          }
        ],
        "textViews": [
          {
            "name": "ViewTextEquation07",
            "modelComponentNames": [
              "Equation07Position"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "setString( '2x^2 + 4 = 3x^2' );\nsetFontSize(40);\nsetFontFamily('serif');\nsetCenterX( phet.paperLand.utils.paperToBoardX( Equation07Position.x, sharedData.displaySize.width ));\nsetCenterY( phet.paperLand.utils.paperToBoardY( Equation07Position.y, sharedData.displaySize.height ));",
            "lazyLink": false,
            "defaultViewOptions": {
              "centerX": 0.5,
              "centerY": 0.5,
              "scale": 1,
              "rotation": 0,
              "opacity": 1,
              "visible": true,
              "viewUnits": "model"
            }
          }
        ],
        "shapeViews": [],
        "backgroundViews": [],
        "imageViews": []
      },
      "listenerContainer": {
        "linkListeners": [],
        "animationListeners": [],
        "bluetoothListeners": []
      },
      "customCodeContainer": {
        "onProgramAddedCode": "",
        "onProgramRemovedCode": "",
        "onProgramChangedPositionCode": "",
        "onProgramMarkersAddedCode": "",
        "onProgramMarkersRemovedCode": "",
        "onProgramMarkersChangedPositionCode": "",
        "onProgramAdjacentCode": "",
        "onProgramSeparatedCode": ""
      }
    },
    {
      "number": 224,
      "title": "Check Balance",
      "keywords": "",
      "description": "",
      "expanded": false,
      "topWhiskerLength": 0.2,
      "rightWhiskerLength": 0.2,
      "bottomWhiskerLength": 0.2,
      "leftWhiskerLength": 0.2,
      "positionProperty": {
        "x": 488.3999938964844,
        "y": 405
      },
      "modelContainer": {
        "namedBooleanProperties": [
          {
            "name": "BooleanIsInBalance",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          },
          {
            "name": "BooleanIsBalanceRotated",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          }
        ],
        "namedVector2Properties": [],
        "namedNumberProperties": [
          {
            "name": "BalanceLeftXSquaredTerms",
            "propertyType": "NumberProperty",
            "min": 0,
            "max": "100",
            "defaultValue": "0"
          },
          {
            "name": "BalanceLeftXTerms",
            "propertyType": "NumberProperty",
            "min": 0,
            "max": 10,
            "defaultValue": 5
          },
          {
            "name": "BalanceLeftOnesTerms",
            "propertyType": "NumberProperty",
            "min": 0,
            "max": 10,
            "defaultValue": 5
          },
          {
            "name": "BalanceRightXSquaredTerms",
            "propertyType": "NumberProperty",
            "min": 0,
            "max": 10,
            "defaultValue": 5
          },
          {
            "name": "BalanceRightXTerms",
            "propertyType": "NumberProperty",
            "min": 0,
            "max": 10,
            "defaultValue": 5
          },
          {
            "name": "BalanceRightOnesTerms",
            "propertyType": "NumberProperty",
            "min": 0,
            "max": 10,
            "defaultValue": 5
          },
          {
            "name": "BalanceSoundTrigger",
            "propertyType": "NumberProperty",
            "min": 0,
            "max": 10,
            "defaultValue": 5
          }
        ],
        "namedEnumerationProperties": [],
        "namedDerivedProperties": [],
        "namedBounds2Properties": [],
        "namedObservableArrays": [],
        "namedArrayItems": [],
        "namedArrayItemReferences": [],
        "namedStringProperties": []
      },
      "controllerContainer": {
        "vector2PropertyControllers": [],
        "boundsPropertyControllers": [],
        "booleanPropertyControllers": [
          {
            "name": "ControllerBalanceRotation",
            "controlledComponentName": "BooleanIsBalanceRotated",
            "controlType": "ROTATION",
            "controlTypeFamily": "",
            "whiskerConfiguration": {
              "topLength": 0.2,
              "rightLength": 0.2,
              "bottomLength": 0.2,
              "leftLength": 0.2,
              "otherPaperNumber": null
            },
            "markerColor": ""
          }
        ],
        "numberPropertyControllers": [],
        "enumerationPropertyControllers": []
      },
      "viewContainer": {
        "soundViews": [
          {
            "name": "ViewOutOfBalanceSound",
            "modelComponentNames": [
              "BooleanIsInBalance",
              "BalanceSoundTrigger"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "if ( !BooleanIsInBalance ) {\r\n    play();\r\n}",
            "lazyLink": false,
            "soundFileName": "/uploads/OutOfBalanceSound.mp3",
            "loop": false,
            "autoplay": false
          },
          {
            "name": "ViewInBalanceSound",
            "modelComponentNames": [
              "BooleanIsInBalance",
              "BalanceSoundTrigger"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "if ( BooleanIsInBalance ) {\r\n    play();\r\n}",
            "lazyLink": false,
            "soundFileName": "/uploads/SuccessSound.mp3",
            "loop": false,
            "autoplay": true
          }
        ],
        "speechViews": [],
        "textViews": [
          {
            "name": "BalanceDebugText",
            "modelComponentNames": [
              "BooleanIsInBalance",
              "BalanceLeftXSquaredTerms",
              "BalanceLeftXTerms",
              "BalanceLeftOnesTerms",
              "BalanceRightXSquaredTerms",
              "BalanceRightXTerms"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "// setCenterX( 200 );\r\n// setCenterY( 200 );\r\n// setString( `\r\n// In Balance Left X Squared: ${BalanceLeftXSquaredTerms}<br>\r\n// In Balance Left X: ${BalanceLeftXTerms}<br>\r\n// In Balance Left Ones: ${BalanceLeftOnesTerms}<br>\r\n// <br>\r\n// In Balance Right X Squared: ${BalanceRightXSquaredTerms}<br>\r\n// In Balance Right X: ${BalanceRightXTerms}<br>\r\n// In Balance Right Ones: ${BalanceRightOnesTerms}<br>\r\n// <br>\r\n// IN BALANCE: ${BooleanIsInBalance}\r\n// ` );",
            "lazyLink": false,
            "defaultViewOptions": {
              "centerX": 0.5,
              "centerY": 0.5,
              "scale": 1,
              "rotation": 0,
              "opacity": 1,
              "visible": true,
              "viewUnits": "model"
            }
          },
          {
            "name": "ViewInBalanceTextRecord",
            "modelComponentNames": [
              "BooleanIsInBalance",
              "BalanceLeftXSquaredTerms",
              "BalanceLeftXTerms",
              "BalanceLeftOnesTerms",
              "BalanceRightXSquaredTerms",
              "BalanceRightXTerms",
              "BalanceRightOnesTerms"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "if ( BooleanIsInBalance ) {\n    setCenterX( 20 );\n    setCenterY( 400 );\n    setString( `\n        ${BalanceLeftXSquaredTerms}<br>\n        ${BalanceLeftXTerms}<br>\n        ${BalanceLeftOnesTerms}<br>\n    <br>\n        ${BalanceRightXSquaredTerms}<br>\n        ${BalanceRightXTerms}<br>\n        ${BalanceRightOnesTerms}<br>\n` );\n}",
            "lazyLink": false,
            "defaultViewOptions": {
              "centerX": 0.5,
              "centerY": 0.5,
              "scale": 1,
              "rotation": 0,
              "opacity": 1,
              "visible": true,
              "viewUnits": "model"
            }
          }
        ],
        "shapeViews": [],
        "backgroundViews": [],
        "imageViews": []
      },
      "listenerContainer": {
        "linkListeners": [
          {
            "name": "RotationBalanceChecker",
            "controlledPropertyNames": [
              "BooleanIsInBalance",
              "BalanceSoundTrigger"
            ],
            "controlFunctionString": "// Get a reference to the tileData - an array of all tiles with information about\r\n// what side they are on. This array was created in custom code in program 802.\r\nconst tileData = phet.paperLand.getModelComponent( 'tileData' );\r\n\r\nif ( tileData ) {\r\n\r\n    // find all of the entries of tile data that are on the left side\r\n    const rightTiles = tileData.filter( data => !data.onLeftSideProperty.value );\r\n    const leftTiles = tileData.filter( data => data.onLeftSideProperty.value );\r\n\r\n   // This is a function that we use to count the \"number\" of terms for a given term. We go \r\n   // through the tiles and increment by the number of terms on that tile if positive, and \r\n   // decrement by the number of terms if negative.\r\n   const createAccumulatorFunction = term => {\r\n      return ( accumulator, data ) => {\r\n        if ( data.term === term ) {\r\n\r\n          // Add one to the number of terms since model Properties start from 0\r\n          const numberOfTerms = data.countProperty.value + 1;\r\n          return data.negativeProperty.value ? accumulator - numberOfTerms : accumulator + numberOfTerms;\r\n        }\r\n        else {\r\n          return accumulator;\r\n        }\r\n      }\r\n    }\r\n\r\n    const currentRightXSquaredTerms = rightTiles.reduce( createAccumulatorFunction( 'xSquared' ), 0 );\r\n    const currentRightXTerms = rightTiles.reduce( createAccumulatorFunction( 'x' ), 0 );\r\n    const currentRightOnesTerms = rightTiles.reduce( createAccumulatorFunction( 'ones' ), 0 );\r\n\r\n    const currentLeftXSquaredTerms = leftTiles.reduce( createAccumulatorFunction( 'xSquared' ), 0 );\r\n    const currentLeftXTerms = leftTiles.reduce( createAccumulatorFunction( 'x' ), 0 );\r\n    const currentLeftOnesTerms = leftTiles.reduce( createAccumulatorFunction( 'ones' ), 0 ); \r\n\r\n    // Get the difference in tiles for the right side since this program was added.\r\n    const rightXSquaredDifference = BalanceRightXSquaredTerms - currentRightXSquaredTerms;\r\n    const rightXDifference = BalanceRightXTerms - currentRightXTerms;\r\n    const rightOnesDifference = BalanceRightOnesTerms - currentRightOnesTerms;\r\n\r\n    // Get the difference in tiles for the left side since this program was added.\r\n    const leftXSquaredDifference = BalanceLeftXSquaredTerms - currentLeftXSquaredTerms;\r\n    const leftXDifference = BalanceLeftXTerms - currentLeftXTerms;\r\n    const leftOnesDifference = BalanceLeftOnesTerms - currentLeftOnesTerms;\r\n\r\n    // The equation will be in balance if the differences for all terms is the same\r\n    // for both sides.\r\n    const finalInBalance = rightXSquaredDifference === leftXSquaredDifference &&\r\n                           rightXDifference === leftXDifference &&\r\n                           rightOnesDifference === leftOnesDifference;\r\n\r\n    // Finally, update our model component representing the state of balance.\r\n    setBooleanIsInBalance( finalInBalance );\r\n    setBalanceSoundTrigger( BalanceSoundTrigger + 1 );\r\n}",
            "dependencyNames": [
              "BooleanIsBalanceRotated",
              "BalanceLeftXSquaredTerms",
              "BalanceLeftXTerms",
              "BalanceLeftOnesTerms",
              "BalanceRightXSquaredTerms",
              "BalanceRightXTerms",
              "BalanceRightOnesTerms"
            ],
            "referenceComponentNames": []
          }
        ],
        "animationListeners": [],
        "bluetoothListeners": []
      },
      "customCodeContainer": {
        "onProgramAddedCode": "// When this program is added, set the model components that represent the number\r\n// of terms on each side. This means that whatever tilese are out when this program\r\n// is added, that will be considered the baseline for balance. Note that this program\r\n// must be added AFTER the Equation Bounds program because it requires the tileData\r\n// array created in custom code in that program.\r\n\r\nconst tileData = phet.paperLand.getModelComponent( 'tileData' );\r\nif ( tileData ) {\r\n\r\n    // find all of the entries of tile data that are on the left side\r\n    const rightTiles = tileData.filter( data => !data.onLeftSideProperty.value );\r\n    const leftTiles = tileData.filter( data => data.onLeftSideProperty.value );\r\n\r\n    const BalanceLeftXSquaredTerms = phet.paperLand.getModelComponent( 'BalanceLeftXSquaredTerms' );\r\n    const BalanceLeftXTerms = phet.paperLand.getModelComponent( 'BalanceLeftXTerms' );\r\n    const BalanceLeftOnesTerms = phet.paperLand.getModelComponent( 'BalanceLeftOnesTerms' );\r\n\r\n    const BalanceRightXSquaredTerms = phet.paperLand.getModelComponent( 'BalanceRightXSquaredTerms' );\r\n    const BalanceRightXTerms = phet.paperLand.getModelComponent( 'BalanceRightXTerms' );\r\n    const BalanceRightOnesTerms = phet.paperLand.getModelComponent( 'BalanceRightOnesTerms' );\r\n\r\n   // This is a function that we use to count the \"number\" of terms for a given term. We go \r\n   // through the tiles and increment by the number of terms on that tile if positive, and \r\n   // decrement by the number of terms if negative.\r\n   const createAccumulatorFunction = term => {\r\n      return ( accumulator, data ) => {\r\n        if ( data.term === term ) {\r\n\r\n          // Add one to the number of terms since model Properties start from 0\r\n          const numberOfTerms = data.countProperty.value + 1;\r\n          return data.negativeProperty.value ? accumulator - numberOfTerms : accumulator + numberOfTerms;\r\n        }\r\n        else {\r\n          return accumulator;\r\n        }\r\n      }\r\n    }\r\n\r\n    BalanceRightXSquaredTerms.value = rightTiles.reduce( createAccumulatorFunction( 'xSquared' ), 0 );\r\n    BalanceRightXTerms.value = rightTiles.reduce( createAccumulatorFunction( 'x' ), 0 );\r\n    BalanceRightOnesTerms.value = rightTiles.reduce( createAccumulatorFunction( 'ones' ), 0 );\r\n\r\n    BalanceLeftXSquaredTerms.value = leftTiles.reduce( createAccumulatorFunction( 'xSquared' ), 0 );\r\n    BalanceLeftXTerms.value = leftTiles.reduce( createAccumulatorFunction( 'x' ), 0 );\r\n    BalanceLeftOnesTerms.value = leftTiles.reduce( createAccumulatorFunction( 'ones' ), 0 );  \r\n}",
        "onProgramRemovedCode": "",
        "onProgramChangedPositionCode": "",
        "onProgramMarkersAddedCode": "",
        "onProgramMarkersRemovedCode": "",
        "onProgramMarkersChangedPositionCode": "",
        "onProgramAdjacentCode": "",
        "onProgramSeparatedCode": ""
      }
    },
    {
      "number": 447,
      "title": "Ones Tiles B",
      "keywords": "TacTiles, algebra, voicing, ones, one, numbers",
      "description": "A program that voices the number of one-tiles and increments and decrements the number of ones using markers. Note that current model range is 0-9, and the voicing strings range from 1-10.",
      "expanded": false,
      "topWhiskerLength": 0.05,
      "rightWhiskerLength": 0.05,
      "bottomWhiskerLength": 0.05,
      "leftWhiskerLength": 0.05,
      "positionProperty": {
        "x": 364.91726242720534,
        "y": 199.97491128990902
      },
      "modelContainer": {
        "namedBooleanProperties": [
          {
            "name": "BooleanOnLeftSideForOnes_B",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          },
          {
            "name": "BooleanNegativeForOnes_B",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          },
          {
            "name": "BooleanGoodConnectionForOnes_B",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          },
          {
            "name": "BooleanBadConnectionForOnes_B",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          }
        ],
        "namedVector2Properties": [
          {
            "name": "PositionForOnesTiles_B",
            "propertyType": "Vector2Property",
            "defaultX": 0,
            "defaultY": 0
          }
        ],
        "namedNumberProperties": [
          {
            "name": "NumberOfOnes_B",
            "propertyType": "NumberProperty",
            "min": 0,
            "max": "9",
            "defaultValue": "0"
          }
        ],
        "namedEnumerationProperties": [],
        "namedDerivedProperties": [],
        "namedBounds2Properties": [],
        "namedObservableArrays": [],
        "namedArrayItems": [],
        "namedArrayItemReferences": [],
        "namedStringProperties": []
      },
      "controllerContainer": {
        "vector2PropertyControllers": [
          {
            "name": "ControllerPositionForOnes_B",
            "controlledComponentName": "PositionForOnesTiles_B",
            "controlType": "MATCH_CENTER",
            "controlTypeFamily": ""
          }
        ],
        "boundsPropertyControllers": [],
        "booleanPropertyControllers": [
          {
            "name": "ControllerBooleanNegativeForOnes_B",
            "controlledComponentName": "BooleanNegativeForOnes_B",
            "controlType": "ROTATION",
            "controlTypeFamily": "",
            "whiskerConfiguration": {
              "topLength": 0.2,
              "rightLength": 0.2,
              "bottomLength": 0.2,
              "leftLength": 0.2,
              "otherPaperNumber": null
            },
            "markerColor": ""
          }
        ],
        "numberPropertyControllers": [
          {
            "name": "ControllerForOnes_B",
            "controlledComponentName": "NumberOfOnes_B",
            "controlType": "MARKER_COUNT",
            "controlTypeFamily": "MARKERS",
            "markerColor": "all",
            "relationshipControlType": null
          }
        ],
        "enumerationPropertyControllers": []
      },
      "viewContainer": {
        "soundViews": [
          {
            "name": "ViewGoodConnectionSoundForOnes_B",
            "modelComponentNames": [
              "RectangleModelMode",
              "BooleanGoodConnectionForOnes_B"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "if ( BooleanGoodConnectionForOnes_B && RectangleModelMode ) {\r\n    play();\r\n}",
            "lazyLink": false,
            "soundFileName": "/uploads/SuccessSound.mp3",
            "loop": false,
            "autoplay": false
          },
          {
            "name": "ViewBadConnectionSoundForOnes_B",
            "modelComponentNames": [
              "RectangleModelMode",
              "BooleanBadConnectionForOnes_B"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "if ( BooleanBadConnectionForOnes_B && RectangleModelMode) {\r\n    play();\r\n}",
            "lazyLink": false,
            "soundFileName": "/uploads/OutOfBalanceSound.mp3",
            "loop": false,
            "autoplay": false
          }
        ],
        "speechViews": [
          {
            "name": "ViewNumberOfOnes_B",
            "modelComponentNames": [
              "BooleanNegativeForOnes_B",
              "NumberOfOnes_B"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "phet.paperLand.console.log(NumberOfOnes_B);\nif (Math.floor(NumberOfOnes_B) === 0) {\n// A paper with no markers represents a single 1 tile, so \n// we need to add 1 or -1 to the min value of 0. \n    if (BooleanNegativeForOnes_B) {\n        speak( -1 );\n    }\n    else {\n        speak( 1 );\n    }\n} else {\n    if (BooleanNegativeForOnes_B) {\n        speak( -Math.floor(NumberOfOnes_B) - 1 );\n    }\n    else {\n        speak( Math.floor(NumberOfOnes_B) + 1 );\n    }\n}",
            "lazyLink": false
          }
        ],
        "textViews": [
          {
            "name": "ViewTextTilesForOnes_B",
            "modelComponentNames": [
              "BooleanNegativeForOnes_B",
              "PositionForOnesTiles_B",
              "NumberOfOnes_B"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "if (BooleanNegativeForOnes_B) {\n        setString('] ' + (-NumberOfOnes_B - 1) + ' [');\n    }\n    else {\n        setString('[ ' + (NumberOfOnes_B + 1) + ' ]');\n    }\nsetFontSize(20);\nsetCenterX( phet.paperLand.utils.paperToBoardX( PositionForOnesTiles_B.x, sharedData.displaySize.width ))\nsetCenterY( phet.paperLand.utils.paperToBoardY( PositionForOnesTiles_B.y, sharedData.displaySize.height ))",
            "lazyLink": false,
            "defaultViewOptions": {
              "centerX": 0.5,
              "centerY": 0.5,
              "scale": 1,
              "rotation": 0,
              "opacity": 1,
              "visible": true,
              "viewUnits": "model"
            }
          }
        ],
        "shapeViews": [],
        "backgroundViews": [],
        "imageViews": []
      },
      "listenerContainer": {
        "linkListeners": [
          {
            "name": "ControllerBooleanLeftSideForOnes_B",
            "controlledPropertyNames": [
              "BooleanOnLeftSideForOnes_B"
            ],
            "controlFunctionString": "// Uncomment to voice side of equation\nsetBooleanOnLeftSideForOnes_B(BoundsLeftSideOfEquals.containsPoint( PositionForOnesTiles_B )); ",
            "dependencyNames": [
              "BoundsLeftSideOfEquals",
              "PositionForOnesTiles_B"
            ],
            "referenceComponentNames": []
          }
        ],
        "animationListeners": [],
        "bluetoothListeners": []
      },
      "customCodeContainer": {
        "onProgramAddedCode": "// Setting program data to the program for some sound design.\r\nphet.paperLand.setProgramData( paperNumber, 'term', 'ones' );\r\n\r\n// Using addModelObserver lets us add the tiles/bounds programs in any order\r\nscratchpad.observerId = phet.paperLand.addModelObserver(\r\n  'tileData', // the bounds program will create this array when it is added\r\n  tileDataArray => {\r\n\r\n    // as soon as the array is available, add this tile to it\r\n    scratchpad.thisTileData = {\r\n      onLeftSideProperty: phet.paperLand.getModelComponent( 'BooleanOnLeftSideForOnes_B' ),\r\n      negativeProperty: phet.paperLand.getModelComponent( 'BooleanNegativeForOnes_B' ),\r\n      countProperty: phet.paperLand.getModelComponent( 'NumberOfOnes_B' ),\r\n      term: 'ones'\r\n    }\r\n    tileDataArray.push( scratchpad.thisTileData );\r\n  },\r\n  tileDataArray => {\r\n\r\n    // Remove this tile from the array when the array is being removed\r\n    const index = tileDataArray.indexOf( scratchpad.thisTileData );\r\n    if ( index > -1 ) {\r\n        tileDataArray.splice( index, 1 );\r\n        delete scratchpad.tileData;\r\n    }\r\n  }\r\n);",
        "onProgramRemovedCode": "// Removes the term data from the model\r\nphet.paperLand.removeProgramData( paperNumber, 'term' );\r\n\r\nconst tileData = phet.paperLand.getModelComponent( 'tileData' );\r\nif ( tileData ) {\r\n\r\n    // Remove the tile from the array\r\n    const index = tileData.indexOf( scratchpad.thisTileData );\r\n    if ( index > -1 ) {\r\n        tileData.splice( index, 1 );\r\n        delete scratchpad.tileData;        \r\n    }\r\n}\r\n\r\n// remove the model observer\r\nphet.paperLand.removeModelObserver( 'tileData', scratchpad.observerId );\r\ndelete scratchpad.observerId;",
        "onProgramChangedPositionCode": "",
        "onProgramMarkersAddedCode": "",
        "onProgramMarkersRemovedCode": "",
        "onProgramMarkersChangedPositionCode": "",
        "onProgramAdjacentCode": "\r\n// Get a reference to the model component and only update it if it exists.\r\nconst goodConnectionComponent = phet.paperLand.getModelComponent( 'BooleanGoodConnectionForOnes_B' );\r\nconst badConnectionComponent = phet.paperLand.getModelComponent( 'BooleanBadConnectionForOnes_B' );\r\n\r\n\r\nif ( goodConnectionComponent && badConnectionComponent ) {\r\n\r\n    // If this is the left or right whisker...\r\n    if ( direction === 'left' || direction === 'right' ) {\r\n\r\n        // These are the terms that this program is allowed to connect to.\r\n        const goodConnectionTerms = [ 'ones' ];\r\n       \r\n        // These are the terms that this program is NOT allowed to connect to.\r\n        const badConnectionTerms = [ 'x', 'xSquared' ];\r\n\r\n        // This connection is \"good\" if the other program has a term in the good list\r\n        goodConnectionComponent.value = goodConnectionTerms.includes(\r\n\r\n            // get the term from the other program\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        );\r\n        // This connection is \"bad\" if the other program has a term in the bad list\r\n        badConnectionComponent.value = badConnectionTerms.includes(\r\n\r\n            // get the term from the other program\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        );\r\n    }\r\n\r\n    phet.paperLand.console.log( direction );\r\n\r\n    // If this is the top or bottom whisker...\r\n    if ( direction === 'top' || direction === 'bottom' ) {\r\n        \r\n        // These are the terms that this program is allowed to connect to.\r\n        // TODO: Add top and bottom of X tiles\r\n        const goodConnectionTerms = [ 'ones' ];\r\n       \r\n        // These are the terms that this program is NOT allowed to connect to.\r\n        // TODO: Add left and right of X tiles\r\n        const badConnectionTerms = [ 'xSquared' ];\r\n\r\n        // This connection is \"good\" if the other program has a term in the good list\r\n        goodConnectionComponent.value = goodConnectionTerms.includes(\r\n\r\n            // get the term from the other program\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        );\r\n        // This connection is \"bad\" if the other program has a term in the bad list\r\n        badConnectionComponent.value = badConnectionTerms.includes(\r\n\r\n            // get the term from the other program\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        );\r\n    }\r\n}",
        "onProgramSeparatedCode": "\r\n// Get a reference to the model component and only update it if it exists.\r\nconst goodConnectionComponent = phet.paperLand.getModelComponent( 'BooleanGoodConnectionForOnes_B' );\r\nconst badConnectionComponent = phet.paperLand.getModelComponent( 'BooleanBadConnectionForOnes_B' );\r\n\r\n// Components must exit check\r\nif ( goodConnectionComponent && badConnectionComponent )  {\r\n\r\n    // If this is the left or right whisker...\r\n    if ( direction === 'left' || direction === 'right' ) {\r\n\r\n        // These are the terms that this program is allowed to connect to.\r\n        const goodConnectionTerms = [ 'ones' ];\r\n\r\n         // These are the terms that this program is NOT allowed to connect to.\r\n        const badConnectionTerms = [ 'x', 'xSquared' ];\r\n\r\n        // If detatching from another program where connection is \"good\",\r\n        // the connection is no longer there.\r\n        if ( goodConnectionTerms.includes(\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        ) ) {\r\n            goodConnectionComponent.value = false;\r\n        }\r\n        // If detatching from another program where connection is \"bad\",\r\n        // the connection is no longer there.\r\n        if ( badConnectionTerms.includes(\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        ) ) {\r\n            badConnectionComponent.value = false;\r\n        }\r\n    }\r\n\r\n    // If this is the top or bottom whisker...\r\n    if ( direction === 'top' || direction === 'bottom' ) {\r\n\r\n       // These are the terms that this program is allowed to connect to.\r\n       // TODO: top and bottom of X tiles need to be added\r\n        const goodConnectionTerms = [ 'ones' ];\r\n\r\n         // These are the terms that this program is NOT allowed to connect to.\r\n         // TODO: left and right of X tiles need to be added\r\n        const badConnectionTerms = [ 'xSquared' ];\r\n\r\n        // If detatching from another program where connection is \"good\",\r\n        // the connection is no longer there.\r\n        if ( goodConnectionTerms.includes(\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        ) ) {\r\n            goodConnectionComponent.value = false;\r\n        }\r\n        // If detatching from another program where connection is \"bad\",\r\n        // the connection is no longer there.\r\n        if ( badConnectionTerms.includes(\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        ) ) {\r\n            badConnectionComponent.value = false;\r\n        }\r\n    }\r\n}"
      }
    },
    {
      "number": 1616,
      "title": "Ones Tiles C",
      "keywords": "TacTiles, algebra, voicing, ones, one, numbers",
      "description": "A program that voices the number of one-tiles and increments and decrements the number of ones using markers. Note that current model range is 0-9, and the voicing strings range from 1-10.",
      "expanded": false,
      "topWhiskerLength": 0.05,
      "rightWhiskerLength": 0.05,
      "bottomWhiskerLength": 0.05,
      "leftWhiskerLength": 0.05,
      "positionProperty": {
        "x": 349.1086381596272,
        "y": 268.4670650657738
      },
      "modelContainer": {
        "namedBooleanProperties": [
          {
            "name": "BooleanOnLeftSideForOnes_C",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          },
          {
            "name": "BooleanNegativeForOnes_C",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          },
          {
            "name": "BooleanGoodConnectionForOnes_C",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          },
          {
            "name": "BooleanBadConnectionForOnes_C",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          }
        ],
        "namedVector2Properties": [
          {
            "name": "PositionForOnesTiles_C",
            "propertyType": "Vector2Property",
            "defaultX": 0,
            "defaultY": 0
          }
        ],
        "namedNumberProperties": [
          {
            "name": "NumberOfOnes_C",
            "propertyType": "NumberProperty",
            "min": 0,
            "max": "9",
            "defaultValue": "0"
          }
        ],
        "namedEnumerationProperties": [],
        "namedDerivedProperties": [],
        "namedBounds2Properties": [],
        "namedObservableArrays": [],
        "namedArrayItems": [],
        "namedArrayItemReferences": [],
        "namedStringProperties": []
      },
      "controllerContainer": {
        "vector2PropertyControllers": [
          {
            "name": "ControllerPositionForOnes_C",
            "controlledComponentName": "PositionForOnesTiles_C",
            "controlType": "MATCH_CENTER",
            "controlTypeFamily": ""
          }
        ],
        "boundsPropertyControllers": [],
        "booleanPropertyControllers": [
          {
            "name": "ControllerBooleanNegativeForOnes_C",
            "controlledComponentName": "BooleanNegativeForOnes_C",
            "controlType": "ROTATION",
            "controlTypeFamily": "",
            "whiskerConfiguration": {
              "topLength": 0.2,
              "rightLength": 0.2,
              "bottomLength": 0.2,
              "leftLength": 0.2,
              "otherPaperNumber": null
            },
            "markerColor": ""
          }
        ],
        "numberPropertyControllers": [
          {
            "name": "ControllerForOnes_C",
            "controlledComponentName": "NumberOfOnes_C",
            "controlType": "MARKER_COUNT",
            "controlTypeFamily": "MARKERS",
            "markerColor": "all",
            "relationshipControlType": null
          }
        ],
        "enumerationPropertyControllers": []
      },
      "viewContainer": {
        "soundViews": [
          {
            "name": "ViewGoodConnectionSoundForOnes_C",
            "modelComponentNames": [
              "RectangleModelMode",
              "BooleanGoodConnectionForOnes_C"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "if ( BooleanGoodConnectionForOnes_C && RectangleModelMode ) {\r\n    play();\r\n}",
            "lazyLink": false,
            "soundFileName": "/uploads/SuccessSound.mp3",
            "loop": false,
            "autoplay": false
          },
          {
            "name": "ViewBadConnectionSoundForOnes_C",
            "modelComponentNames": [
              "RectangleModelMode",
              "BooleanBadConnectionForOnes_C"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "if ( BooleanBadConnectionForOnes_C && RectangleModelMode) {\r\n    play();\r\n}",
            "lazyLink": false,
            "soundFileName": "/uploads/OutOfBalanceSound.mp3",
            "loop": false,
            "autoplay": false
          }
        ],
        "speechViews": [
          {
            "name": "ViewNumberOfOnes_C",
            "modelComponentNames": [
              "BooleanNegativeForOnes_C",
              "NumberOfOnes_C"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "phet.paperLand.console.log(NumberOfOnes_C);\nif (Math.floor(NumberOfOnes_C) === 0) {\n// A paper with no markers represents a single 1 tile, so \n// we need to add 1 or -1 to the min value of 0. \n    if (BooleanNegativeForOnes_C) {\n        speak( -1 );\n    }\n    else {\n        speak( 1 );\n    }\n} else {\n    if (BooleanNegativeForOnes_C) {\n        speak( -Math.floor(NumberOfOnes_C) - 1 );\n    }\n    else {\n        speak( Math.floor(NumberOfOnes_C) + 1 );\n    }\n}",
            "lazyLink": false
          }
        ],
        "textViews": [
          {
            "name": "ViewTextTilesForOnes_C",
            "modelComponentNames": [
              "BooleanNegativeForOnes_C",
              "PositionForOnesTiles_C",
              "NumberOfOnes_C"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "if (BooleanNegativeForOnes_C) {\n        setString('] ' + (-NumberOfOnes_C - 1) + ' [');\n    }\n    else {\n        setString('[ ' + (NumberOfOnes_C + 1) + ' ]');\n    }\nsetFontSize(20);\nsetCenterX( phet.paperLand.utils.paperToBoardX( PositionForOnesTiles_C.x, sharedData.displaySize.width ))\nsetCenterY( phet.paperLand.utils.paperToBoardY( PositionForOnesTiles_C.y, sharedData.displaySize.height ))",
            "lazyLink": false,
            "defaultViewOptions": {
              "centerX": 0.5,
              "centerY": 0.5,
              "scale": 1,
              "rotation": 0,
              "opacity": 1,
              "visible": true,
              "viewUnits": "model"
            }
          }
        ],
        "shapeViews": [],
        "backgroundViews": [],
        "imageViews": []
      },
      "listenerContainer": {
        "linkListeners": [
          {
            "name": "ControllerBooleanLeftSideForOnes_C",
            "controlledPropertyNames": [
              "BooleanOnLeftSideForOnes_C"
            ],
            "controlFunctionString": "// Uncomment to voice side of equation\nsetBooleanOnLeftSideForOnes_C(BoundsLeftSideOfEquals.containsPoint( PositionForOnesTiles_C )); ",
            "dependencyNames": [
              "BoundsLeftSideOfEquals",
              "PositionForOnesTiles_C"
            ],
            "referenceComponentNames": []
          }
        ],
        "animationListeners": [],
        "bluetoothListeners": []
      },
      "customCodeContainer": {
        "onProgramAddedCode": "// Setting program data to the program for some sound design.\r\nphet.paperLand.setProgramData( paperNumber, 'term', 'ones' );\r\n\r\n// Using addModelObserver lets us add the tiles/bounds programs in any order\r\nscratchpad.observerId = phet.paperLand.addModelObserver(\r\n  'tileData', // the bounds program will create this array when it is added\r\n  tileDataArray => {\r\n\r\n    // as soon as the array is available, add this tile to it\r\n    scratchpad.thisTileData = {\r\n      onLeftSideProperty: phet.paperLand.getModelComponent( 'BooleanOnLeftSideForOnes_C' ),\r\n      negativeProperty: phet.paperLand.getModelComponent( 'BooleanNegativeForOnes_C' ),\r\n      countProperty: phet.paperLand.getModelComponent( 'NumberOfOnes_C' ),\r\n      term: 'ones'\r\n    }\r\n    tileDataArray.push( scratchpad.thisTileData );\r\n  },\r\n  tileDataArray => {\r\n\r\n    // Remove this tile from the array when the array is being removed\r\n    const index = tileDataArray.indexOf( scratchpad.thisTileData );\r\n    if ( index > -1 ) {\r\n        tileDataArray.splice( index, 1 );\r\n        delete scratchpad.tileData;\r\n    }\r\n  }\r\n);",
        "onProgramRemovedCode": "// Removes the term data from the model\r\nphet.paperLand.removeProgramData( paperNumber, 'term' );\r\n\r\nconst tileData = phet.paperLand.getModelComponent( 'tileData' );\r\nif ( tileData ) {\r\n\r\n    // Remove the tile from the array\r\n    const index = tileData.indexOf( scratchpad.thisTileData );\r\n    if ( index > -1 ) {\r\n        tileData.splice( index, 1 );\r\n        delete scratchpad.tileData;        \r\n    }\r\n}\r\n\r\n// remove the model observer\r\nphet.paperLand.removeModelObserver( 'tileData', scratchpad.observerId );\r\ndelete scratchpad.observerId;",
        "onProgramChangedPositionCode": "",
        "onProgramMarkersAddedCode": "",
        "onProgramMarkersRemovedCode": "",
        "onProgramMarkersChangedPositionCode": "",
        "onProgramAdjacentCode": "\r\n// Get a reference to the model component and only update it if it exists.\r\nconst goodConnectionComponent = phet.paperLand.getModelComponent( 'BooleanGoodConnectionForOnes_C' );\r\nconst badConnectionComponent = phet.paperLand.getModelComponent( 'BooleanBadConnectionForOnes_C' );\r\n\r\n\r\nif ( goodConnectionComponent && badConnectionComponent ) {\r\n\r\n    // If this is the left or right whisker...\r\n    if ( direction === 'left' || direction === 'right' ) {\r\n\r\n        // These are the terms that this program is allowed to connect to.\r\n        const goodConnectionTerms = [ 'ones' ];\r\n       \r\n        // These are the terms that this program is NOT allowed to connect to.\r\n        const badConnectionTerms = [ 'x', 'xSquared' ];\r\n\r\n        // This connection is \"good\" if the other program has a term in the good list\r\n        goodConnectionComponent.value = goodConnectionTerms.includes(\r\n\r\n            // get the term from the other program\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        );\r\n        // This connection is \"bad\" if the other program has a term in the bad list\r\n        badConnectionComponent.value = badConnectionTerms.includes(\r\n\r\n            // get the term from the other program\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        );\r\n    }\r\n\r\n    phet.paperLand.console.log( direction );\r\n\r\n    // If this is the top or bottom whisker...\r\n    if ( direction === 'top' || direction === 'bottom' ) {\r\n        \r\n        // These are the terms that this program is allowed to connect to.\r\n        // TODO: Add top and bottom of X tiles\r\n        const goodConnectionTerms = [ 'ones' ];\r\n       \r\n        // These are the terms that this program is NOT allowed to connect to.\r\n        // TODO: Add left and right of X tiles\r\n        const badConnectionTerms = [ 'xSquared' ];\r\n\r\n        // This connection is \"good\" if the other program has a term in the good list\r\n        goodConnectionComponent.value = goodConnectionTerms.includes(\r\n\r\n            // get the term from the other program\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        );\r\n        // This connection is \"bad\" if the other program has a term in the bad list\r\n        badConnectionComponent.value = badConnectionTerms.includes(\r\n\r\n            // get the term from the other program\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        );\r\n    }\r\n}",
        "onProgramSeparatedCode": "\r\n// Get a reference to the model component and only update it if it exists.\r\nconst goodConnectionComponent = phet.paperLand.getModelComponent( 'BooleanGoodConnectionForOnes_C' );\r\nconst badConnectionComponent = phet.paperLand.getModelComponent( 'BooleanBadConnectionForOnes_C' );\r\n\r\n// Components must exit check\r\nif ( goodConnectionComponent && badConnectionComponent )  {\r\n\r\n    // If this is the left or right whisker...\r\n    if ( direction === 'left' || direction === 'right' ) {\r\n\r\n        // These are the terms that this program is allowed to connect to.\r\n        const goodConnectionTerms = [ 'ones' ];\r\n\r\n         // These are the terms that this program is NOT allowed to connect to.\r\n        const badConnectionTerms = [ 'x', 'xSquared' ];\r\n\r\n        // If detatching from another program where connection is \"good\",\r\n        // the connection is no longer there.\r\n        if ( goodConnectionTerms.includes(\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        ) ) {\r\n            goodConnectionComponent.value = false;\r\n        }\r\n        // If detatching from another program where connection is \"bad\",\r\n        // the connection is no longer there.\r\n        if ( badConnectionTerms.includes(\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        ) ) {\r\n            badConnectionComponent.value = false;\r\n        }\r\n    }\r\n\r\n    // If this is the top or bottom whisker...\r\n    if ( direction === 'top' || direction === 'bottom' ) {\r\n\r\n       // These are the terms that this program is allowed to connect to.\r\n       // TODO: top and bottom of X tiles need to be added\r\n        const goodConnectionTerms = [ 'ones' ];\r\n\r\n         // These are the terms that this program is NOT allowed to connect to.\r\n         // TODO: left and right of X tiles need to be added\r\n        const badConnectionTerms = [ 'xSquared' ];\r\n\r\n        // If detatching from another program where connection is \"good\",\r\n        // the connection is no longer there.\r\n        if ( goodConnectionTerms.includes(\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        ) ) {\r\n            goodConnectionComponent.value = false;\r\n        }\r\n        // If detatching from another program where connection is \"bad\",\r\n        // the connection is no longer there.\r\n        if ( badConnectionTerms.includes(\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        ) ) {\r\n            badConnectionComponent.value = false;\r\n        }\r\n    }\r\n}"
      }
    },
    {
      "number": 795,
      "title": "Ones Tiles D",
      "keywords": "TacTiles, algebra, voicing, ones, one, numbers",
      "description": "A program that voices the number of one-tiles and increments and decrements the number of ones using markers. Note that current model range is 0-9, and the voicing strings range from 1-10.",
      "expanded": false,
      "topWhiskerLength": 0.05,
      "rightWhiskerLength": 0.05,
      "bottomWhiskerLength": 0.05,
      "leftWhiskerLength": 0.05,
      "positionProperty": {
        "x": 346.3859819096272,
        "y": 365.09595605698473
      },
      "modelContainer": {
        "namedBooleanProperties": [
          {
            "name": "BooleanOnLeftSideForOnes_D",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          },
          {
            "name": "BooleanNegativeForOnes_D",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          },
          {
            "name": "BooleanGoodConnectionForOnes_D",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          },
          {
            "name": "BooleanBadConnectionForOnes_D",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          }
        ],
        "namedVector2Properties": [
          {
            "name": "PositionForOnesTiles_D",
            "propertyType": "Vector2Property",
            "defaultX": 0,
            "defaultY": 0
          }
        ],
        "namedNumberProperties": [
          {
            "name": "NumberOfOnes_D",
            "propertyType": "NumberProperty",
            "min": 0,
            "max": "9",
            "defaultValue": "0"
          }
        ],
        "namedEnumerationProperties": [],
        "namedDerivedProperties": [],
        "namedBounds2Properties": [],
        "namedObservableArrays": [],
        "namedArrayItems": [],
        "namedArrayItemReferences": [],
        "namedStringProperties": []
      },
      "controllerContainer": {
        "vector2PropertyControllers": [
          {
            "name": "ControllerPositionForOnes_D",
            "controlledComponentName": "PositionForOnesTiles_D",
            "controlType": "MATCH_CENTER",
            "controlTypeFamily": ""
          }
        ],
        "boundsPropertyControllers": [],
        "booleanPropertyControllers": [
          {
            "name": "ControllerBooleanNegativeForOnes_D",
            "controlledComponentName": "BooleanNegativeForOnes_D",
            "controlType": "ROTATION",
            "controlTypeFamily": "",
            "whiskerConfiguration": {
              "topLength": 0.2,
              "rightLength": 0.2,
              "bottomLength": 0.2,
              "leftLength": 0.2,
              "otherPaperNumber": null
            },
            "markerColor": ""
          }
        ],
        "numberPropertyControllers": [
          {
            "name": "ControllerForOnes_D",
            "controlledComponentName": "NumberOfOnes_D",
            "controlType": "MARKER_COUNT",
            "controlTypeFamily": "MARKERS",
            "markerColor": "all",
            "relationshipControlType": null
          }
        ],
        "enumerationPropertyControllers": []
      },
      "viewContainer": {
        "soundViews": [
          {
            "name": "ViewGoodConnectionSoundForOnes_D",
            "modelComponentNames": [
              "RectangleModelMode",
              "BooleanGoodConnectionForOnes_D"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "if ( BooleanGoodConnectionForOnes_D && RectangleModelMode ) {\r\n    play();\r\n}",
            "lazyLink": false,
            "soundFileName": "/uploads/SuccessSound.mp3",
            "loop": false,
            "autoplay": false
          },
          {
            "name": "ViewBadConnectionSoundForOnes_D",
            "modelComponentNames": [
              "RectangleModelMode",
              "BooleanBadConnectionForOnes_D"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "if ( BooleanBadConnectionForOnes_D && RectangleModelMode) {\r\n    play();\r\n}",
            "lazyLink": false,
            "soundFileName": "/uploads/OutOfBalanceSound.mp3",
            "loop": false,
            "autoplay": false
          }
        ],
        "speechViews": [
          {
            "name": "ViewNumberOfOnes_D",
            "modelComponentNames": [
              "BooleanNegativeForOnes_D",
              "NumberOfOnes_D"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "phet.paperLand.console.log(NumberOfOnes_D);\nif (Math.floor(NumberOfOnes_D) === 0) {\n// A paper with no markers represents a single 1 tile, so \n// we need to add 1 or -1 to the min value of 0. \n    if (BooleanNegativeForOnes_D) {\n        speak( -1 );\n    }\n    else {\n        speak( 1 );\n    }\n} else {\n    if (BooleanNegativeForOnes_D) {\n        speak( -Math.floor(NumberOfOnes_D) - 1 );\n    }\n    else {\n        speak( Math.floor(NumberOfOnes_D) + 1 );\n    }\n}",
            "lazyLink": false
          }
        ],
        "textViews": [
          {
            "name": "ViewTextTilesForOnes_D",
            "modelComponentNames": [
              "BooleanNegativeForOnes_D",
              "PositionForOnesTiles_D",
              "NumberOfOnes_D"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "if (BooleanNegativeForOnes_D) {\n        setString('] ' + (-NumberOfOnes_D - 1) + ' [');\n    }\n    else {\n        setString('[ ' + (NumberOfOnes_D + 1) + ' ]');\n    }\nsetFontSize(20);\nsetCenterX( phet.paperLand.utils.paperToBoardX( PositionForOnesTiles_D.x, sharedData.displaySize.width ))\nsetCenterY( phet.paperLand.utils.paperToBoardY( PositionForOnesTiles_D.y, sharedData.displaySize.height ))",
            "lazyLink": false,
            "defaultViewOptions": {
              "centerX": 0.5,
              "centerY": 0.5,
              "scale": 1,
              "rotation": 0,
              "opacity": 1,
              "visible": true,
              "viewUnits": "model"
            }
          }
        ],
        "shapeViews": [],
        "backgroundViews": [],
        "imageViews": []
      },
      "listenerContainer": {
        "linkListeners": [
          {
            "name": "ControllerBooleanLeftSideForOnes_D",
            "controlledPropertyNames": [
              "BooleanOnLeftSideForOnes_D"
            ],
            "controlFunctionString": "// Uncomment to voice side of equation\nsetBooleanOnLeftSideForOnes_D(BoundsLeftSideOfEquals.containsPoint( PositionForOnesTiles_D )); ",
            "dependencyNames": [
              "BoundsLeftSideOfEquals",
              "PositionForOnesTiles_D"
            ],
            "referenceComponentNames": []
          }
        ],
        "animationListeners": [],
        "bluetoothListeners": []
      },
      "customCodeContainer": {
        "onProgramAddedCode": "// Setting program data to the program for some sound design.\r\nphet.paperLand.setProgramData( paperNumber, 'term', 'ones' );\r\n\r\n// Using addModelObserver lets us add the tiles/bounds programs in any order\r\nscratchpad.observerId = phet.paperLand.addModelObserver(\r\n  'tileData', // the bounds program will create this array when it is added\r\n  tileDataArray => {\r\n\r\n    // as soon as the array is available, add this tile to it\r\n    scratchpad.thisTileData = {\r\n      onLeftSideProperty: phet.paperLand.getModelComponent( 'BooleanOnLeftSideForOnes_D' ),\r\n      negativeProperty: phet.paperLand.getModelComponent( 'BooleanNegativeForOnes_D' ),\r\n      countProperty: phet.paperLand.getModelComponent( 'NumberOfOnes_D' ),\r\n      term: 'ones'\r\n    }\r\n    tileDataArray.push( scratchpad.thisTileData );\r\n  },\r\n  tileDataArray => {\r\n\r\n    // Remove this tile from the array when the array is being removed\r\n    const index = tileDataArray.indexOf( scratchpad.thisTileData );\r\n    if ( index > -1 ) {\r\n        tileDataArray.splice( index, 1 );\r\n        delete scratchpad.tileData;\r\n    }\r\n  }\r\n);",
        "onProgramRemovedCode": "// Removes the term data from the model\r\nphet.paperLand.removeProgramData( paperNumber, 'term' );\r\n\r\nconst tileData = phet.paperLand.getModelComponent( 'tileData' );\r\nif ( tileData ) {\r\n\r\n    // Remove the tile from the array\r\n    const index = tileData.indexOf( scratchpad.thisTileData );\r\n    if ( index > -1 ) {\r\n        tileData.splice( index, 1 );\r\n        delete scratchpad.tileData;        \r\n    }\r\n}\r\n\r\n// remove the model observer\r\nphet.paperLand.removeModelObserver( 'tileData', scratchpad.observerId );\r\ndelete scratchpad.observerId;",
        "onProgramChangedPositionCode": "",
        "onProgramMarkersAddedCode": "",
        "onProgramMarkersRemovedCode": "",
        "onProgramMarkersChangedPositionCode": "",
        "onProgramAdjacentCode": "\r\n// Get a reference to the model component and only update it if it exists.\r\nconst goodConnectionComponent = phet.paperLand.getModelComponent( 'BooleanGoodConnectionForOnes_D' );\r\nconst badConnectionComponent = phet.paperLand.getModelComponent( 'BooleanBadConnectionForOnes_D' );\r\n\r\n\r\nif ( goodConnectionComponent && badConnectionComponent ) {\r\n\r\n    // If this is the left or right whisker...\r\n    if ( direction === 'left' || direction === 'right' ) {\r\n\r\n        // These are the terms that this program is allowed to connect to.\r\n        const goodConnectionTerms = [ 'ones' ];\r\n       \r\n        // These are the terms that this program is NOT allowed to connect to.\r\n        const badConnectionTerms = [ 'x', 'xSquared' ];\r\n\r\n        // This connection is \"good\" if the other program has a term in the good list\r\n        goodConnectionComponent.value = goodConnectionTerms.includes(\r\n\r\n            // get the term from the other program\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        );\r\n        // This connection is \"bad\" if the other program has a term in the bad list\r\n        badConnectionComponent.value = badConnectionTerms.includes(\r\n\r\n            // get the term from the other program\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        );\r\n    }\r\n\r\n    phet.paperLand.console.log( direction );\r\n\r\n    // If this is the top or bottom whisker...\r\n    if ( direction === 'top' || direction === 'bottom' ) {\r\n        \r\n        // These are the terms that this program is allowed to connect to.\r\n        // TODO: Add top and bottom of X tiles\r\n        const goodConnectionTerms = [ 'ones' ];\r\n       \r\n        // These are the terms that this program is NOT allowed to connect to.\r\n        // TODO: Add left and right of X tiles\r\n        const badConnectionTerms = [ 'xSquared' ];\r\n\r\n        // This connection is \"good\" if the other program has a term in the good list\r\n        goodConnectionComponent.value = goodConnectionTerms.includes(\r\n\r\n            // get the term from the other program\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        );\r\n        // This connection is \"bad\" if the other program has a term in the bad list\r\n        badConnectionComponent.value = badConnectionTerms.includes(\r\n\r\n            // get the term from the other program\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        );\r\n    }\r\n}",
        "onProgramSeparatedCode": "\r\n// Get a reference to the model component and only update it if it exists.\r\nconst goodConnectionComponent = phet.paperLand.getModelComponent( 'BooleanGoodConnectionForOnes_D' );\r\nconst badConnectionComponent = phet.paperLand.getModelComponent( 'BooleanBadConnectionForOnes_D' );\r\n\r\n// Components must exit check\r\nif ( goodConnectionComponent && badConnectionComponent )  {\r\n\r\n    // If this is the left or right whisker...\r\n    if ( direction === 'left' || direction === 'right' ) {\r\n\r\n        // These are the terms that this program is allowed to connect to.\r\n        const goodConnectionTerms = [ 'ones' ];\r\n\r\n         // These are the terms that this program is NOT allowed to connect to.\r\n        const badConnectionTerms = [ 'x', 'xSquared' ];\r\n\r\n        // If detatching from another program where connection is \"good\",\r\n        // the connection is no longer there.\r\n        if ( goodConnectionTerms.includes(\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        ) ) {\r\n            goodConnectionComponent.value = false;\r\n        }\r\n        // If detatching from another program where connection is \"bad\",\r\n        // the connection is no longer there.\r\n        if ( badConnectionTerms.includes(\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        ) ) {\r\n            badConnectionComponent.value = false;\r\n        }\r\n    }\r\n\r\n    // If this is the top or bottom whisker...\r\n    if ( direction === 'top' || direction === 'bottom' ) {\r\n\r\n       // These are the terms that this program is allowed to connect to.\r\n       // TODO: top and bottom of X tiles need to be added\r\n        const goodConnectionTerms = [ 'ones' ];\r\n\r\n         // These are the terms that this program is NOT allowed to connect to.\r\n         // TODO: left and right of X tiles need to be added\r\n        const badConnectionTerms = [ 'xSquared' ];\r\n\r\n        // If detatching from another program where connection is \"good\",\r\n        // the connection is no longer there.\r\n        if ( goodConnectionTerms.includes(\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        ) ) {\r\n            goodConnectionComponent.value = false;\r\n        }\r\n        // If detatching from another program where connection is \"bad\",\r\n        // the connection is no longer there.\r\n        if ( badConnectionTerms.includes(\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        ) ) {\r\n            badConnectionComponent.value = false;\r\n        }\r\n    }\r\n}"
      }
    },
    {
      "number": 1641,
      "title": "Ones Tiles E",
      "keywords": "TacTiles, algebra, voicing, ones, one, numbers",
      "description": "A program that voices the number of one-tiles and increments and decrements the number of ones using markers. Note that current model range is 0-9, and the voicing strings range from 1-10.",
      "expanded": false,
      "topWhiskerLength": 0.05,
      "rightWhiskerLength": 0.05,
      "bottomWhiskerLength": 0.05,
      "leftWhiskerLength": 0.05,
      "positionProperty": {
        "x": 396.45083176314284,
        "y": 360.8037502464378
      },
      "modelContainer": {
        "namedBooleanProperties": [
          {
            "name": "BooleanOnLeftSideForOnes_E",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          },
          {
            "name": "BooleanNegativeForOnes_E",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          },
          {
            "name": "BooleanGoodConnectionForOnes_E",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          },
          {
            "name": "BooleanBadConnectionForOnes_E",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          }
        ],
        "namedVector2Properties": [
          {
            "name": "PositionForOnesTiles_E",
            "propertyType": "Vector2Property",
            "defaultX": 0,
            "defaultY": 0
          }
        ],
        "namedNumberProperties": [
          {
            "name": "NumberOfOnes_E",
            "propertyType": "NumberProperty",
            "min": 0,
            "max": "9",
            "defaultValue": "0"
          }
        ],
        "namedEnumerationProperties": [],
        "namedDerivedProperties": [],
        "namedBounds2Properties": [],
        "namedObservableArrays": [],
        "namedArrayItems": [],
        "namedArrayItemReferences": [],
        "namedStringProperties": []
      },
      "controllerContainer": {
        "vector2PropertyControllers": [
          {
            "name": "ControllerPositionForOnes_E",
            "controlledComponentName": "PositionForOnesTiles_E",
            "controlType": "MATCH_CENTER",
            "controlTypeFamily": ""
          }
        ],
        "boundsPropertyControllers": [],
        "booleanPropertyControllers": [
          {
            "name": "ControllerBooleanNegativeForOnes_E",
            "controlledComponentName": "BooleanNegativeForOnes_E",
            "controlType": "ROTATION",
            "controlTypeFamily": "",
            "whiskerConfiguration": {
              "topLength": 0.2,
              "rightLength": 0.2,
              "bottomLength": 0.2,
              "leftLength": 0.2,
              "otherPaperNumber": null
            },
            "markerColor": ""
          }
        ],
        "numberPropertyControllers": [
          {
            "name": "ControllerForOnes_E",
            "controlledComponentName": "NumberOfOnes_E",
            "controlType": "MARKER_COUNT",
            "controlTypeFamily": "MARKERS",
            "markerColor": "all",
            "relationshipControlType": null
          }
        ],
        "enumerationPropertyControllers": []
      },
      "viewContainer": {
        "soundViews": [
          {
            "name": "ViewGoodConnectionSoundForOnes_E",
            "modelComponentNames": [
              "RectangleModelMode",
              "BooleanGoodConnectionForOnes_E"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "if ( BooleanGoodConnectionForOnes_E && RectangleModelMode ) {\r\n    play();\r\n}",
            "lazyLink": false,
            "soundFileName": "/uploads/SuccessSound.mp3",
            "loop": false,
            "autoplay": false
          },
          {
            "name": "ViewBadConnectionSoundForOnes_E",
            "modelComponentNames": [
              "RectangleModelMode",
              "BooleanBadConnectionForOnes_E"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "if ( BooleanBadConnectionForOnes_E && RectangleModelMode) {\r\n    play();\r\n}",
            "lazyLink": false,
            "soundFileName": "/uploads/OutOfBalanceSound.mp3",
            "loop": false,
            "autoplay": false
          }
        ],
        "speechViews": [
          {
            "name": "ViewNumberOfOnes_E",
            "modelComponentNames": [
              "BooleanNegativeForOnes_E",
              "NumberOfOnes_E"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "phet.paperLand.console.log(NumberOfOnes_E);\nif (Math.floor(NumberOfOnes_E) === 0) {\n// A paper with no markers represents a single 1 tile, so \n// we need to add 1 or -1 to the min value of 0. \n    if (BooleanNegativeForOnes_E) {\n        speak( -1 );\n    }\n    else {\n        speak( 1 );\n    }\n} else {\n    if (BooleanNegativeForOnes_E) {\n        speak( -Math.floor(NumberOfOnes_E) - 1 );\n    }\n    else {\n        speak( Math.floor(NumberOfOnes_E) + 1 );\n    }\n}",
            "lazyLink": false
          }
        ],
        "textViews": [
          {
            "name": "ViewTextTilesForOnes_E",
            "modelComponentNames": [
              "BooleanNegativeForOnes_E",
              "PositionForOnesTiles_E",
              "NumberOfOnes_E"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "if (BooleanNegativeForOnes_E) {\n        setString('] ' + (-NumberOfOnes_E - 1) + ' [');\n    }\n    else {\n        setString('[ ' + (NumberOfOnes_E + 1) + ' ]');\n    }\nsetFontSize(20);\nsetCenterX( phet.paperLand.utils.paperToBoardX( PositionForOnesTiles_E.x, sharedData.displaySize.width ))\nsetCenterY( phet.paperLand.utils.paperToBoardY( PositionForOnesTiles_E.y, sharedData.displaySize.height ))",
            "lazyLink": false,
            "defaultViewOptions": {
              "centerX": 0.5,
              "centerY": 0.5,
              "scale": 1,
              "rotation": 0,
              "opacity": 1,
              "visible": true,
              "viewUnits": "model"
            }
          }
        ],
        "shapeViews": [],
        "backgroundViews": [],
        "imageViews": []
      },
      "listenerContainer": {
        "linkListeners": [
          {
            "name": "ControllerBooleanLeftSideForOnes_E",
            "controlledPropertyNames": [
              "BooleanOnLeftSideForOnes_E"
            ],
            "controlFunctionString": "// Uncomment to voice side of equation\nsetBooleanOnLeftSideForOnes_E(BoundsLeftSideOfEquals.containsPoint( PositionForOnesTiles_E )); ",
            "dependencyNames": [
              "BoundsLeftSideOfEquals",
              "PositionForOnesTiles_E"
            ],
            "referenceComponentNames": []
          }
        ],
        "animationListeners": [],
        "bluetoothListeners": []
      },
      "customCodeContainer": {
        "onProgramAddedCode": "// Setting program data to the program for some sound design.\r\nphet.paperLand.setProgramData( paperNumber, 'term', 'ones' );\r\n\r\n// Using addModelObserver lets us add the tiles/bounds programs in any order\r\nscratchpad.observerId = phet.paperLand.addModelObserver(\r\n  'tileData', // the bounds program will create this array when it is added\r\n  tileDataArray => {\r\n\r\n    // as soon as the array is available, add this tile to it\r\n    scratchpad.thisTileData = {\r\n      onLeftSideProperty: phet.paperLand.getModelComponent( 'BooleanOnLeftSideForOnes_E' ),\r\n      negativeProperty: phet.paperLand.getModelComponent( 'BooleanNegativeForOnes_E' ),\r\n      countProperty: phet.paperLand.getModelComponent( 'NumberOfOnes_E' ),\r\n      term: 'ones'\r\n    }\r\n    tileDataArray.push( scratchpad.thisTileData );\r\n  },\r\n  tileDataArray => {\r\n\r\n    // Remove this tile from the array when the array is being removed\r\n    const index = tileDataArray.indexOf( scratchpad.thisTileData );\r\n    if ( index > -1 ) {\r\n        tileDataArray.splice( index, 1 );\r\n        delete scratchpad.tileData;\r\n    }\r\n  }\r\n);",
        "onProgramRemovedCode": "// Removes the term data from the model\r\nphet.paperLand.removeProgramData( paperNumber, 'term' );\r\n\r\nconst tileData = phet.paperLand.getModelComponent( 'tileData' );\r\nif ( tileData ) {\r\n\r\n    // Remove the tile from the array\r\n    const index = tileData.indexOf( scratchpad.thisTileData );\r\n    if ( index > -1 ) {\r\n        tileData.splice( index, 1 );\r\n        delete scratchpad.tileData;        \r\n    }\r\n}\r\n\r\n// remove the model observer\r\nphet.paperLand.removeModelObserver( 'tileData', scratchpad.observerId );\r\ndelete scratchpad.observerId;",
        "onProgramChangedPositionCode": "",
        "onProgramMarkersAddedCode": "",
        "onProgramMarkersRemovedCode": "",
        "onProgramMarkersChangedPositionCode": "",
        "onProgramAdjacentCode": "\r\n// Get a reference to the model component and only update it if it exists.\r\nconst goodConnectionComponent = phet.paperLand.getModelComponent( 'BooleanGoodConnectionForOnes_E' );\r\nconst badConnectionComponent = phet.paperLand.getModelComponent( 'BooleanBadConnectionForOnes_E' );\r\n\r\n\r\nif ( goodConnectionComponent && badConnectionComponent ) {\r\n\r\n    // If this is the left or right whisker...\r\n    if ( direction === 'left' || direction === 'right' ) {\r\n\r\n        // These are the terms that this program is allowed to connect to.\r\n        const goodConnectionTerms = [ 'ones' ];\r\n       \r\n        // These are the terms that this program is NOT allowed to connect to.\r\n        const badConnectionTerms = [ 'x', 'xSquared' ];\r\n\r\n        // This connection is \"good\" if the other program has a term in the good list\r\n        goodConnectionComponent.value = goodConnectionTerms.includes(\r\n\r\n            // get the term from the other program\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        );\r\n        // This connection is \"bad\" if the other program has a term in the bad list\r\n        badConnectionComponent.value = badConnectionTerms.includes(\r\n\r\n            // get the term from the other program\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        );\r\n    }\r\n\r\n    phet.paperLand.console.log( direction );\r\n\r\n    // If this is the top or bottom whisker...\r\n    if ( direction === 'top' || direction === 'bottom' ) {\r\n        \r\n        // These are the terms that this program is allowed to connect to.\r\n        // TODO: Add top and bottom of X tiles\r\n        const goodConnectionTerms = [ 'ones' ];\r\n       \r\n        // These are the terms that this program is NOT allowed to connect to.\r\n        // TODO: Add left and right of X tiles\r\n        const badConnectionTerms = [ 'xSquared' ];\r\n\r\n        // This connection is \"good\" if the other program has a term in the good list\r\n        goodConnectionComponent.value = goodConnectionTerms.includes(\r\n\r\n            // get the term from the other program\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        );\r\n        // This connection is \"bad\" if the other program has a term in the bad list\r\n        badConnectionComponent.value = badConnectionTerms.includes(\r\n\r\n            // get the term from the other program\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        );\r\n    }\r\n}",
        "onProgramSeparatedCode": "\r\n// Get a reference to the model component and only update it if it exists.\r\nconst goodConnectionComponent = phet.paperLand.getModelComponent( 'BooleanGoodConnectionForOnes_E' );\r\nconst badConnectionComponent = phet.paperLand.getModelComponent( 'BooleanBadConnectionForOnes_E' );\r\n\r\n// Components must exit check\r\nif ( goodConnectionComponent && badConnectionComponent )  {\r\n\r\n    // If this is the left or right whisker...\r\n    if ( direction === 'left' || direction === 'right' ) {\r\n\r\n        // These are the terms that this program is allowed to connect to.\r\n        const goodConnectionTerms = [ 'ones' ];\r\n\r\n         // These are the terms that this program is NOT allowed to connect to.\r\n        const badConnectionTerms = [ 'x', 'xSquared' ];\r\n\r\n        // If detatching from another program where connection is \"good\",\r\n        // the connection is no longer there.\r\n        if ( goodConnectionTerms.includes(\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        ) ) {\r\n            goodConnectionComponent.value = false;\r\n        }\r\n        // If detatching from another program where connection is \"bad\",\r\n        // the connection is no longer there.\r\n        if ( badConnectionTerms.includes(\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        ) ) {\r\n            badConnectionComponent.value = false;\r\n        }\r\n    }\r\n\r\n    // If this is the top or bottom whisker...\r\n    if ( direction === 'top' || direction === 'bottom' ) {\r\n\r\n       // These are the terms that this program is allowed to connect to.\r\n       // TODO: top and bottom of X tiles need to be added\r\n        const goodConnectionTerms = [ 'ones' ];\r\n\r\n         // These are the terms that this program is NOT allowed to connect to.\r\n         // TODO: left and right of X tiles need to be added\r\n        const badConnectionTerms = [ 'xSquared' ];\r\n\r\n        // If detatching from another program where connection is \"good\",\r\n        // the connection is no longer there.\r\n        if ( goodConnectionTerms.includes(\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        ) ) {\r\n            goodConnectionComponent.value = false;\r\n        }\r\n        // If detatching from another program where connection is \"bad\",\r\n        // the connection is no longer there.\r\n        if ( badConnectionTerms.includes(\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        ) ) {\r\n            badConnectionComponent.value = false;\r\n        }\r\n    }\r\n}"
      }
    },
    {
      "number": 1561,
      "title": "X Tiles B",
      "keywords": "NumberXCoefficient",
      "description": "A program that voices the number of x-tiles (the coefficient of x) and increments and decrements the coefficient using markers.  Note that current model range for the coefficient is 0-9, voicing strings range from x to 10x.",
      "expanded": false,
      "topWhiskerLength": 0.05,
      "rightWhiskerLength": 0.05,
      "bottomWhiskerLength": 0.05,
      "leftWhiskerLength": 0.05,
      "positionProperty": {
        "x": 482.9000244140625,
        "y": 391.85897637816583
      },
      "modelContainer": {
        "namedBooleanProperties": [
          {
            "name": "BooleanOnLeftSideForX_B",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          },
          {
            "name": "BooleanNegativeForX_B",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          },
          {
            "name": "BooleanGoodConnectionForX_B",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          },
          {
            "name": "BooleanBadConnectionForX_B",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          }
        ],
        "namedVector2Properties": [
          {
            "name": "PositionForXTiles_B",
            "propertyType": "Vector2Property",
            "defaultX": 0,
            "defaultY": 0
          }
        ],
        "namedNumberProperties": [
          {
            "name": "NumberXCoefficient_B",
            "propertyType": "NumberProperty",
            "min": 0,
            "max": "9",
            "defaultValue": "0"
          }
        ],
        "namedEnumerationProperties": [],
        "namedDerivedProperties": [],
        "namedBounds2Properties": [],
        "namedObservableArrays": [],
        "namedArrayItems": [],
        "namedArrayItemReferences": [],
        "namedStringProperties": []
      },
      "controllerContainer": {
        "vector2PropertyControllers": [
          {
            "name": "ControllerPositionForX_B",
            "controlledComponentName": "PositionForXTiles_B",
            "controlType": "MATCH_CENTER",
            "controlTypeFamily": ""
          }
        ],
        "boundsPropertyControllers": [],
        "booleanPropertyControllers": [
          {
            "name": "ControllerBooleanNegativeForX_B",
            "controlledComponentName": "BooleanNegativeForX_B",
            "controlType": "ROTATION",
            "controlTypeFamily": "",
            "whiskerConfiguration": {
              "topLength": 0.2,
              "rightLength": 0.2,
              "bottomLength": 0.2,
              "leftLength": 0.2,
              "otherPaperNumber": null
            },
            "markerColor": ""
          }
        ],
        "numberPropertyControllers": [
          {
            "name": "ControllerXCoefficient_B",
            "controlledComponentName": "NumberXCoefficient_B",
            "controlType": "MARKER_COUNT",
            "controlTypeFamily": "MARKERS",
            "markerColor": "all",
            "relationshipControlType": null
          }
        ],
        "enumerationPropertyControllers": []
      },
      "viewContainer": {
        "soundViews": [
          {
            "name": "ViewGoodConnectionSoundForX_B",
            "modelComponentNames": [
              "RectangleModelMode",
              "BooleanGoodConnectionForX_B"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "if ( BooleanGoodConnectionForX_B && RectangleModelMode ) {\r\n    play();\r\n}",
            "lazyLink": false,
            "soundFileName": "/uploads/SuccessSound.mp3",
            "loop": false,
            "autoplay": false
          },
          {
            "name": "ViewBadConnectionSoundForX_B",
            "modelComponentNames": [
              "RectangleModelMode",
              "BooleanBadConnectionForX_B"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "if ( BooleanBadConnectionForX_B && RectangleModelMode ) {\n    play();\n}",
            "lazyLink": false,
            "soundFileName": "/uploads/OutOfBalanceSound.mp3",
            "loop": false,
            "autoplay": false
          }
        ],
        "speechViews": [
          {
            "name": "ViewNumberOfX_B",
            "modelComponentNames": [
              "BooleanNegativeForX_B",
              "NumberXCoefficient_B"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "  // A paper with no markers represents a 1x tile or a -1x tile \n  // and not 0x. We need to add or minus 1, and \n  // for the case of 1x not voice the coefficient. \n  // I think it is ok to voice -1x rather than -x.\nif (Math.floor(NumberXCoefficient_B) === 0) {\n    if (BooleanNegativeForX_B) {\n        speak( 'minus x' );\n    }\n    else {\n        speak( 'x' );\n    }\n} else {\n    if (BooleanNegativeForX_B) {\n        speak( -Math.floor(NumberXCoefficient_B) - 1 + 'x' );\n    }\n    else {\n        speak( Math.floor(NumberXCoefficient_B) + 1 + 'x' );\n    }\n}",
            "lazyLink": false
          }
        ],
        "textViews": [
          {
            "name": "ViewTextTilesForXTiles_B",
            "modelComponentNames": [
              "BooleanNegativeForX_B",
              "PositionForXTiles_B",
              "NumberXCoefficient_B"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "if (Math.floor(NumberXCoefficient_B) === 0) {\n    if (BooleanNegativeForX_B) {\n        setString('] ' + '-x [');\n    }\n    else {\n        setString('[ ' + 'x ]');\n    }\n} \nelse {\n    if (BooleanNegativeForX_B) {\n        setString('] ' + (-NumberXCoefficient_B - 1) + 'x [');\n    }\n    else {\n        setString('[ ' + (NumberXCoefficient_B + 1) + 'x ]');\n    }\n}\nsetFontSize(20);\nsetCenterX( phet.paperLand.utils.paperToBoardX( PositionForXTiles_B.x, sharedData.displaySize.width ))\nsetCenterY( phet.paperLand.utils.paperToBoardY( PositionForXTiles_B.y, sharedData.displaySize.height ))\nphet.paperLand.console.log( phet.paperLand.utils.paperToBoardX( PositionForXTiles_B.x, sharedData.displaySize.width ));",
            "lazyLink": false,
            "defaultViewOptions": {
              "centerX": 0.5,
              "centerY": 0.5,
              "scale": 1,
              "rotation": 0,
              "opacity": 1,
              "visible": true,
              "viewUnits": "model"
            }
          }
        ],
        "shapeViews": [],
        "backgroundViews": [],
        "imageViews": []
      },
      "listenerContainer": {
        "linkListeners": [
          {
            "name": "ControllerBooleanLeftSideForX_B",
            "controlledPropertyNames": [
              "BooleanOnLeftSideForX_B"
            ],
            "controlFunctionString": "setBooleanOnLeftSideForX_B(BoundsLeftSideOfEquals.containsPoint( PositionForXTiles_B )); ",
            "dependencyNames": [
              "BoundsLeftSideOfEquals",
              "PositionForXTiles_B"
            ],
            "referenceComponentNames": []
          }
        ],
        "animationListeners": [],
        "bluetoothListeners": []
      },
      "customCodeContainer": {
        "onProgramAddedCode": "// Setting program data to the program for some sound design.\r\nphet.paperLand.setProgramData( paperNumber, 'term', 'x' );\r\n\r\n// Using addModelObserver lets us add the tiles/bounds programs in any order\r\nscratchpad.observerId = phet.paperLand.addModelObserver(\r\n  'tileData', // the bounds program will create this array when it is added\r\n  tileDataArray => {\r\n\r\n    // as soon as the array is available, add this tile to it\r\n    scratchpad.thisTileData = {\r\n      onLeftSideProperty: phet.paperLand.getModelComponent( 'BooleanOnLeftSideForX_B' ),\r\n      negativeProperty: phet.paperLand.getModelComponent( 'BooleanNegativeForX_B' ),\r\n      countProperty: phet.paperLand.getModelComponent( 'NumberXCoefficient_B' ),\r\n      term: 'x'\r\n    }\r\n    tileDataArray.push( scratchpad.thisTileData );\r\n  },\r\n  tileDataArray => {\r\n\r\n    // Remove this tile from the array when the array is being removed\r\n    const index = tileDataArray.indexOf( scratchpad.thisTileData );\r\n    if ( index > -1 ) {\r\n        tileDataArray.splice( index, 1 );\r\n        delete scratchpad.tileData;\r\n    }\r\n  }\r\n);",
        "onProgramRemovedCode": "// Removes the term data from the model\r\nphet.paperLand.removeProgramData( paperNumber, 'term' );\r\n\r\nconst tileData = phet.paperLand.getModelComponent( 'tileData' );\r\nif ( tileData ) {\r\n\r\n    // Remove the tile from the array\r\n    const index = tileData.indexOf( scratchpad.thisTileData );\r\n    if ( index > -1 ) {\r\n        tileData.splice( index, 1 );\r\n        delete scratchpad.tileData;        \r\n    }\r\n}\r\n\r\n// remove the model observer\r\nphet.paperLand.removeModelObserver( 'tileData', scratchpad.observerId );\r\ndelete scratchpad.observerId;",
        "onProgramChangedPositionCode": "",
        "onProgramMarkersAddedCode": "",
        "onProgramMarkersRemovedCode": "",
        "onProgramMarkersChangedPositionCode": "",
        "onProgramAdjacentCode": "\n// Get a reference to the model component and only update it if it exists.\nconst goodConnectionComponent = phet.paperLand.getModelComponent( 'BooleanGoodConnectionForX_B' );\nconst badConnectionComponent = phet.paperLand.getModelComponent( 'BooleanBadConnectionForX_B' );\n\n\nif ( goodConnectionComponent && badConnectionComponent ) {\n\n    // If this is the left or right whisker...\n    if ( direction === 'left' || direction === 'right' ) {\n\n        // These are the terms that this program is allowed to connect to.\n        const goodConnectionTerms = [ 'xSquared' ];\n       \n        // These are the terms that this program is NOT allowed to connect to.\n        const badConnectionTerms = [ 'ones' ];\n\n        // This connection is \"good\" if the other program has a term in the good list\n        goodConnectionComponent.value = goodConnectionTerms.includes(\n\n            // get the term from the other program\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\n        );\n        // This connection is \"bad\" if the other program has a term in the bad list\n        badConnectionComponent.value = badConnectionTerms.includes(\n\n            // get the term from the other program\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\n        );\n    }\n\n    phet.paperLand.console.log( direction );\n\n    // If this is the top or bottom whisker...\n    if ( direction === 'top' || direction === 'bottom' ) {\n        \n        // These are the terms that this program is allowed to connect to.\n        const goodConnectionTerms = [ 'ones' ];\n       \n        // These are the terms that this program is NOT allowed to connect to.\n        const badConnectionTerms = [ 'xSquared' ];\n\n        // This connection is \"good\" if the other program has a term in the good list\n        goodConnectionComponent.value = goodConnectionTerms.includes(\n\n            // get the term from the other program\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\n        );\n        // This connection is \"bad\" if the other program has a term in the bad list\n        badConnectionComponent.value = badConnectionTerms.includes(\n\n            // get the term from the other program\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\n        );\n    }\n}",
        "onProgramSeparatedCode": "\r\n// Get a reference to the model component and only update it if it exists.\r\nconst goodConnectionComponent = phet.paperLand.getModelComponent( 'BooleanGoodConnectionForX_B' );\r\nconst badConnectionComponent = phet.paperLand.getModelComponent( 'BooleanBadConnectionForX_B' );\r\n\r\n// Components must exit check\r\nif ( goodConnectionComponent && badConnectionComponent )  {\r\n\r\n    // If this is the left or right whisker...\r\n    if ( direction === 'left' || direction === 'right' ) {\r\n\r\n        // These are the terms that this program is allowed to connect to.\r\n        const goodConnectionTerms = [ 'xSquared' ];\r\n\r\n         // These are the terms that this program is NOT allowed to connect to.\r\n        const badConnectionTerms = [ 'ones' ];\r\n\r\n        // If detatching from another program where connection is \"good\",\r\n        // the connection is no longer there.\r\n        if ( goodConnectionTerms.includes(\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        ) ) {\r\n            goodConnectionComponent.value = false;\r\n        }\r\n        // If detatching from another program where connection is \"bad\",\r\n        // the connection is no longer there.\r\n        if ( badConnectionTerms.includes(\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        ) ) {\r\n            badConnectionComponent.value = false;\r\n        }\r\n    }\r\n\r\n    // If this is the top or bottom whisker...\r\n    if ( direction === 'top' || direction === 'bottom' ) {\r\n\r\n       // These are the terms that this program is allowed to connect to.\r\n       // TODO: Need to add top and bottom of X tiles\r\n        const goodConnectionTerms = [ 'ones' ];\r\n\r\n         // These are the terms that this program is NOT allowed to connect to.\r\n        // TODO: Need to add left and right of X tiles\r\n        const badConnectionTerms = [ 'xSquared' ];\r\n\r\n        // If detatching from another program where connection is \"good\",\r\n        // the connection is no longer there.\r\n        if ( goodConnectionTerms.includes(\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        ) ) {\r\n            goodConnectionComponent.value = false;\r\n        }\r\n        // If detatching from another program where connection is \"bad\",\r\n        // the connection is no longer there.\r\n        if ( badConnectionTerms.includes(\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        ) ) {\r\n            badConnectionComponent.value = false;\r\n        }\r\n    }\r\n}"
      }
    },
    {
      "number": 141,
      "title": "X Tiles C",
      "keywords": "NumberXCoefficient",
      "description": "A program that voices the number of x-tiles (the coefficient of x) and increments and decrements the coefficient using markers.  Note that current model range for the coefficient is 0-9, voicing strings range from x to 10x.",
      "expanded": false,
      "topWhiskerLength": 0.05,
      "rightWhiskerLength": 0.05,
      "bottomWhiskerLength": 0.05,
      "leftWhiskerLength": 0.05,
      "positionProperty": {
        "x": 447.70001220703125,
        "y": 394.16134454222833
      },
      "modelContainer": {
        "namedBooleanProperties": [
          {
            "name": "BooleanOnLeftSideForX_C",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          },
          {
            "name": "BooleanNegativeForX_C",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          },
          {
            "name": "BooleanGoodConnectionForX_C",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          },
          {
            "name": "BooleanBadConnectionForX_C",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          }
        ],
        "namedVector2Properties": [
          {
            "name": "PositionForXTiles_C",
            "propertyType": "Vector2Property",
            "defaultX": 0,
            "defaultY": 0
          }
        ],
        "namedNumberProperties": [
          {
            "name": "NumberXCoefficient_C",
            "propertyType": "NumberProperty",
            "min": 0,
            "max": "9",
            "defaultValue": "0"
          }
        ],
        "namedEnumerationProperties": [],
        "namedDerivedProperties": [],
        "namedBounds2Properties": [],
        "namedObservableArrays": [],
        "namedArrayItems": [],
        "namedArrayItemReferences": [],
        "namedStringProperties": []
      },
      "controllerContainer": {
        "vector2PropertyControllers": [
          {
            "name": "ControllerPositionForX_C",
            "controlledComponentName": "PositionForXTiles_C",
            "controlType": "MATCH_CENTER",
            "controlTypeFamily": ""
          }
        ],
        "boundsPropertyControllers": [],
        "booleanPropertyControllers": [
          {
            "name": "ControllerBooleanNegativeForX_C",
            "controlledComponentName": "BooleanNegativeForX_C",
            "controlType": "ROTATION",
            "controlTypeFamily": "",
            "whiskerConfiguration": {
              "topLength": 0.2,
              "rightLength": 0.2,
              "bottomLength": 0.2,
              "leftLength": 0.2,
              "otherPaperNumber": null
            },
            "markerColor": ""
          }
        ],
        "numberPropertyControllers": [
          {
            "name": "ControllerXCoefficient_C",
            "controlledComponentName": "NumberXCoefficient_C",
            "controlType": "MARKER_COUNT",
            "controlTypeFamily": "MARKERS",
            "markerColor": "all",
            "relationshipControlType": null
          }
        ],
        "enumerationPropertyControllers": []
      },
      "viewContainer": {
        "soundViews": [
          {
            "name": "ViewGoodConnectionSoundForX_C",
            "modelComponentNames": [
              "RectangleModelMode",
              "BooleanGoodConnectionForX_C"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "if ( BooleanGoodConnectionForX_C && RectangleModelMode ) {\r\n    play();\r\n}",
            "lazyLink": false,
            "soundFileName": "/uploads/SuccessSound.mp3",
            "loop": false,
            "autoplay": false
          },
          {
            "name": "ViewBadConnectionSoundForX_C",
            "modelComponentNames": [
              "RectangleModelMode",
              "BooleanBadConnectionForX_C"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "if ( BooleanBadConnectionForX_C && RectangleModelMode ) {\n    play();\n}",
            "lazyLink": false,
            "soundFileName": "/uploads/OutOfBalanceSound.mp3",
            "loop": false,
            "autoplay": false
          }
        ],
        "speechViews": [
          {
            "name": "ViewNumberOfX_C",
            "modelComponentNames": [
              "BooleanNegativeForX_C",
              "NumberXCoefficient_C"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "  // A paper with no markers represents a 1x tile or a -1x tile \n  // and not 0x. We need to add or minus 1, and \n  // for the case of 1x not voice the coefficient. \n  // I think it is ok to voice -1x rather than -x.\nif (Math.floor(NumberXCoefficient_C) === 0) {\n    if (BooleanNegativeForX_C) {\n        speak( 'minus x' );\n    }\n    else {\n        speak( 'x' );\n    }\n} else {\n    if (BooleanNegativeForX_C) {\n        speak( -Math.floor(NumberXCoefficient_C) - 1 + 'x' );\n    }\n    else {\n        speak( Math.floor(NumberXCoefficient_C) + 1 + 'x' );\n    }\n}",
            "lazyLink": false
          }
        ],
        "textViews": [
          {
            "name": "ViewTextTilesForXTiles_C",
            "modelComponentNames": [
              "BooleanNegativeForX_C",
              "PositionForXTiles_C",
              "NumberXCoefficient_C"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "if (Math.floor(NumberXCoefficient_C) === 0) {\n    if (BooleanNegativeForX_C) {\n        setString('] ' + '-x [');\n    }\n    else {\n        setString('[ ' + 'x ]');\n    }\n} \nelse {\n    if (BooleanNegativeForX_C) {\n        setString('] ' + (-NumberXCoefficient_C - 1) + 'x [');\n    }\n    else {\n        setString('[ ' + (NumberXCoefficient_C + 1) + 'x ]');\n    }\n}\nsetFontSize(20);\nsetCenterX( phet.paperLand.utils.paperToBoardX( PositionForXTiles_C.x, sharedData.displaySize.width ))\nsetCenterY( phet.paperLand.utils.paperToBoardY( PositionForXTiles_C.y, sharedData.displaySize.height ))\nphet.paperLand.console.log( phet.paperLand.utils.paperToBoardX( PositionForXTiles_C.x, sharedData.displaySize.width ));",
            "lazyLink": false,
            "defaultViewOptions": {
              "centerX": 0.5,
              "centerY": 0.5,
              "scale": 1,
              "rotation": 0,
              "opacity": 1,
              "visible": true,
              "viewUnits": "model"
            }
          }
        ],
        "shapeViews": [],
        "backgroundViews": [],
        "imageViews": []
      },
      "listenerContainer": {
        "linkListeners": [
          {
            "name": "ControllerBooleanLeftSideForX_C",
            "controlledPropertyNames": [
              "BooleanOnLeftSideForX_C"
            ],
            "controlFunctionString": "setBooleanOnLeftSideForX_C(BoundsLeftSideOfEquals.containsPoint( PositionForXTiles_C )); ",
            "dependencyNames": [
              "BoundsLeftSideOfEquals",
              "PositionForXTiles_C"
            ],
            "referenceComponentNames": []
          }
        ],
        "animationListeners": [],
        "bluetoothListeners": []
      },
      "customCodeContainer": {
        "onProgramAddedCode": "// Setting program data to the program for some sound design.\r\nphet.paperLand.setProgramData( paperNumber, 'term', 'x' );\r\n\r\n// Using addModelObserver lets us add the tiles/bounds programs in any order\r\nscratchpad.observerId = phet.paperLand.addModelObserver(\r\n  'tileData', // the bounds program will create this array when it is added\r\n  tileDataArray => {\r\n\r\n    // as soon as the array is available, add this tile to it\r\n    scratchpad.thisTileData = {\r\n      onLeftSideProperty: phet.paperLand.getModelComponent( 'BooleanOnLeftSideForX_C' ),\r\n      negativeProperty: phet.paperLand.getModelComponent( 'BooleanNegativeForX_C' ),\r\n      countProperty: phet.paperLand.getModelComponent( 'NumberXCoefficient_C' ),\r\n      term: 'x'\r\n    }\r\n    tileDataArray.push( scratchpad.thisTileData );\r\n  },\r\n  tileDataArray => {\r\n\r\n    // Remove this tile from the array when the array is being removed\r\n    const index = tileDataArray.indexOf( scratchpad.thisTileData );\r\n    if ( index > -1 ) {\r\n        tileDataArray.splice( index, 1 );\r\n        delete scratchpad.tileData;\r\n    }\r\n  }\r\n);",
        "onProgramRemovedCode": "// Removes the term data from the model\r\nphet.paperLand.removeProgramData( paperNumber, 'term' );\r\n\r\nconst tileData = phet.paperLand.getModelComponent( 'tileData' );\r\nif ( tileData ) {\r\n\r\n    // Remove the tile from the array\r\n    const index = tileData.indexOf( scratchpad.thisTileData );\r\n    if ( index > -1 ) {\r\n        tileData.splice( index, 1 );\r\n        delete scratchpad.tileData;        \r\n    }\r\n}\r\n\r\n// remove the model observer\r\nphet.paperLand.removeModelObserver( 'tileData', scratchpad.observerId );\r\ndelete scratchpad.observerId;",
        "onProgramChangedPositionCode": "",
        "onProgramMarkersAddedCode": "",
        "onProgramMarkersRemovedCode": "",
        "onProgramMarkersChangedPositionCode": "",
        "onProgramAdjacentCode": "\n// Get a reference to the model component and only update it if it exists.\nconst goodConnectionComponent = phet.paperLand.getModelComponent( 'BooleanGoodConnectionForX_C' );\nconst badConnectionComponent = phet.paperLand.getModelComponent( 'BooleanBadConnectionForX_C' );\n\n\nif ( goodConnectionComponent && badConnectionComponent ) {\n\n    // If this is the left or right whisker...\n    if ( direction === 'left' || direction === 'right' ) {\n\n        // These are the terms that this program is allowed to connect to.\n        const goodConnectionTerms = [ 'xSquared' ];\n       \n        // These are the terms that this program is NOT allowed to connect to.\n        const badConnectionTerms = [ 'ones' ];\n\n        // This connection is \"good\" if the other program has a term in the good list\n        goodConnectionComponent.value = goodConnectionTerms.includes(\n\n            // get the term from the other program\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\n        );\n        // This connection is \"bad\" if the other program has a term in the bad list\n        badConnectionComponent.value = badConnectionTerms.includes(\n\n            // get the term from the other program\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\n        );\n    }\n\n    phet.paperLand.console.log( direction );\n\n    // If this is the top or bottom whisker...\n    if ( direction === 'top' || direction === 'bottom' ) {\n        \n        // These are the terms that this program is allowed to connect to.\n        const goodConnectionTerms = [ 'ones' ];\n       \n        // These are the terms that this program is NOT allowed to connect to.\n        const badConnectionTerms = [ 'xSquared' ];\n\n        // This connection is \"good\" if the other program has a term in the good list\n        goodConnectionComponent.value = goodConnectionTerms.includes(\n\n            // get the term from the other program\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\n        );\n        // This connection is \"bad\" if the other program has a term in the bad list\n        badConnectionComponent.value = badConnectionTerms.includes(\n\n            // get the term from the other program\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\n        );\n    }\n}",
        "onProgramSeparatedCode": "\r\n// Get a reference to the model component and only update it if it exists.\r\nconst goodConnectionComponent = phet.paperLand.getModelComponent( 'BooleanGoodConnectionForX_C' );\r\nconst badConnectionComponent = phet.paperLand.getModelComponent( 'BooleanBadConnectionForX_C' );\r\n\r\n// Components must exit check\r\nif ( goodConnectionComponent && badConnectionComponent )  {\r\n\r\n    // If this is the left or right whisker...\r\n    if ( direction === 'left' || direction === 'right' ) {\r\n\r\n        // These are the terms that this program is allowed to connect to.\r\n        const goodConnectionTerms = [ 'xSquared' ];\r\n\r\n         // These are the terms that this program is NOT allowed to connect to.\r\n        const badConnectionTerms = [ 'ones' ];\r\n\r\n        // If detatching from another program where connection is \"good\",\r\n        // the connection is no longer there.\r\n        if ( goodConnectionTerms.includes(\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        ) ) {\r\n            goodConnectionComponent.value = false;\r\n        }\r\n        // If detatching from another program where connection is \"bad\",\r\n        // the connection is no longer there.\r\n        if ( badConnectionTerms.includes(\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        ) ) {\r\n            badConnectionComponent.value = false;\r\n        }\r\n    }\r\n\r\n    // If this is the top or bottom whisker...\r\n    if ( direction === 'top' || direction === 'bottom' ) {\r\n\r\n       // These are the terms that this program is allowed to connect to.\r\n       // TODO: Need to add top and bottom of X tiles\r\n        const goodConnectionTerms = [ 'ones' ];\r\n\r\n         // These are the terms that this program is NOT allowed to connect to.\r\n        // TODO: Need to add left and right of X tiles\r\n        const badConnectionTerms = [ 'xSquared' ];\r\n\r\n        // If detatching from another program where connection is \"good\",\r\n        // the connection is no longer there.\r\n        if ( goodConnectionTerms.includes(\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        ) ) {\r\n            goodConnectionComponent.value = false;\r\n        }\r\n        // If detatching from another program where connection is \"bad\",\r\n        // the connection is no longer there.\r\n        if ( badConnectionTerms.includes(\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        ) ) {\r\n            badConnectionComponent.value = false;\r\n        }\r\n    }\r\n}"
      }
    },
    {
      "number": 1036,
      "title": "X Tiles D",
      "keywords": "NumberXCoefficient",
      "description": "A program that voices the number of x-tiles (the coefficient of x) and increments and decrements the coefficient using markers.  Note that current model range for the coefficient is 0-9, voicing strings range from x to 10x.",
      "expanded": false,
      "topWhiskerLength": 0.05,
      "rightWhiskerLength": 0.05,
      "bottomWhiskerLength": 0.05,
      "leftWhiskerLength": 0.05,
      "positionProperty": {
        "x": 478.20001220703125,
        "y": 418.2
      },
      "modelContainer": {
        "namedBooleanProperties": [
          {
            "name": "BooleanOnLeftSideForX_D",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          },
          {
            "name": "BooleanNegativeForX_D",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          },
          {
            "name": "BooleanGoodConnectionForX_D",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          },
          {
            "name": "BooleanBadConnectionForX_D",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          }
        ],
        "namedVector2Properties": [
          {
            "name": "PositionForXTiles_D",
            "propertyType": "Vector2Property",
            "defaultX": 0,
            "defaultY": 0
          }
        ],
        "namedNumberProperties": [
          {
            "name": "NumberXCoefficient_D",
            "propertyType": "NumberProperty",
            "min": 0,
            "max": "9",
            "defaultValue": "0"
          }
        ],
        "namedEnumerationProperties": [],
        "namedDerivedProperties": [],
        "namedBounds2Properties": [],
        "namedObservableArrays": [],
        "namedArrayItems": [],
        "namedArrayItemReferences": [],
        "namedStringProperties": []
      },
      "controllerContainer": {
        "vector2PropertyControllers": [
          {
            "name": "ControllerPositionForX_D",
            "controlledComponentName": "PositionForXTiles_D",
            "controlType": "MATCH_CENTER",
            "controlTypeFamily": ""
          }
        ],
        "boundsPropertyControllers": [],
        "booleanPropertyControllers": [
          {
            "name": "ControllerBooleanNegativeForX_D",
            "controlledComponentName": "BooleanNegativeForX_D",
            "controlType": "ROTATION",
            "controlTypeFamily": "",
            "whiskerConfiguration": {
              "topLength": 0.2,
              "rightLength": 0.2,
              "bottomLength": 0.2,
              "leftLength": 0.2,
              "otherPaperNumber": null
            },
            "markerColor": ""
          }
        ],
        "numberPropertyControllers": [
          {
            "name": "ControllerXCoefficient_D",
            "controlledComponentName": "NumberXCoefficient_D",
            "controlType": "MARKER_COUNT",
            "controlTypeFamily": "MARKERS",
            "markerColor": "all",
            "relationshipControlType": null
          }
        ],
        "enumerationPropertyControllers": []
      },
      "viewContainer": {
        "soundViews": [
          {
            "name": "ViewGoodConnectionSoundForX_D",
            "modelComponentNames": [
              "RectangleModelMode",
              "BooleanGoodConnectionForX_D"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "if ( BooleanGoodConnectionForX_D && RectangleModelMode ) {\r\n    play();\r\n}",
            "lazyLink": false,
            "soundFileName": "/uploads/SuccessSound.mp3",
            "loop": false,
            "autoplay": false
          },
          {
            "name": "ViewBadConnectionSoundForX_D",
            "modelComponentNames": [
              "RectangleModelMode",
              "BooleanBadConnectionForX_D"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "if ( BooleanBadConnectionForX_D && RectangleModelMode ) {\n    play();\n}",
            "lazyLink": false,
            "soundFileName": "/uploads/OutOfBalanceSound.mp3",
            "loop": false,
            "autoplay": false
          }
        ],
        "speechViews": [
          {
            "name": "ViewNumberOfX_D",
            "modelComponentNames": [
              "BooleanNegativeForX_D",
              "NumberXCoefficient_D"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "  // A paper with no markers represents a 1x tile or a -1x tile \n  // and not 0x. We need to add or minus 1, and \n  // for the case of 1x not voice the coefficient. \n  // I think it is ok to voice -1x rather than -x.\nif (Math.floor(NumberXCoefficient_D) === 0) {\n    if (BooleanNegativeForX_D) {\n        speak( 'minus x' );\n    }\n    else {\n        speak( 'x' );\n    }\n} else {\n    if (BooleanNegativeForX_D) {\n        speak( -Math.floor(NumberXCoefficient_D) - 1 + 'x' );\n    }\n    else {\n        speak( Math.floor(NumberXCoefficient_D) + 1 + 'x' );\n    }\n}",
            "lazyLink": false
          }
        ],
        "textViews": [
          {
            "name": "ViewTextTilesForXTiles_D",
            "modelComponentNames": [
              "BooleanNegativeForX_D",
              "PositionForXTiles_D",
              "NumberXCoefficient_D"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "if (Math.floor(NumberXCoefficient_D) === 0) {\n    if (BooleanNegativeForX_D) {\n        setString('] ' + '-x [');\n    }\n    else {\n        setString('[ ' + 'x ]');\n    }\n} \nelse {\n    if (BooleanNegativeForX_D) {\n        setString('] ' + (-NumberXCoefficient_D - 1) + 'x [');\n    }\n    else {\n        setString('[ ' + (NumberXCoefficient_D + 1) + 'x ]');\n    }\n}\nsetFontSize(20);\nsetCenterX( phet.paperLand.utils.paperToBoardX( PositionForXTiles_D.x, sharedData.displaySize.width ))\nsetCenterY( phet.paperLand.utils.paperToBoardY( PositionForXTiles_D.y, sharedData.displaySize.height ))\nphet.paperLand.console.log( phet.paperLand.utils.paperToBoardX( PositionForXTiles_D.x, sharedData.displaySize.width ));",
            "lazyLink": false,
            "defaultViewOptions": {
              "centerX": 0.5,
              "centerY": 0.5,
              "scale": 1,
              "rotation": 0,
              "opacity": 1,
              "visible": true,
              "viewUnits": "model"
            }
          }
        ],
        "shapeViews": [],
        "backgroundViews": [],
        "imageViews": []
      },
      "listenerContainer": {
        "linkListeners": [
          {
            "name": "ControllerBooleanLeftSideForX_D",
            "controlledPropertyNames": [
              "BooleanOnLeftSideForX_D"
            ],
            "controlFunctionString": "setBooleanOnLeftSideForX_D(BoundsLeftSideOfEquals.containsPoint( PositionForXTiles_D )); ",
            "dependencyNames": [
              "BoundsLeftSideOfEquals",
              "PositionForXTiles_D"
            ],
            "referenceComponentNames": []
          }
        ],
        "animationListeners": [],
        "bluetoothListeners": []
      },
      "customCodeContainer": {
        "onProgramAddedCode": "// Setting program data to the program for some sound design.\r\nphet.paperLand.setProgramData( paperNumber, 'term', 'x' );\r\n\r\n// Using addModelObserver lets us add the tiles/bounds programs in any order\r\nscratchpad.observerId = phet.paperLand.addModelObserver(\r\n  'tileData', // the bounds program will create this array when it is added\r\n  tileDataArray => {\r\n\r\n    // as soon as the array is available, add this tile to it\r\n    scratchpad.thisTileData = {\r\n      onLeftSideProperty: phet.paperLand.getModelComponent( 'BooleanOnLeftSideForX_D' ),\r\n      negativeProperty: phet.paperLand.getModelComponent( 'BooleanNegativeForX_D' ),\r\n      countProperty: phet.paperLand.getModelComponent( 'NumberXCoefficient_D' ),\r\n      term: 'x'\r\n    }\r\n    tileDataArray.push( scratchpad.thisTileData );\r\n  },\r\n  tileDataArray => {\r\n\r\n    // Remove this tile from the array when the array is being removed\r\n    const index = tileDataArray.indexOf( scratchpad.thisTileData );\r\n    if ( index > -1 ) {\r\n        tileDataArray.splice( index, 1 );\r\n        delete scratchpad.tileData;\r\n    }\r\n  }\r\n);",
        "onProgramRemovedCode": "// Removes the term data from the model\r\nphet.paperLand.removeProgramData( paperNumber, 'term' );\r\n\r\nconst tileData = phet.paperLand.getModelComponent( 'tileData' );\r\nif ( tileData ) {\r\n\r\n    // Remove the tile from the array\r\n    const index = tileData.indexOf( scratchpad.thisTileData );\r\n    if ( index > -1 ) {\r\n        tileData.splice( index, 1 );\r\n        delete scratchpad.tileData;        \r\n    }\r\n}\r\n\r\n// remove the model observer\r\nphet.paperLand.removeModelObserver( 'tileData', scratchpad.observerId );\r\ndelete scratchpad.observerId;",
        "onProgramChangedPositionCode": "",
        "onProgramMarkersAddedCode": "",
        "onProgramMarkersRemovedCode": "",
        "onProgramMarkersChangedPositionCode": "",
        "onProgramAdjacentCode": "\n// Get a reference to the model component and only update it if it exists.\nconst goodConnectionComponent = phet.paperLand.getModelComponent( 'BooleanGoodConnectionForX_D' );\nconst badConnectionComponent = phet.paperLand.getModelComponent( 'BooleanBadConnectionForX_D' );\n\n\nif ( goodConnectionComponent && badConnectionComponent ) {\n\n    // If this is the left or right whisker...\n    if ( direction === 'left' || direction === 'right' ) {\n\n        // These are the terms that this program is allowed to connect to.\n        const goodConnectionTerms = [ 'xSquared' ];\n       \n        // These are the terms that this program is NOT allowed to connect to.\n        const badConnectionTerms = [ 'ones' ];\n\n        // This connection is \"good\" if the other program has a term in the good list\n        goodConnectionComponent.value = goodConnectionTerms.includes(\n\n            // get the term from the other program\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\n        );\n        // This connection is \"bad\" if the other program has a term in the bad list\n        badConnectionComponent.value = badConnectionTerms.includes(\n\n            // get the term from the other program\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\n        );\n    }\n\n    phet.paperLand.console.log( direction );\n\n    // If this is the top or bottom whisker...\n    if ( direction === 'top' || direction === 'bottom' ) {\n        \n        // These are the terms that this program is allowed to connect to.\n        const goodConnectionTerms = [ 'ones' ];\n       \n        // These are the terms that this program is NOT allowed to connect to.\n        const badConnectionTerms = [ 'xSquared' ];\n\n        // This connection is \"good\" if the other program has a term in the good list\n        goodConnectionComponent.value = goodConnectionTerms.includes(\n\n            // get the term from the other program\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\n        );\n        // This connection is \"bad\" if the other program has a term in the bad list\n        badConnectionComponent.value = badConnectionTerms.includes(\n\n            // get the term from the other program\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\n        );\n    }\n}",
        "onProgramSeparatedCode": "\r\n// Get a reference to the model component and only update it if it exists.\r\nconst goodConnectionComponent = phet.paperLand.getModelComponent( 'BooleanGoodConnectionForX_D' );\r\nconst badConnectionComponent = phet.paperLand.getModelComponent( 'BooleanBadConnectionForX_D' );\r\n\r\n// Components must exit check\r\nif ( goodConnectionComponent && badConnectionComponent )  {\r\n\r\n    // If this is the left or right whisker...\r\n    if ( direction === 'left' || direction === 'right' ) {\r\n\r\n        // These are the terms that this program is allowed to connect to.\r\n        const goodConnectionTerms = [ 'xSquared' ];\r\n\r\n         // These are the terms that this program is NOT allowed to connect to.\r\n        const badConnectionTerms = [ 'ones' ];\r\n\r\n        // If detatching from another program where connection is \"good\",\r\n        // the connection is no longer there.\r\n        if ( goodConnectionTerms.includes(\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        ) ) {\r\n            goodConnectionComponent.value = false;\r\n        }\r\n        // If detatching from another program where connection is \"bad\",\r\n        // the connection is no longer there.\r\n        if ( badConnectionTerms.includes(\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        ) ) {\r\n            badConnectionComponent.value = false;\r\n        }\r\n    }\r\n\r\n    // If this is the top or bottom whisker...\r\n    if ( direction === 'top' || direction === 'bottom' ) {\r\n\r\n       // These are the terms that this program is allowed to connect to.\r\n       // TODO: Need to add top and bottom of X tiles\r\n        const goodConnectionTerms = [ 'ones' ];\r\n\r\n         // These are the terms that this program is NOT allowed to connect to.\r\n        // TODO: Need to add left and right of X tiles\r\n        const badConnectionTerms = [ 'xSquared' ];\r\n\r\n        // If detatching from another program where connection is \"good\",\r\n        // the connection is no longer there.\r\n        if ( goodConnectionTerms.includes(\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        ) ) {\r\n            goodConnectionComponent.value = false;\r\n        }\r\n        // If detatching from another program where connection is \"bad\",\r\n        // the connection is no longer there.\r\n        if ( badConnectionTerms.includes(\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        ) ) {\r\n            badConnectionComponent.value = false;\r\n        }\r\n    }\r\n}"
      }
    },
    {
      "number": 470,
      "title": "X Tiles E",
      "keywords": "NumberXCoefficient",
      "description": "A program that voices the number of x-tiles (the coefficient of x) and increments and decrements the coefficient using markers.  Note that current model range for the coefficient is 0-9, voicing strings range from x to 10x.",
      "expanded": false,
      "topWhiskerLength": 0.05,
      "rightWhiskerLength": 0.05,
      "bottomWhiskerLength": 0.05,
      "leftWhiskerLength": 0.05,
      "positionProperty": {
        "x": 479.9000549316406,
        "y": 421
      },
      "modelContainer": {
        "namedBooleanProperties": [
          {
            "name": "BooleanOnLeftSideForX_E",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          },
          {
            "name": "BooleanNegativeForX_E",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          },
          {
            "name": "BooleanGoodConnectionForX_E",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          },
          {
            "name": "BooleanBadConnectionForX_E",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          }
        ],
        "namedVector2Properties": [
          {
            "name": "PositionForXTiles_E",
            "propertyType": "Vector2Property",
            "defaultX": 0,
            "defaultY": 0
          }
        ],
        "namedNumberProperties": [
          {
            "name": "NumberXCoefficient_E",
            "propertyType": "NumberProperty",
            "min": 0,
            "max": "9",
            "defaultValue": "0"
          }
        ],
        "namedEnumerationProperties": [],
        "namedDerivedProperties": [],
        "namedBounds2Properties": [],
        "namedObservableArrays": [],
        "namedArrayItems": [],
        "namedArrayItemReferences": [],
        "namedStringProperties": []
      },
      "controllerContainer": {
        "vector2PropertyControllers": [
          {
            "name": "ControllerPositionForX_E",
            "controlledComponentName": "PositionForXTiles_E",
            "controlType": "MATCH_CENTER",
            "controlTypeFamily": ""
          }
        ],
        "boundsPropertyControllers": [],
        "booleanPropertyControllers": [
          {
            "name": "ControllerBooleanNegativeForX_E",
            "controlledComponentName": "BooleanNegativeForX_E",
            "controlType": "ROTATION",
            "controlTypeFamily": "",
            "whiskerConfiguration": {
              "topLength": 0.2,
              "rightLength": 0.2,
              "bottomLength": 0.2,
              "leftLength": 0.2,
              "otherPaperNumber": null
            },
            "markerColor": ""
          }
        ],
        "numberPropertyControllers": [
          {
            "name": "ControllerXCoefficient_E",
            "controlledComponentName": "NumberXCoefficient_E",
            "controlType": "MARKER_COUNT",
            "controlTypeFamily": "MARKERS",
            "markerColor": "all",
            "relationshipControlType": null
          }
        ],
        "enumerationPropertyControllers": []
      },
      "viewContainer": {
        "soundViews": [
          {
            "name": "ViewGoodConnectionSoundForX_E",
            "modelComponentNames": [
              "RectangleModelMode",
              "BooleanGoodConnectionForX_E"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "if ( BooleanGoodConnectionForX_E && RectangleModelMode ) {\r\n    play();\r\n}",
            "lazyLink": false,
            "soundFileName": "/uploads/SuccessSound.mp3",
            "loop": false,
            "autoplay": false
          },
          {
            "name": "ViewBadConnectionSoundForX_E",
            "modelComponentNames": [
              "RectangleModelMode",
              "BooleanBadConnectionForX_E"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "if ( BooleanBadConnectionForX_E && RectangleModelMode ) {\n    play();\n}",
            "lazyLink": false,
            "soundFileName": "/uploads/OutOfBalanceSound.mp3",
            "loop": false,
            "autoplay": false
          }
        ],
        "speechViews": [
          {
            "name": "ViewNumberOfX_E",
            "modelComponentNames": [
              "BooleanNegativeForX_E",
              "NumberXCoefficient_E"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "  // A paper with no markers represents a 1x tile or a -1x tile \n  // and not 0x. We need to add or minus 1, and \n  // for the case of 1x not voice the coefficient. \n  // I think it is ok to voice -1x rather than -x.\nif (Math.floor(NumberXCoefficient_E) === 0) {\n    if (BooleanNegativeForX_E) {\n        speak( 'minus x' );\n    }\n    else {\n        speak( 'x' );\n    }\n} else {\n    if (BooleanNegativeForX_E) {\n        speak( -Math.floor(NumberXCoefficient_E) - 1 + 'x' );\n    }\n    else {\n        speak( Math.floor(NumberXCoefficient_E) + 1 + 'x' );\n    }\n}",
            "lazyLink": false
          }
        ],
        "textViews": [
          {
            "name": "ViewTextTilesForXTiles_E",
            "modelComponentNames": [
              "BooleanNegativeForX_E",
              "PositionForXTiles_E",
              "NumberXCoefficient_E"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "if (Math.floor(NumberXCoefficient_E) === 0) {\n    if (BooleanNegativeForX_E) {\n        setString('] ' + '-x [');\n    }\n    else {\n        setString('[ ' + 'x ]');\n    }\n} \nelse {\n    if (BooleanNegativeForX_E) {\n        setString('] ' + (-NumberXCoefficient_E - 1) + 'x [');\n    }\n    else {\n        setString('[ ' + (NumberXCoefficient_E + 1) + 'x ]');\n    }\n}\nsetFontSize(20);\nsetCenterX( phet.paperLand.utils.paperToBoardX( PositionForXTiles_E.x, sharedData.displaySize.width ))\nsetCenterY( phet.paperLand.utils.paperToBoardY( PositionForXTiles_E.y, sharedData.displaySize.height ))\nphet.paperLand.console.log( phet.paperLand.utils.paperToBoardX( PositionForXTiles_E.x, sharedData.displaySize.width ));",
            "lazyLink": false,
            "defaultViewOptions": {
              "centerX": 0.5,
              "centerY": 0.5,
              "scale": 1,
              "rotation": 0,
              "opacity": 1,
              "visible": true,
              "viewUnits": "model"
            }
          }
        ],
        "shapeViews": [],
        "backgroundViews": [],
        "imageViews": []
      },
      "listenerContainer": {
        "linkListeners": [
          {
            "name": "ControllerBooleanLeftSideForX_E",
            "controlledPropertyNames": [
              "BooleanOnLeftSideForX_E"
            ],
            "controlFunctionString": "setBooleanOnLeftSideForX_E(BoundsLeftSideOfEquals.containsPoint( PositionForXTiles_E )); ",
            "dependencyNames": [
              "BoundsLeftSideOfEquals",
              "PositionForXTiles_E"
            ],
            "referenceComponentNames": []
          }
        ],
        "animationListeners": [],
        "bluetoothListeners": []
      },
      "customCodeContainer": {
        "onProgramAddedCode": "// Setting program data to the program for some sound design.\r\nphet.paperLand.setProgramData( paperNumber, 'term', 'x' );\r\n\r\n// Using addModelObserver lets us add the tiles/bounds programs in any order\r\nscratchpad.observerId = phet.paperLand.addModelObserver(\r\n  'tileData', // the bounds program will create this array when it is added\r\n  tileDataArray => {\r\n\r\n    // as soon as the array is available, add this tile to it\r\n    scratchpad.thisTileData = {\r\n      onLeftSideProperty: phet.paperLand.getModelComponent( 'BooleanOnLeftSideForX_E' ),\r\n      negativeProperty: phet.paperLand.getModelComponent( 'BooleanNegativeForX_E' ),\r\n      countProperty: phet.paperLand.getModelComponent( 'NumberXCoefficient_E' ),\r\n      term: 'x'\r\n    }\r\n    tileDataArray.push( scratchpad.thisTileData );\r\n  },\r\n  tileDataArray => {\r\n\r\n    // Remove this tile from the array when the array is being removed\r\n    const index = tileDataArray.indexOf( scratchpad.thisTileData );\r\n    if ( index > -1 ) {\r\n        tileDataArray.splice( index, 1 );\r\n        delete scratchpad.tileData;\r\n    }\r\n  }\r\n);",
        "onProgramRemovedCode": "// Removes the term data from the model\r\nphet.paperLand.removeProgramData( paperNumber, 'term' );\r\n\r\nconst tileData = phet.paperLand.getModelComponent( 'tileData' );\r\nif ( tileData ) {\r\n\r\n    // Remove the tile from the array\r\n    const index = tileData.indexOf( scratchpad.thisTileData );\r\n    if ( index > -1 ) {\r\n        tileData.splice( index, 1 );\r\n        delete scratchpad.tileData;        \r\n    }\r\n}\r\n\r\n// remove the model observer\r\nphet.paperLand.removeModelObserver( 'tileData', scratchpad.observerId );\r\ndelete scratchpad.observerId;",
        "onProgramChangedPositionCode": "",
        "onProgramMarkersAddedCode": "",
        "onProgramMarkersRemovedCode": "",
        "onProgramMarkersChangedPositionCode": "",
        "onProgramAdjacentCode": "\n// Get a reference to the model component and only update it if it exists.\nconst goodConnectionComponent = phet.paperLand.getModelComponent( 'BooleanGoodConnectionForX_E' );\nconst badConnectionComponent = phet.paperLand.getModelComponent( 'BooleanBadConnectionForX_E' );\n\n\nif ( goodConnectionComponent && badConnectionComponent ) {\n\n    // If this is the left or right whisker...\n    if ( direction === 'left' || direction === 'right' ) {\n\n        // These are the terms that this program is allowed to connect to.\n        const goodConnectionTerms = [ 'xSquared' ];\n       \n        // These are the terms that this program is NOT allowed to connect to.\n        const badConnectionTerms = [ 'ones' ];\n\n        // This connection is \"good\" if the other program has a term in the good list\n        goodConnectionComponent.value = goodConnectionTerms.includes(\n\n            // get the term from the other program\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\n        );\n        // This connection is \"bad\" if the other program has a term in the bad list\n        badConnectionComponent.value = badConnectionTerms.includes(\n\n            // get the term from the other program\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\n        );\n    }\n\n    phet.paperLand.console.log( direction );\n\n    // If this is the top or bottom whisker...\n    if ( direction === 'top' || direction === 'bottom' ) {\n        \n        // These are the terms that this program is allowed to connect to.\n        const goodConnectionTerms = [ 'ones' ];\n       \n        // These are the terms that this program is NOT allowed to connect to.\n        const badConnectionTerms = [ 'xSquared' ];\n\n        // This connection is \"good\" if the other program has a term in the good list\n        goodConnectionComponent.value = goodConnectionTerms.includes(\n\n            // get the term from the other program\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\n        );\n        // This connection is \"bad\" if the other program has a term in the bad list\n        badConnectionComponent.value = badConnectionTerms.includes(\n\n            // get the term from the other program\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\n        );\n    }\n}",
        "onProgramSeparatedCode": "\r\n// Get a reference to the model component and only update it if it exists.\r\nconst goodConnectionComponent = phet.paperLand.getModelComponent( 'BooleanGoodConnectionForX_E' );\r\nconst badConnectionComponent = phet.paperLand.getModelComponent( 'BooleanBadConnectionForX_E' );\r\n\r\n// Components must exit check\r\nif ( goodConnectionComponent && badConnectionComponent )  {\r\n\r\n    // If this is the left or right whisker...\r\n    if ( direction === 'left' || direction === 'right' ) {\r\n\r\n        // These are the terms that this program is allowed to connect to.\r\n        const goodConnectionTerms = [ 'xSquared' ];\r\n\r\n         // These are the terms that this program is NOT allowed to connect to.\r\n        const badConnectionTerms = [ 'ones' ];\r\n\r\n        // If detatching from another program where connection is \"good\",\r\n        // the connection is no longer there.\r\n        if ( goodConnectionTerms.includes(\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        ) ) {\r\n            goodConnectionComponent.value = false;\r\n        }\r\n        // If detatching from another program where connection is \"bad\",\r\n        // the connection is no longer there.\r\n        if ( badConnectionTerms.includes(\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        ) ) {\r\n            badConnectionComponent.value = false;\r\n        }\r\n    }\r\n\r\n    // If this is the top or bottom whisker...\r\n    if ( direction === 'top' || direction === 'bottom' ) {\r\n\r\n       // These are the terms that this program is allowed to connect to.\r\n       // TODO: Need to add top and bottom of X tiles\r\n        const goodConnectionTerms = [ 'ones' ];\r\n\r\n         // These are the terms that this program is NOT allowed to connect to.\r\n        // TODO: Need to add left and right of X tiles\r\n        const badConnectionTerms = [ 'xSquared' ];\r\n\r\n        // If detatching from another program where connection is \"good\",\r\n        // the connection is no longer there.\r\n        if ( goodConnectionTerms.includes(\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        ) ) {\r\n            goodConnectionComponent.value = false;\r\n        }\r\n        // If detatching from another program where connection is \"bad\",\r\n        // the connection is no longer there.\r\n        if ( badConnectionTerms.includes(\r\n            phet.paperLand.getProgramData( otherPaperNumber, 'term' )\r\n        ) ) {\r\n            badConnectionComponent.value = false;\r\n        }\r\n    }\r\n}"
      }
    },
    {
      "number": 1153,
      "title": "x Squared Tiles B",
      "keywords": "TacTiles, algebra, voicing, x^2, x, squared, x-squared",
      "description": "A program that voices the number of x-squared tiles (the coefficient of x-squared) and increments and decrements the coefficient using markers.  Note that current model range is 0-9, voicing strings range from x squared to 10x^2.",
      "expanded": false,
      "topWhiskerLength": 0.05,
      "rightWhiskerLength": 0.05,
      "bottomWhiskerLength": 0.05,
      "leftWhiskerLength": 0.05,
      "positionProperty": {
        "x": 413.1999816894531,
        "y": 402.49051609474304
      },
      "modelContainer": {
        "namedBooleanProperties": [
          {
            "name": "BooleanOnLeftSideForXSquared_B",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          },
          {
            "name": "BooleanNegativeForXSquared_B",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          }
        ],
        "namedVector2Properties": [
          {
            "name": "PositionForXSquaredTiles_B",
            "propertyType": "Vector2Property",
            "defaultX": 0,
            "defaultY": 0
          }
        ],
        "namedNumberProperties": [
          {
            "name": "NumberXSquaredCoefficient_B",
            "propertyType": "NumberProperty",
            "min": "0",
            "max": "9",
            "defaultValue": "0"
          }
        ],
        "namedEnumerationProperties": [],
        "namedDerivedProperties": [],
        "namedBounds2Properties": [],
        "namedObservableArrays": [],
        "namedArrayItems": [],
        "namedArrayItemReferences": [],
        "namedStringProperties": []
      },
      "controllerContainer": {
        "vector2PropertyControllers": [
          {
            "name": "ControllerPositionForXSquared_B",
            "controlledComponentName": "PositionForXSquaredTiles_B",
            "controlType": "MATCH_CENTER",
            "controlTypeFamily": ""
          }
        ],
        "boundsPropertyControllers": [],
        "booleanPropertyControllers": [
          {
            "name": "ControllerBooleanNegativeForXSquared_B",
            "controlledComponentName": "BooleanNegativeForXSquared_B",
            "controlType": "ROTATION",
            "controlTypeFamily": "",
            "whiskerConfiguration": {
              "topLength": 0.2,
              "rightLength": 0.2,
              "bottomLength": 0.2,
              "leftLength": 0.2,
              "otherPaperNumber": null
            },
            "markerColor": ""
          }
        ],
        "numberPropertyControllers": [
          {
            "name": "ControllerXSquareCoefficient_B",
            "controlledComponentName": "NumberXSquaredCoefficient_B",
            "controlType": "MARKER_COUNT",
            "controlTypeFamily": "MARKERS",
            "markerColor": "all",
            "relationshipControlType": null
          }
        ],
        "enumerationPropertyControllers": []
      },
      "viewContainer": {
        "soundViews": [],
        "speechViews": [
          {
            "name": "ViewNumberOfXSquared_B",
            "modelComponentNames": [
              "BooleanNegativeForXSquared_B",
              "NumberXSquaredCoefficient_B"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "phet.paperLand.console.log(NumberXSquaredCoefficient_B);\nif (Math.floor(NumberXSquaredCoefficient_B) === 0) {\n // A paper with no markers represents 1x^2 or -1x^2 and \n // in the case of 1x^2 the coefficient does not need to be voiced.\nif (BooleanNegativeForXSquared_B) {\n        speak( 'minus x squared' );\n    }\n    else {\n        speak( 'x squared' );\n    }\n} else {\n    if (BooleanNegativeForXSquared_B) {\n        speak( -Math.floor(NumberXSquaredCoefficient_B) - 1 + 'x squared' );\n    }\n    else {\n        speak( Math.floor(NumberXSquaredCoefficient_B) + 1 + 'x squared' );\n    }\n}",
            "lazyLink": false
          }
        ],
        "textViews": [
          {
            "name": "ViewTextTilesForXSquared_B",
            "modelComponentNames": [
              "BooleanNegativeForXSquared_B",
              "PositionForXSquaredTiles_B",
              "NumberXSquaredCoefficient_B"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "//\n//if (BooleanNegativeForXSquared_B) {\n//    setString('] ' + (-NumberXSquaredCoefficient_B - 1) + 'x^2 [');\n //   }\n //   else {\n//        setString('[ ' + (NumberXSquaredCoefficient_B + 1) + 'x^2 ]');\n //   }\n if (Math.floor(NumberXSquaredCoefficient_B) === 0) {\n    if (BooleanNegativeForXSquared_B) {\n        setString('] ' + '-x^2 [');\n    }\n    else {\n        setString('[ ' + 'x^2  ]');\n    }\n} \nelse {\n    if (BooleanNegativeForXSquared_B) {\n        setString('] ' + (-NumberXSquaredCoefficient_B - 1) + 'x^2 [');\n    }\n    else {\n        setString('[ ' + (NumberXSquaredCoefficient_B + 1) + 'x^2 ]');\n    }\n}\nsetFontSize(20);\nsetCenterX( phet.paperLand.utils.paperToBoardX( PositionForXSquaredTiles_B.x, sharedData.displaySize.width ))\nsetCenterY( phet.paperLand.utils.paperToBoardY( PositionForXSquaredTiles_B.y, sharedData.displaySize.height ))\nphet.paperLand.console.log( phet.paperLand.utils.paperToBoardX( PositionForXSquaredTiles_B.x, sharedData.displaySize.width ));",
            "lazyLink": false,
            "defaultViewOptions": {
              "centerX": 0.5,
              "centerY": 0.5,
              "scale": 1,
              "rotation": 0,
              "opacity": 1,
              "visible": true,
              "viewUnits": "model"
            }
          }
        ],
        "shapeViews": [],
        "backgroundViews": [],
        "imageViews": []
      },
      "listenerContainer": {
        "linkListeners": [
          {
            "name": "ControllerBooleanLeftSideForXSquared_B",
            "controlledPropertyNames": [
              "BooleanOnLeftSideForXSquared_B"
            ],
            "controlFunctionString": "setBooleanOnLeftSideForXSquared_B(BoundsLeftSideOfEquals.containsPoint( PositionForXSquaredTiles_B )); ",
            "dependencyNames": [
              "BoundsLeftSideOfEquals",
              "PositionForXSquaredTiles_B"
            ],
            "referenceComponentNames": []
          }
        ],
        "animationListeners": [],
        "bluetoothListeners": []
      },
      "customCodeContainer": {
        "onProgramAddedCode": "// Setting program data to the program for some sound design.\r\nphet.paperLand.setProgramData( paperNumber, 'term', 'xSquared' );\r\n\r\n// Using addModelObserver lets us add the tiles/bounds programs in any order\r\nscratchpad.observerId = phet.paperLand.addModelObserver(\r\n  'tileData', // the bounds program will create this array when it is added\r\n  tileDataArray => {\r\n\r\n    // as soon as the array is available, add this tile to it\r\n    scratchpad.thisTileData = {\r\n      onLeftSideProperty: phet.paperLand.getModelComponent( 'BooleanOnLeftSideForXSquared_B' ),\r\n      negativeProperty: phet.paperLand.getModelComponent( 'BooleanNegativeForXSquared_B' ),\r\n      countProperty: phet.paperLand.getModelComponent( 'NumberXSquaredCoefficient_B' ),\r\n      term: 'xSquared'\r\n    }\r\n    tileDataArray.push( scratchpad.thisTileData );\r\n  },\r\n  tileDataArray => {\r\n\r\n    // Remove this tile from the array when the array is being removed\r\n    const index = tileDataArray.indexOf( scratchpad.thisTileData );\r\n    if ( index > -1 ) {\r\n        tileDataArray.splice( index, 1 );\r\n        delete scratchpad.tileData;\r\n    }\r\n  }\r\n);",
        "onProgramRemovedCode": "// Removes the term data from the model\r\nphet.paperLand.removeProgramData( paperNumber, 'term' );\r\n\r\nconst tileData = phet.paperLand.getModelComponent( 'tileData' );\r\nif ( tileData ) {\r\n\r\n    // Remove the tile from the array\r\n    const index = tileData.indexOf( scratchpad.thisTileData );\r\n    if ( index > -1 ) {\r\n        tileData.splice( index, 1 );\r\n        delete scratchpad.tileData;        \r\n    }\r\n}\r\n\r\n// remove the model observer\r\nphet.paperLand.removeModelObserver( 'tileData', scratchpad.observerId );\r\ndelete scratchpad.observerId;",
        "onProgramChangedPositionCode": "",
        "onProgramMarkersAddedCode": "",
        "onProgramMarkersRemovedCode": "",
        "onProgramMarkersChangedPositionCode": "",
        "onProgramAdjacentCode": "",
        "onProgramSeparatedCode": ""
      }
    },
    {
      "number": 351,
      "title": "x Squared Tiles C",
      "keywords": "TacTiles, algebra, voicing, x^2, x, squared, x-squared",
      "description": "A program that voices the number of x-squared tiles (the coefficient of x-squared) and increments and decrements the coefficient using markers.  Note that current model range is 0-9, voicing strings range from x squared to 10x^2.",
      "expanded": false,
      "topWhiskerLength": 0.05,
      "rightWhiskerLength": 0.05,
      "bottomWhiskerLength": 0.05,
      "leftWhiskerLength": 0.05,
      "positionProperty": {
        "x": 357,
        "y": 366.9530511899579
      },
      "modelContainer": {
        "namedBooleanProperties": [
          {
            "name": "BooleanOnLeftSideForXSquared_C",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          },
          {
            "name": "BooleanNegativeForXSquared_C",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          }
        ],
        "namedVector2Properties": [
          {
            "name": "PositionForXSquaredTiles_C",
            "propertyType": "Vector2Property",
            "defaultX": 0,
            "defaultY": 0
          }
        ],
        "namedNumberProperties": [
          {
            "name": "NumberXSquaredCoefficient_C",
            "propertyType": "NumberProperty",
            "min": "0",
            "max": "9",
            "defaultValue": "0"
          }
        ],
        "namedEnumerationProperties": [],
        "namedDerivedProperties": [],
        "namedBounds2Properties": [],
        "namedObservableArrays": [],
        "namedArrayItems": [],
        "namedArrayItemReferences": [],
        "namedStringProperties": []
      },
      "controllerContainer": {
        "vector2PropertyControllers": [
          {
            "name": "ControllerPositionForXSquared_C",
            "controlledComponentName": "PositionForXSquaredTiles_C",
            "controlType": "MATCH_CENTER",
            "controlTypeFamily": ""
          }
        ],
        "boundsPropertyControllers": [],
        "booleanPropertyControllers": [
          {
            "name": "ControllerBooleanNegativeForXSquared_C",
            "controlledComponentName": "BooleanNegativeForXSquared_C",
            "controlType": "ROTATION",
            "controlTypeFamily": "",
            "whiskerConfiguration": {
              "topLength": 0.2,
              "rightLength": 0.2,
              "bottomLength": 0.2,
              "leftLength": 0.2,
              "otherPaperNumber": null
            },
            "markerColor": ""
          }
        ],
        "numberPropertyControllers": [
          {
            "name": "ControllerXSquareCoefficient_C",
            "controlledComponentName": "NumberXSquaredCoefficient_C",
            "controlType": "MARKER_COUNT",
            "controlTypeFamily": "MARKERS",
            "markerColor": "all",
            "relationshipControlType": null
          }
        ],
        "enumerationPropertyControllers": []
      },
      "viewContainer": {
        "soundViews": [],
        "speechViews": [
          {
            "name": "ViewNumberOfXSquared_C",
            "modelComponentNames": [
              "BooleanNegativeForXSquared_C",
              "NumberXSquaredCoefficient_C"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "phet.paperLand.console.log(NumberXSquaredCoefficient_C);\nif (Math.floor(NumberXSquaredCoefficient_C) === 0) {\n // A paper with no markers represents 1x^2 or -1x^2 and \n // in the case of 1x^2 the coefficient does not need to be voiced.\nif (BooleanNegativeForXSquared_C) {\n        speak( 'minus x squared' );\n    }\n    else {\n        speak( 'x squared' );\n    }\n} else {\n    if (BooleanNegativeForXSquared_C) {\n        speak( -Math.floor(NumberXSquaredCoefficient_C) - 1 + 'x squared' );\n    }\n    else {\n        speak( Math.floor(NumberXSquaredCoefficient_C) + 1 + 'x squared' );\n    }\n}",
            "lazyLink": false
          }
        ],
        "textViews": [
          {
            "name": "ViewTextTilesForXSquared_C",
            "modelComponentNames": [
              "BooleanNegativeForXSquared_C",
              "PositionForXSquaredTiles_C",
              "NumberXSquaredCoefficient_C"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "//\n//if (BooleanNegativeForXSquared_C) {\n//    setString('] ' + (-NumberXSquaredCoefficient_C - 1) + 'x^2 [');\n //   }\n //   else {\n//        setString('[ ' + (NumberXSquaredCoefficient_C + 1) + 'x^2 ]');\n //   }\n if (Math.floor(NumberXSquaredCoefficient_C) === 0) {\n    if (BooleanNegativeForXSquared_C) {\n        setString('] ' + '-x^2 [');\n    }\n    else {\n        setString('[ ' + 'x^2  ]');\n    }\n} \nelse {\n    if (BooleanNegativeForXSquared_C) {\n        setString('] ' + (-NumberXSquaredCoefficient_C - 1) + 'x^2 [');\n    }\n    else {\n        setString('[ ' + (NumberXSquaredCoefficient_C + 1) + 'x^2 ]');\n    }\n}\nsetFontSize(20);\nsetCenterX( phet.paperLand.utils.paperToBoardX( PositionForXSquaredTiles_C.x, sharedData.displaySize.width ))\nsetCenterY( phet.paperLand.utils.paperToBoardY( PositionForXSquaredTiles_C.y, sharedData.displaySize.height ))\nphet.paperLand.console.log( phet.paperLand.utils.paperToBoardX( PositionForXSquaredTiles_C.x, sharedData.displaySize.width ));",
            "lazyLink": false,
            "defaultViewOptions": {
              "centerX": 0.5,
              "centerY": 0.5,
              "scale": 1,
              "rotation": 0,
              "opacity": 1,
              "visible": true,
              "viewUnits": "model"
            }
          }
        ],
        "shapeViews": [],
        "backgroundViews": [],
        "imageViews": []
      },
      "listenerContainer": {
        "linkListeners": [
          {
            "name": "ControllerBooleanLeftSideForXSquared_C",
            "controlledPropertyNames": [
              "BooleanOnLeftSideForXSquared_C"
            ],
            "controlFunctionString": "setBooleanOnLeftSideForXSquared_C(BoundsLeftSideOfEquals.containsPoint( PositionForXSquaredTiles_C )); ",
            "dependencyNames": [
              "BoundsLeftSideOfEquals",
              "PositionForXSquaredTiles_C"
            ],
            "referenceComponentNames": []
          }
        ],
        "animationListeners": [],
        "bluetoothListeners": []
      },
      "customCodeContainer": {
        "onProgramAddedCode": "// Setting program data to the program for some sound design.\r\nphet.paperLand.setProgramData( paperNumber, 'term', 'xSquared' );\r\n\r\n// Using addModelObserver lets us add the tiles/bounds programs in any order\r\nscratchpad.observerId = phet.paperLand.addModelObserver(\r\n  'tileData', // the bounds program will create this array when it is added\r\n  tileDataArray => {\r\n\r\n    // as soon as the array is available, add this tile to it\r\n    scratchpad.thisTileData = {\r\n      onLeftSideProperty: phet.paperLand.getModelComponent( 'BooleanOnLeftSideForXSquared_C' ),\r\n      negativeProperty: phet.paperLand.getModelComponent( 'BooleanNegativeForXSquared_C' ),\r\n      countProperty: phet.paperLand.getModelComponent( 'NumberXSquaredCoefficient_C' ),\r\n      term: 'xSquared'\r\n    }\r\n    tileDataArray.push( scratchpad.thisTileData );\r\n  },\r\n  tileDataArray => {\r\n\r\n    // Remove this tile from the array when the array is being removed\r\n    const index = tileDataArray.indexOf( scratchpad.thisTileData );\r\n    if ( index > -1 ) {\r\n        tileDataArray.splice( index, 1 );\r\n        delete scratchpad.tileData;\r\n    }\r\n  }\r\n);",
        "onProgramRemovedCode": "// Removes the term data from the model\r\nphet.paperLand.removeProgramData( paperNumber, 'term' );\r\n\r\nconst tileData = phet.paperLand.getModelComponent( 'tileData' );\r\nif ( tileData ) {\r\n\r\n    // Remove the tile from the array\r\n    const index = tileData.indexOf( scratchpad.thisTileData );\r\n    if ( index > -1 ) {\r\n        tileData.splice( index, 1 );\r\n        delete scratchpad.tileData;        \r\n    }\r\n}\r\n\r\n// remove the model observer\r\nphet.paperLand.removeModelObserver( 'tileData', scratchpad.observerId );\r\ndelete scratchpad.observerId;",
        "onProgramChangedPositionCode": "",
        "onProgramMarkersAddedCode": "",
        "onProgramMarkersRemovedCode": "",
        "onProgramMarkersChangedPositionCode": "",
        "onProgramAdjacentCode": "",
        "onProgramSeparatedCode": ""
      }
    },
    {
      "number": 1014,
      "title": "x Squared Tiles D",
      "keywords": "TacTiles, algebra, voicing, x^2, x, squared, x-squared",
      "description": "A program that voices the number of x-squared tiles (the coefficient of x-squared) and increments and decrements the coefficient using markers.  Note that current model range is 0-9, voicing strings range from x squared to 10x^2.",
      "expanded": false,
      "topWhiskerLength": 0.05,
      "rightWhiskerLength": 0.05,
      "bottomWhiskerLength": 0.05,
      "leftWhiskerLength": 0.05,
      "positionProperty": {
        "x": 408.7000427246094,
        "y": 354.3499292417157
      },
      "modelContainer": {
        "namedBooleanProperties": [
          {
            "name": "BooleanOnLeftSideForXSquared_D",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          },
          {
            "name": "BooleanNegativeForXSquared_D",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          }
        ],
        "namedVector2Properties": [
          {
            "name": "PositionForXSquaredTiles_D",
            "propertyType": "Vector2Property",
            "defaultX": 0,
            "defaultY": 0
          }
        ],
        "namedNumberProperties": [
          {
            "name": "NumberXSquaredCoefficient_D",
            "propertyType": "NumberProperty",
            "min": "0",
            "max": "9",
            "defaultValue": "0"
          }
        ],
        "namedEnumerationProperties": [],
        "namedDerivedProperties": [],
        "namedBounds2Properties": [],
        "namedObservableArrays": [],
        "namedArrayItems": [],
        "namedArrayItemReferences": [],
        "namedStringProperties": []
      },
      "controllerContainer": {
        "vector2PropertyControllers": [
          {
            "name": "ControllerPositionForXSquared_D",
            "controlledComponentName": "PositionForXSquaredTiles_D",
            "controlType": "MATCH_CENTER",
            "controlTypeFamily": ""
          }
        ],
        "boundsPropertyControllers": [],
        "booleanPropertyControllers": [
          {
            "name": "ControllerBooleanNegativeForXSquared_D",
            "controlledComponentName": "BooleanNegativeForXSquared_D",
            "controlType": "ROTATION",
            "controlTypeFamily": "",
            "whiskerConfiguration": {
              "topLength": 0.2,
              "rightLength": 0.2,
              "bottomLength": 0.2,
              "leftLength": 0.2,
              "otherPaperNumber": null
            },
            "markerColor": ""
          }
        ],
        "numberPropertyControllers": [
          {
            "name": "ControllerXSquareCoefficient_D",
            "controlledComponentName": "NumberXSquaredCoefficient_D",
            "controlType": "MARKER_COUNT",
            "controlTypeFamily": "MARKERS",
            "markerColor": "all",
            "relationshipControlType": null
          }
        ],
        "enumerationPropertyControllers": []
      },
      "viewContainer": {
        "soundViews": [],
        "speechViews": [
          {
            "name": "ViewNumberOfXSquared_D",
            "modelComponentNames": [
              "BooleanNegativeForXSquared_D",
              "NumberXSquaredCoefficient_D"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "phet.paperLand.console.log(NumberXSquaredCoefficient_D);\nif (Math.floor(NumberXSquaredCoefficient_D) === 0) {\n // A paper with no markers represents 1x^2 or -1x^2 and \n // in the case of 1x^2 the coefficient does not need to be voiced.\nif (BooleanNegativeForXSquared_D) {\n        speak( 'minus x squared' );\n    }\n    else {\n        speak( 'x squared' );\n    }\n} else {\n    if (BooleanNegativeForXSquared_D) {\n        speak( -Math.floor(NumberXSquaredCoefficient_D) - 1 + 'x squared' );\n    }\n    else {\n        speak( Math.floor(NumberXSquaredCoefficient_D) + 1 + 'x squared' );\n    }\n}",
            "lazyLink": false
          }
        ],
        "textViews": [
          {
            "name": "ViewTextTilesForXSquared_D",
            "modelComponentNames": [
              "BooleanNegativeForXSquared_D",
              "PositionForXSquaredTiles_D",
              "NumberXSquaredCoefficient_D"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "//\n//if (BooleanNegativeForXSquared_D) {\n//    setString('] ' + (-NumberXSquaredCoefficient_D - 1) + 'x^2 [');\n //   }\n //   else {\n//        setString('[ ' + (NumberXSquaredCoefficient_D + 1) + 'x^2 ]');\n //   }\n if (Math.floor(NumberXSquaredCoefficient_D) === 0) {\n    if (BooleanNegativeForXSquared_D) {\n        setString('] ' + '-x^2 [');\n    }\n    else {\n        setString('[ ' + 'x^2  ]');\n    }\n} \nelse {\n    if (BooleanNegativeForXSquared_D) {\n        setString('] ' + (-NumberXSquaredCoefficient_D - 1) + 'x^2 [');\n    }\n    else {\n        setString('[ ' + (NumberXSquaredCoefficient_D + 1) + 'x^2 ]');\n    }\n}\nsetFontSize(20);\nsetCenterX( phet.paperLand.utils.paperToBoardX( PositionForXSquaredTiles_D.x, sharedData.displaySize.width ))\nsetCenterY( phet.paperLand.utils.paperToBoardY( PositionForXSquaredTiles_D.y, sharedData.displaySize.height ))\nphet.paperLand.console.log( phet.paperLand.utils.paperToBoardX( PositionForXSquaredTiles_D.x, sharedData.displaySize.width ));",
            "lazyLink": false,
            "defaultViewOptions": {
              "centerX": 0.5,
              "centerY": 0.5,
              "scale": 1,
              "rotation": 0,
              "opacity": 1,
              "visible": true,
              "viewUnits": "model"
            }
          }
        ],
        "shapeViews": [],
        "backgroundViews": [],
        "imageViews": []
      },
      "listenerContainer": {
        "linkListeners": [
          {
            "name": "ControllerBooleanLeftSideForXSquared_D",
            "controlledPropertyNames": [
              "BooleanOnLeftSideForXSquared_D"
            ],
            "controlFunctionString": "setBooleanOnLeftSideForXSquared_D(BoundsLeftSideOfEquals.containsPoint( PositionForXSquaredTiles_D )); ",
            "dependencyNames": [
              "BoundsLeftSideOfEquals",
              "PositionForXSquaredTiles_D"
            ],
            "referenceComponentNames": []
          }
        ],
        "animationListeners": [],
        "bluetoothListeners": []
      },
      "customCodeContainer": {
        "onProgramAddedCode": "// Setting program data to the program for some sound design.\r\nphet.paperLand.setProgramData( paperNumber, 'term', 'xSquared' );\r\n\r\n// Using addModelObserver lets us add the tiles/bounds programs in any order\r\nscratchpad.observerId = phet.paperLand.addModelObserver(\r\n  'tileData', // the bounds program will create this array when it is added\r\n  tileDataArray => {\r\n\r\n    // as soon as the array is available, add this tile to it\r\n    scratchpad.thisTileData = {\r\n      onLeftSideProperty: phet.paperLand.getModelComponent( 'BooleanOnLeftSideForXSquared_D' ),\r\n      negativeProperty: phet.paperLand.getModelComponent( 'BooleanNegativeForXSquared_D' ),\r\n      countProperty: phet.paperLand.getModelComponent( 'NumberXSquaredCoefficient_D' ),\r\n      term: 'xSquared'\r\n    }\r\n    tileDataArray.push( scratchpad.thisTileData );\r\n  },\r\n  tileDataArray => {\r\n\r\n    // Remove this tile from the array when the array is being removed\r\n    const index = tileDataArray.indexOf( scratchpad.thisTileData );\r\n    if ( index > -1 ) {\r\n        tileDataArray.splice( index, 1 );\r\n        delete scratchpad.tileData;\r\n    }\r\n  }\r\n);",
        "onProgramRemovedCode": "// Removes the term data from the model\r\nphet.paperLand.removeProgramData( paperNumber, 'term' );\r\n\r\nconst tileData = phet.paperLand.getModelComponent( 'tileData' );\r\nif ( tileData ) {\r\n\r\n    // Remove the tile from the array\r\n    const index = tileData.indexOf( scratchpad.thisTileData );\r\n    if ( index > -1 ) {\r\n        tileData.splice( index, 1 );\r\n        delete scratchpad.tileData;        \r\n    }\r\n}\r\n\r\n// remove the model observer\r\nphet.paperLand.removeModelObserver( 'tileData', scratchpad.observerId );\r\ndelete scratchpad.observerId;",
        "onProgramChangedPositionCode": "",
        "onProgramMarkersAddedCode": "",
        "onProgramMarkersRemovedCode": "",
        "onProgramMarkersChangedPositionCode": "",
        "onProgramAdjacentCode": "",
        "onProgramSeparatedCode": ""
      }
    },
    {
      "number": 1389,
      "title": "x Squared Tiles E",
      "keywords": "TacTiles, algebra, voicing, x^2, x, squared, x-squared",
      "description": "A program that voices the number of x-squared tiles (the coefficient of x-squared) and increments and decrements the coefficient using markers.  Note that current model range is 0-9, voicing strings range from x squared to 10x^2.",
      "expanded": false,
      "topWhiskerLength": 0.05,
      "rightWhiskerLength": 0.05,
      "bottomWhiskerLength": 0.05,
      "leftWhiskerLength": 0.05,
      "positionProperty": {
        "x": 385.3999938964844,
        "y": 366.3468042417157
      },
      "modelContainer": {
        "namedBooleanProperties": [
          {
            "name": "BooleanOnLeftSideForXSquared_E",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          },
          {
            "name": "BooleanNegativeForXSquared_E",
            "defaultValue": false,
            "propertyType": "BooleanProperty"
          }
        ],
        "namedVector2Properties": [
          {
            "name": "PositionForXSquaredTiles_E",
            "propertyType": "Vector2Property",
            "defaultX": 0,
            "defaultY": 0
          }
        ],
        "namedNumberProperties": [
          {
            "name": "NumberXSquaredCoefficient_E",
            "propertyType": "NumberProperty",
            "min": "0",
            "max": "9",
            "defaultValue": "0"
          }
        ],
        "namedEnumerationProperties": [],
        "namedDerivedProperties": [],
        "namedBounds2Properties": [],
        "namedObservableArrays": [],
        "namedArrayItems": [],
        "namedArrayItemReferences": [],
        "namedStringProperties": []
      },
      "controllerContainer": {
        "vector2PropertyControllers": [
          {
            "name": "ControllerPositionForXSquared_E",
            "controlledComponentName": "PositionForXSquaredTiles_E",
            "controlType": "MATCH_CENTER",
            "controlTypeFamily": ""
          }
        ],
        "boundsPropertyControllers": [],
        "booleanPropertyControllers": [
          {
            "name": "ControllerBooleanNegativeForXSquared_E",
            "controlledComponentName": "BooleanNegativeForXSquared_E",
            "controlType": "ROTATION",
            "controlTypeFamily": "",
            "whiskerConfiguration": {
              "topLength": 0.2,
              "rightLength": 0.2,
              "bottomLength": 0.2,
              "leftLength": 0.2,
              "otherPaperNumber": null
            },
            "markerColor": ""
          }
        ],
        "numberPropertyControllers": [
          {
            "name": "ControllerXSquareCoefficient_E",
            "controlledComponentName": "NumberXSquaredCoefficient_E",
            "controlType": "MARKER_COUNT",
            "controlTypeFamily": "MARKERS",
            "markerColor": "all",
            "relationshipControlType": null
          }
        ],
        "enumerationPropertyControllers": []
      },
      "viewContainer": {
        "soundViews": [],
        "speechViews": [
          {
            "name": "ViewNumberOfXSquared_E",
            "modelComponentNames": [
              "BooleanNegativeForXSquared_E",
              "NumberXSquaredCoefficient_E"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "phet.paperLand.console.log(NumberXSquaredCoefficient_E);\nif (Math.floor(NumberXSquaredCoefficient_E) === 0) {\n // A paper with no markers represents 1x^2 or -1x^2 and \n // in the case of 1x^2 the coefficient does not need to be voiced.\nif (BooleanNegativeForXSquared_E) {\n        speak( 'minus x squared' );\n    }\n    else {\n        speak( 'x squared' );\n    }\n} else {\n    if (BooleanNegativeForXSquared_E) {\n        speak( -Math.floor(NumberXSquaredCoefficient_E) - 1 + 'x squared' );\n    }\n    else {\n        speak( Math.floor(NumberXSquaredCoefficient_E) + 1 + 'x squared' );\n    }\n}",
            "lazyLink": false
          }
        ],
        "textViews": [
          {
            "name": "ViewTextTilesForXSquared_E",
            "modelComponentNames": [
              "BooleanNegativeForXSquared_E",
              "PositionForXSquaredTiles_E",
              "NumberXSquaredCoefficient_E"
            ],
            "referenceComponentNames": [],
            "controlFunctionString": "//\n//if (BooleanNegativeForXSquared_E) {\n//    setString('] ' + (-NumberXSquaredCoefficient_E - 1) + 'x^2 [');\n //   }\n //   else {\n//        setString('[ ' + (NumberXSquaredCoefficient_E + 1) + 'x^2 ]');\n //   }\n if (Math.floor(NumberXSquaredCoefficient_E) === 0) {\n    if (BooleanNegativeForXSquared_E) {\n        setString('] ' + '-x^2 [');\n    }\n    else {\n        setString('[ ' + 'x^2  ]');\n    }\n} \nelse {\n    if (BooleanNegativeForXSquared_E) {\n        setString('] ' + (-NumberXSquaredCoefficient_E - 1) + 'x^2 [');\n    }\n    else {\n        setString('[ ' + (NumberXSquaredCoefficient_E + 1) + 'x^2 ]');\n    }\n}\nsetFontSize(20);\nsetCenterX( phet.paperLand.utils.paperToBoardX( PositionForXSquaredTiles_E.x, sharedData.displaySize.width ))\nsetCenterY( phet.paperLand.utils.paperToBoardY( PositionForXSquaredTiles_E.y, sharedData.displaySize.height ))\nphet.paperLand.console.log( phet.paperLand.utils.paperToBoardX( PositionForXSquaredTiles_E.x, sharedData.displaySize.width ));",
            "lazyLink": false,
            "defaultViewOptions": {
              "centerX": 0.5,
              "centerY": 0.5,
              "scale": 1,
              "rotation": 0,
              "opacity": 1,
              "visible": true,
              "viewUnits": "model"
            }
          }
        ],
        "shapeViews": [],
        "backgroundViews": [],
        "imageViews": []
      },
      "listenerContainer": {
        "linkListeners": [
          {
            "name": "ControllerBooleanLeftSideForXSquared_E",
            "controlledPropertyNames": [
              "BooleanOnLeftSideForXSquared_E"
            ],
            "controlFunctionString": "setBooleanOnLeftSideForXSquared_E(BoundsLeftSideOfEquals.containsPoint( PositionForXSquaredTiles_E )); ",
            "dependencyNames": [
              "BoundsLeftSideOfEquals",
              "PositionForXSquaredTiles_E"
            ],
            "referenceComponentNames": []
          }
        ],
        "animationListeners": [],
        "bluetoothListeners": []
      },
      "customCodeContainer": {
        "onProgramAddedCode": "// Setting program data to the program for some sound design.\r\nphet.paperLand.setProgramData( paperNumber, 'term', 'xSquared' );\r\n\r\n// Using addModelObserver lets us add the tiles/bounds programs in any order\r\nscratchpad.observerId = phet.paperLand.addModelObserver(\r\n  'tileData', // the bounds program will create this array when it is added\r\n  tileDataArray => {\r\n\r\n    // as soon as the array is available, add this tile to it\r\n    scratchpad.thisTileData = {\r\n      onLeftSideProperty: phet.paperLand.getModelComponent( 'BooleanOnLeftSideForXSquared_E' ),\r\n      negativeProperty: phet.paperLand.getModelComponent( 'BooleanNegativeForXSquared_E' ),\r\n      countProperty: phet.paperLand.getModelComponent( 'NumberXSquaredCoefficient_E' ),\r\n      term: 'xSquared'\r\n    }\r\n    tileDataArray.push( scratchpad.thisTileData );\r\n  },\r\n  tileDataArray => {\r\n\r\n    // Remove this tile from the array when the array is being removed\r\n    const index = tileDataArray.indexOf( scratchpad.thisTileData );\r\n    if ( index > -1 ) {\r\n        tileDataArray.splice( index, 1 );\r\n        delete scratchpad.tileData;\r\n    }\r\n  }\r\n);",
        "onProgramRemovedCode": "// Removes the term data from the model\r\nphet.paperLand.removeProgramData( paperNumber, 'term' );\r\n\r\nconst tileData = phet.paperLand.getModelComponent( 'tileData' );\r\nif ( tileData ) {\r\n\r\n    // Remove the tile from the array\r\n    const index = tileData.indexOf( scratchpad.thisTileData );\r\n    if ( index > -1 ) {\r\n        tileData.splice( index, 1 );\r\n        delete scratchpad.tileData;        \r\n    }\r\n}\r\n\r\n// remove the model observer\r\nphet.paperLand.removeModelObserver( 'tileData', scratchpad.observerId );\r\ndelete scratchpad.observerId;",
        "onProgramChangedPositionCode": "",
        "onProgramMarkersAddedCode": "",
        "onProgramMarkersRemovedCode": "",
        "onProgramMarkersChangedPositionCode": "",
        "onProgramAdjacentCode": "",
        "onProgramSeparatedCode": ""
      }
    }
  ]
}