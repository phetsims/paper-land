{
  "number": 899,
  "originalCode": "// Multimodal Checkbox\n// Keywords: \n// Description: A sample checkbox with sound and voiced responses/ descriptions.\n// \n// Copy the template into your own project, edit the String Model Components to try out your own name, hint, and checkbox responses. The hint response is optional. To not hear it, just remove it from the View component called voiceResponsesForFocus.\n\nimportScripts('paper.js');\n\n(async () => {\n\n  const onProgramAdded = ( paperNumber, scratchpad, sharedData ) => {\n    \n      const isEnabled = new phet.axon.BooleanProperty(false);\n      phet.paperLand.addModelComponent( 'isEnabled', isEnabled );\n    \n\n      const isFocused = new phet.axon.BooleanProperty(false);\n      phet.paperLand.addModelComponent( 'isFocused', isFocused );\n    \n\n      const visualPosition = new phet.dot.Vector2Property(\n        new phet.dot.Vector2( 0.5, 0.5 )\n      );\n      phet.paperLand.addModelComponent( 'visualPosition', visualPosition );\n    \n\n      const fontSize = new phet.axon.NumberProperty( 24, {\n        range: new phet.dot.Range( 0, 48 )\n      });\n      phet.paperLand.addModelComponent( 'fontSize', fontSize );\n    \n\n      const checkboxNameResponse = new phet.axon.StringProperty( 'Force Values' );\n      phet.paperLand.addModelComponent( 'checkboxNameResponse', checkboxNameResponse );\n    \n\n      const checkedResponse = new phet.axon.StringProperty( 'Shown in newtons.' );\n      phet.paperLand.addModelComponent( 'checkedResponse', checkedResponse );\n    \n\n      const uncheckedResponse = new phet.axon.StringProperty( 'Hidden.' );\n      phet.paperLand.addModelComponent( 'uncheckedResponse', uncheckedResponse );\n    \n\n      const checkboxHintResponse = new phet.axon.StringProperty( 'Explore with or without newtons.' );\n      phet.paperLand.addModelComponent( 'checkboxHintResponse', checkboxHintResponse );\n    \n\n      const playCheckboxCheckedWrappedAudioBuffer = createAndLoadWrappedAudioBuffer( 'media/sounds/uploads/checkboxChecked.mp3' );\n      const playCheckboxCheckedSoundClip = new phet.tambo.SoundClip( playCheckboxCheckedWrappedAudioBuffer, {\n        loop: false,\n        initialOutputLevel: 0.5\n       } );\n      phet.tambo.soundManager.addSoundGenerator( playCheckboxCheckedSoundClip );\n      scratchpad.playCheckboxCheckedWrappedAudioBuffer = playCheckboxCheckedWrappedAudioBuffer;\n      \n      let playCheckboxCheckedStopSoundTimeout = null;\n      \n      // as a safety measure, sound can only be played every 0.25 seconds - initial value is very small\n      // so that it can be played immediately\n      let playCheckboxCheckedLastPlayTime = 0;\n      \n      // The listener that will observe the model and play sounds is added as soon as the sounds are loaded, and\n      // added to the scratch pad so that it can be removed later.\n      scratchpad.playCheckboxCheckedWrappedAudioBufferListener = _buffer => {\n        if ( _buffer ) {\n        \n          // Play the sound when any dependencies change value.\n          scratchpad.playCheckboxCheckedSoundMultilinkId = phet.paperLand.addModelPropertyMultilink( [ 'isEnabled' ], ( isEnabled ) => {\n            \n            // in a local scope, define the functions that the user can use to manipulate the sound\n            const setOutputLevel = ( level ) => {\n            \n              // As a safety measure, don't let the user set a level below zero and above 2.\n              const outputLevel = Math.max( 0, Math.min( 2, level ) );\n              playCheckboxCheckedSoundClip.outputLevel = outputLevel;\n            };\n            const setPlaybackRate = ( rate ) => {\n            \n              // As a safety measure, the playback rate cannot go below zero.\n              const playbackRate = Math.max( 0, rate );\n              playCheckboxCheckedSoundClip.setPlaybackRate( playbackRate );\n            };\n            \n            // a function the user can call to play the sound\n            const play = () => {\n            \n              // Play the sound - if looping, we don't want to start playing again if already playing. The sound\n              // can only be played at a limited interval for safety.\n              if ( ( !playCheckboxCheckedSoundClip.isPlaying || !false ) && phet.paperLand.elapsedTimeProperty.value - playCheckboxCheckedLastPlayTime > 0.25 ) {\n      \n                // only start playing again if it has been stopped - but we still enter this block to update\n                // the last play time and timeouts        \n                if ( !playCheckboxCheckedSoundClip.isPlaying ) {\n                  playCheckboxCheckedSoundClip.play();\n                }\n                playCheckboxCheckedLastPlayTime = phet.paperLand.elapsedTimeProperty.value;\n                \n                // Set a timer to turn off the sound when the value stops changing.\n                if ( playCheckboxCheckedStopSoundTimeout ){\n                  window.clearTimeout( playCheckboxCheckedStopSoundTimeout );\n                }\n                \n                // only stop if not looping\n                if ( !false ) {\n                  playCheckboxCheckedStopSoundTimeout = window.setTimeout( () => {\n                    playCheckboxCheckedSoundClip.stop();\n                  }, 5000 );\n                }  \n              }\n            };\n            \n            const stop = () => {\n              // Set a timer to turn off the sound when the value stops changing.\n              if ( playCheckboxCheckedStopSoundTimeout ){\n                window.clearTimeout( playCheckboxCheckedStopSoundTimeout );\n              }\n              playCheckboxCheckedSoundClip.stop();\n            };\n            \n            if ( false ) {\n              play();\n            }\n            \n            // declare the references so that they can be used in the control function\n            \n          \n            if (isEnabled) {\n    play();\n}\n          }, {\n            otherReferences: [  ],\n          } );  \n        }\n      };     \n      scratchpad.playCheckboxCheckedWrappedAudioBuffer.audioBufferProperty.link( scratchpad.playCheckboxCheckedWrappedAudioBufferListener );\n      \n      // Assign the sound to the scratchpad so that we can remove it later\n      scratchpad.playCheckboxCheckedSoundClip = playCheckboxCheckedSoundClip;\n    \n\n      const playCheckboxUncheckedWrappedAudioBuffer = createAndLoadWrappedAudioBuffer( 'media/sounds/uploads/checkboxUnchecked.mp3' );\n      const playCheckboxUncheckedSoundClip = new phet.tambo.SoundClip( playCheckboxUncheckedWrappedAudioBuffer, {\n        loop: false,\n        initialOutputLevel: 0.5\n       } );\n      phet.tambo.soundManager.addSoundGenerator( playCheckboxUncheckedSoundClip );\n      scratchpad.playCheckboxUncheckedWrappedAudioBuffer = playCheckboxUncheckedWrappedAudioBuffer;\n      \n      let playCheckboxUncheckedStopSoundTimeout = null;\n      \n      // as a safety measure, sound can only be played every 0.25 seconds - initial value is very small\n      // so that it can be played immediately\n      let playCheckboxUncheckedLastPlayTime = 0;\n      \n      // The listener that will observe the model and play sounds is added as soon as the sounds are loaded, and\n      // added to the scratch pad so that it can be removed later.\n      scratchpad.playCheckboxUncheckedWrappedAudioBufferListener = _buffer => {\n        if ( _buffer ) {\n        \n          // Play the sound when any dependencies change value.\n          scratchpad.playCheckboxUncheckedSoundMultilinkId = phet.paperLand.addModelPropertyMultilink( [ 'isEnabled' ], ( isEnabled ) => {\n            \n            // in a local scope, define the functions that the user can use to manipulate the sound\n            const setOutputLevel = ( level ) => {\n            \n              // As a safety measure, don't let the user set a level below zero and above 2.\n              const outputLevel = Math.max( 0, Math.min( 2, level ) );\n              playCheckboxUncheckedSoundClip.outputLevel = outputLevel;\n            };\n            const setPlaybackRate = ( rate ) => {\n            \n              // As a safety measure, the playback rate cannot go below zero.\n              const playbackRate = Math.max( 0, rate );\n              playCheckboxUncheckedSoundClip.setPlaybackRate( playbackRate );\n            };\n            \n            // a function the user can call to play the sound\n            const play = () => {\n            \n              // Play the sound - if looping, we don't want to start playing again if already playing. The sound\n              // can only be played at a limited interval for safety.\n              if ( ( !playCheckboxUncheckedSoundClip.isPlaying || !false ) && phet.paperLand.elapsedTimeProperty.value - playCheckboxUncheckedLastPlayTime > 0.25 ) {\n      \n                // only start playing again if it has been stopped - but we still enter this block to update\n                // the last play time and timeouts        \n                if ( !playCheckboxUncheckedSoundClip.isPlaying ) {\n                  playCheckboxUncheckedSoundClip.play();\n                }\n                playCheckboxUncheckedLastPlayTime = phet.paperLand.elapsedTimeProperty.value;\n                \n                // Set a timer to turn off the sound when the value stops changing.\n                if ( playCheckboxUncheckedStopSoundTimeout ){\n                  window.clearTimeout( playCheckboxUncheckedStopSoundTimeout );\n                }\n                \n                // only stop if not looping\n                if ( !false ) {\n                  playCheckboxUncheckedStopSoundTimeout = window.setTimeout( () => {\n                    playCheckboxUncheckedSoundClip.stop();\n                  }, 5000 );\n                }  \n              }\n            };\n            \n            const stop = () => {\n              // Set a timer to turn off the sound when the value stops changing.\n              if ( playCheckboxUncheckedStopSoundTimeout ){\n                window.clearTimeout( playCheckboxUncheckedStopSoundTimeout );\n              }\n              playCheckboxUncheckedSoundClip.stop();\n            };\n            \n            if ( false ) {\n              play();\n            }\n            \n            // declare the references so that they can be used in the control function\n            \n          \n            if (isEnabled === false){\n    play();\n}\n          }, {\n            otherReferences: [  ],\n          } );  \n        }\n      };     \n      scratchpad.playCheckboxUncheckedWrappedAudioBuffer.audioBufferProperty.link( scratchpad.playCheckboxUncheckedWrappedAudioBufferListener );\n      \n      // Assign the sound to the scratchpad so that we can remove it later\n      scratchpad.playCheckboxUncheckedSoundClip = playCheckboxUncheckedSoundClip;\n    \n\n      // Speak the description whenever the dependencies change.\n      const voiceResponsesForChangesDescriptionFunction = ( isEnabled, checkboxNameResponse, checkedResponse, uncheckedResponse ) => {\n      \n        // get the additional reference constants so they are available in the control function\n        \n      \n        // in a local scope, define the functions that the user can use to manipulate the text\n        \n      const unitBoundsToDisplayBounds = ( bounds ) => {\n        return phet.paperLand.utils.paperToBoardBounds( bounds, sharedData.displaySize.width, sharedData.displaySize.height );\n      };\n      \n      const unitPositionToDisplayPosition = ( position ) => {\n        return phet.paperLand.utils.paperToBoardCoordinates( position, sharedData.displaySize.width, sharedData.displaySize.height );\n      };\n    \n      const setCenterX = ( x ) => {\n        voiceResponsesForChangesDescription.centerX = x;\n      };\n      \n      const setCenterY = ( y ) => {\n        voiceResponsesForChangesDescription.centerY = y;\n      };\n      \n      const setLeft = ( left ) => {\n        voiceResponsesForChangesDescription.left = left;\n      };\n      \n      const setTop = ( top ) => {\n        voiceResponsesForChangesDescription.top = top;\n      };\n      \n      const setScale = ( scale ) => {\n        voiceResponsesForChangesDescription.setScaleMagnitude( scale );\n      };\n      \n      const setOpacity = ( opacity ) => {\n        voiceResponsesForChangesDescription.opacity = opacity;\n      };\n      \n      const setVisible = ( visible ) => {\n        voiceResponsesForChangesDescription.visible = visible;\n      };\n      \n      const moveToFront = () => {\n        voiceResponsesForChangesDescription.moveToFront();\n      };\n      \n      const moveToBack = () => {\n        voiceResponsesForChangesDescription.moveToBack();\n      };\n      \n      const setRotation = ( rotation ) => {\n        voiceResponsesForChangesDescription.rotation = rotation;\n      };\n\n      // Set the scale in X and Y and the       \n      const matchBounds = ( bounds, stretch ) => {\n      \n        // Find the scale to apply to the x and y dimensions so that the component bounds match the provided bounds\n        const voiceResponsesForChangesDescriptionViewBounds = phet.paperLand.utils.paperToBoardBounds(bounds, sharedData.displaySize.width, sharedData.displaySize.height);\n\n        // local bounds may be zero as things load\n        // const aspectRatio = ( voiceResponsesForChangesDescription.localBounds.width || 1 ) / ( voiceResponsesForChangesDescription.localBounds.height || 1 );\n\n        const scaleX = voiceResponsesForChangesDescriptionViewBounds.width / ( voiceResponsesForChangesDescription.localBounds.width || 1 );\n        const scaleY = voiceResponsesForChangesDescriptionViewBounds.height / ( voiceResponsesForChangesDescription.localBounds.height || 1 );\n\n        if ( stretch ) {\n          voiceResponsesForChangesDescription.setScaleMagnitude(scaleX, scaleY);\n        }\n        else {\n        \n          // Scale by the minimum of the x and y scale factors, preserving the aspect ratio\n          voiceResponsesForChangesDescription.setScaleMagnitude( Math.min( scaleX, scaleY ) );\n        }        \n\n        // Now put the component in the center of the bounds\n        voiceResponsesForChangesDescription.center = voiceResponsesForChangesDescriptionViewBounds.center;\n      };\n      \n\n      \n        // Stop all speech and clear the queue\n        const interruptSpeech = () => {\n          phet.scenery.voicingUtteranceQueue.cancel();;\n        };\n        \n        // Mute/unmute the utterance queue\n        const setMuted = ( v ) => {\n          phet.scenery.voicingUtteranceQueue.setMuted( v );\n        };\n        \n        // Sets the priority of this utterance in the queue\n        const setPriority = ( v ) => {\n          scratchpad.voiceResponsesForChangesDescriptionUtterance.priorityProperty.value = v;\n        }\n        \n        const setAlertStableDelay = ( v ) => {\n          scratchpad.voiceResponsesForChangesDescriptionUtterance.setAlertStableDelay( v );\n        };\n        \n        const setVoiceRate = ( v ) => {\n          phet.scenery.voicingManager.voiceRateProperty.value = v;\n        };\n        \n        const setVoicePitch = ( v ) => {\n          phet.scenery.voicingManager.voicePitchProperty.value = v;\n        };\n      \n      \n        if (isEnabled) {\n  return checkboxNameResponse + checkedResponse ;\n} \nelse {\n  return checkboxNameResponse + uncheckedResponse ;\n}\n      }\n      \n      // a reusable utterance for this description component so that only the latest value is spoken - in general\n      // it should not cancel other Utterances in this context but it should cancel itself\n      scratchpad.voiceResponsesForChangesDescriptionUtterance = new phet.utteranceQueue.Utterance( { announcerOptions: { cancelOther: false } } );\n      \n      scratchpad.voiceResponsesForChangesDescriptionMultilinkId = phet.paperLand.addModelPropertyMultilink( [ 'isEnabled', 'checkboxNameResponse', 'checkedResponse', 'uncheckedResponse' ], ( isEnabled, checkboxNameResponse, checkedResponse, uncheckedResponse ) => {\n\n        // Make sure there is a string to speak, including converting falsy values and numbers to a string       \n        const descriptionResult = voiceResponsesForChangesDescriptionFunction( isEnabled, checkboxNameResponse, checkedResponse, uncheckedResponse );\n        if ( descriptionResult && descriptionResult.toString ) {\n          const descriptionString = descriptionResult.toString();\n          if ( descriptionString && descriptionString.length > 0 ) {\n            scratchpad.voiceResponsesForChangesDescriptionUtterance.alert = descriptionString;\n            phet.scenery.voicingUtteranceQueue.addToBack( scratchpad.voiceResponsesForChangesDescriptionUtterance ); \n          }\n        }\n      }, {\n        lazy: true,\n        otherReferences: [  ]\n      } ); \n    \n\n      // Speak the description whenever the dependencies change.\n      const voiceResponsesForFocusDescriptionFunction = ( isFocused, checkboxHintResponse ) => {\n      \n        // get the additional reference constants so they are available in the control function\n        const checkboxNameResponse = phet.paperLand.getModelComponent('checkboxNameResponse').value;\n      \n        // in a local scope, define the functions that the user can use to manipulate the text\n        \n      const unitBoundsToDisplayBounds = ( bounds ) => {\n        return phet.paperLand.utils.paperToBoardBounds( bounds, sharedData.displaySize.width, sharedData.displaySize.height );\n      };\n      \n      const unitPositionToDisplayPosition = ( position ) => {\n        return phet.paperLand.utils.paperToBoardCoordinates( position, sharedData.displaySize.width, sharedData.displaySize.height );\n      };\n    \n      const setCenterX = ( x ) => {\n        voiceResponsesForFocusDescription.centerX = x;\n      };\n      \n      const setCenterY = ( y ) => {\n        voiceResponsesForFocusDescription.centerY = y;\n      };\n      \n      const setLeft = ( left ) => {\n        voiceResponsesForFocusDescription.left = left;\n      };\n      \n      const setTop = ( top ) => {\n        voiceResponsesForFocusDescription.top = top;\n      };\n      \n      const setScale = ( scale ) => {\n        voiceResponsesForFocusDescription.setScaleMagnitude( scale );\n      };\n      \n      const setOpacity = ( opacity ) => {\n        voiceResponsesForFocusDescription.opacity = opacity;\n      };\n      \n      const setVisible = ( visible ) => {\n        voiceResponsesForFocusDescription.visible = visible;\n      };\n      \n      const moveToFront = () => {\n        voiceResponsesForFocusDescription.moveToFront();\n      };\n      \n      const moveToBack = () => {\n        voiceResponsesForFocusDescription.moveToBack();\n      };\n      \n      const setRotation = ( rotation ) => {\n        voiceResponsesForFocusDescription.rotation = rotation;\n      };\n\n      // Set the scale in X and Y and the       \n      const matchBounds = ( bounds, stretch ) => {\n      \n        // Find the scale to apply to the x and y dimensions so that the component bounds match the provided bounds\n        const voiceResponsesForFocusDescriptionViewBounds = phet.paperLand.utils.paperToBoardBounds(bounds, sharedData.displaySize.width, sharedData.displaySize.height);\n\n        // local bounds may be zero as things load\n        // const aspectRatio = ( voiceResponsesForFocusDescription.localBounds.width || 1 ) / ( voiceResponsesForFocusDescription.localBounds.height || 1 );\n\n        const scaleX = voiceResponsesForFocusDescriptionViewBounds.width / ( voiceResponsesForFocusDescription.localBounds.width || 1 );\n        const scaleY = voiceResponsesForFocusDescriptionViewBounds.height / ( voiceResponsesForFocusDescription.localBounds.height || 1 );\n\n        if ( stretch ) {\n          voiceResponsesForFocusDescription.setScaleMagnitude(scaleX, scaleY);\n        }\n        else {\n        \n          // Scale by the minimum of the x and y scale factors, preserving the aspect ratio\n          voiceResponsesForFocusDescription.setScaleMagnitude( Math.min( scaleX, scaleY ) );\n        }        \n\n        // Now put the component in the center of the bounds\n        voiceResponsesForFocusDescription.center = voiceResponsesForFocusDescriptionViewBounds.center;\n      };\n      \n\n      \n        // Stop all speech and clear the queue\n        const interruptSpeech = () => {\n          phet.scenery.voicingUtteranceQueue.cancel();;\n        };\n        \n        // Mute/unmute the utterance queue\n        const setMuted = ( v ) => {\n          phet.scenery.voicingUtteranceQueue.setMuted( v );\n        };\n        \n        // Sets the priority of this utterance in the queue\n        const setPriority = ( v ) => {\n          scratchpad.voiceResponsesForFocusDescriptionUtterance.priorityProperty.value = v;\n        }\n        \n        const setAlertStableDelay = ( v ) => {\n          scratchpad.voiceResponsesForFocusDescriptionUtterance.setAlertStableDelay( v );\n        };\n        \n        const setVoiceRate = ( v ) => {\n          phet.scenery.voicingManager.voiceRateProperty.value = v;\n        };\n        \n        const setVoicePitch = ( v ) => {\n          phet.scenery.voicingManager.voicePitchProperty.value = v;\n        };\n      \n      \n        if (isFocused){\n    return ( checkboxNameResponse + checkboxHintResponse ) ;\n}\n      }\n      \n      // a reusable utterance for this description component so that only the latest value is spoken - in general\n      // it should not cancel other Utterances in this context but it should cancel itself\n      scratchpad.voiceResponsesForFocusDescriptionUtterance = new phet.utteranceQueue.Utterance( { announcerOptions: { cancelOther: false } } );\n      \n      scratchpad.voiceResponsesForFocusDescriptionMultilinkId = phet.paperLand.addModelPropertyMultilink( [ 'isFocused', 'checkboxHintResponse' ], ( isFocused, checkboxHintResponse ) => {\n\n        // Make sure there is a string to speak, including converting falsy values and numbers to a string       \n        const descriptionResult = voiceResponsesForFocusDescriptionFunction( isFocused, checkboxHintResponse );\n        if ( descriptionResult && descriptionResult.toString ) {\n          const descriptionString = descriptionResult.toString();\n          if ( descriptionString && descriptionString.length > 0 ) {\n            scratchpad.voiceResponsesForFocusDescriptionUtterance.alert = descriptionString;\n            phet.scenery.voicingUtteranceQueue.addToBack( scratchpad.voiceResponsesForFocusDescriptionUtterance ); \n          }\n        }\n      }, {\n        lazy: true,\n        otherReferences: [ 'checkboxNameResponse' ]\n      } ); \n    \n\n      // Create a background rectangle and add it to the view.\n      const setBackgroundWhiteBackgroundRectangle = new phet.scenery.Rectangle( 0, 0, sharedData.displaySize.width, sharedData.displaySize.height, {\n        fill: 'white'\n      } );\n      \n      // If there are no dependencies for the background, add it to the view immediately. Otherwise, we will add it\n      // once all dependencies are available.\n      if ( [  ].length === 0 ) {\n        sharedData.scene.addChild( setBackgroundWhiteBackgroundRectangle );\n        setBackgroundWhiteBackgroundRectangle.moveToBack();\n      }\n      \n      // Assign to the scratchpad so that we can remove it later.\n      scratchpad.setBackgroundWhiteBackgroundRectangle = setBackgroundWhiteBackgroundRectangle;\n  \n      const setBackgroundWhiteBackgroundColorDependencies = [  ];\n\n      // Get a new background color whenever a dependency changes. The control function should return a color string.\n      const setBackgroundWhiteBackgroundFunction = (  ) => {\n      \n        // bring in the references so they are available in the control function\n        \n      \n        \n      }\n      \n      // Update the background rectangle whenever the dependencies change.\n      scratchpad.setBackgroundWhiteBackgroundMultilinkId = phet.paperLand.addModelPropertyMultilink( [  ], (  ) => {\n    \n        const backgroundColorString = setBackgroundWhiteBackgroundFunction(  );\n        \n        // wait to add the background until all dependencies are available (only add this once)\n        if ( scratchpad.setBackgroundWhiteBackgroundRectangle.parents.length === 0 ) {\n          sharedData.scene.addChild( setBackgroundWhiteBackgroundRectangle );\n          setBackgroundWhiteBackgroundRectangle.moveToBack();\n        }\n        \n        // the function may not be implemented\n        if ( backgroundColorString ) {\n          setBackgroundWhiteBackgroundRectangle.fill = backgroundColorString;\n        }\n        \n        setBackgroundWhiteBackgroundRectangle.setRect( 0, 0, sharedData.displaySize.width, sharedData.displaySize.height );\n      }, {\n        otherProperties: [ phet.paperLand.displaySizeProperty ],\n        otherReferences: [  ]\n      } );\n    \n// Create a checkbox and add it to the scene.\nconst fontSizeA = phet.paperLand.getModelComponent(`fontSize`);\nconst checkboxLabelA = phet.paperLand.getModelComponent(`checkboxNameResponse`);\nconst isEnabledA = phet.paperLand.getModelComponent(`isEnabled`);\n\nconst checkboxLabelText = new phet.scenery.Text(checkboxLabelA.value, {\n    font: new phet.sceneryPhet.PhetFont( fontSizeA.value )\n});\n\nconst checkbox = new phet.sun.Checkbox(isEnabledA, checkboxLabelText);\nsharedData.scene.addChild(checkbox);\nscratchpad.checkbox = checkbox;\ncheckbox.moveToFront();\n  };\n\n  const onProgramRemoved = ( paperNumber, scratchpad, sharedData ) => {\n    \n      // Remove the component from the model\n      phet.paperLand.removeModelComponent( 'isEnabled' );\n    \n\n      // Remove the component from the model\n      phet.paperLand.removeModelComponent( 'isFocused' );\n    \n\n      // Remove the component from the model\n      phet.paperLand.removeModelComponent( 'visualPosition' );\n    \n\n      // Remove the component from the model\n      phet.paperLand.removeModelComponent( 'fontSize' );\n    \n\n      // Remove the component from the model\n      phet.paperLand.removeModelComponent( 'checkboxNameResponse' );\n    \n\n      // Remove the component from the model\n      phet.paperLand.removeModelComponent( 'checkedResponse' );\n    \n\n      // Remove the component from the model\n      phet.paperLand.removeModelComponent( 'uncheckedResponse' );\n    \n\n      // Remove the component from the model\n      phet.paperLand.removeModelComponent( 'checkboxHintResponse' );\n    \n\n      phet.tambo.soundManager.removeSoundGenerator( scratchpad.playCheckboxCheckedSoundClip );\n      delete scratchpad.playCheckboxCheckedSoundClip;\n      \n      scratchpad.playCheckboxCheckedWrappedAudioBuffer.audioBufferProperty.unlink( scratchpad.playCheckboxCheckedWrappedAudioBufferListener );\n      delete scratchpad.playCheckboxCheckedWrappedAudioBufferListener;\n      \n      phet.paperLand.removeModelPropertyMultilink( [ 'isEnabled' ], scratchpad.playCheckboxCheckedSoundMultilinkId, {\n        otherReferences: [  ]\n       } );\n      delete scratchpad.playCheckboxCheckedSoundMultilinkId;\n    \n\n      phet.tambo.soundManager.removeSoundGenerator( scratchpad.playCheckboxUncheckedSoundClip );\n      delete scratchpad.playCheckboxUncheckedSoundClip;\n      \n      scratchpad.playCheckboxUncheckedWrappedAudioBuffer.audioBufferProperty.unlink( scratchpad.playCheckboxUncheckedWrappedAudioBufferListener );\n      delete scratchpad.playCheckboxUncheckedWrappedAudioBufferListener;\n      \n      phet.paperLand.removeModelPropertyMultilink( [ 'isEnabled' ], scratchpad.playCheckboxUncheckedSoundMultilinkId, {\n        otherReferences: [  ]\n       } );\n      delete scratchpad.playCheckboxUncheckedSoundMultilinkId;\n    \n\n      // Remove the description multilink\n      phet.paperLand.removeModelPropertyMultilink( [ 'isEnabled', 'checkboxNameResponse', 'checkedResponse', 'uncheckedResponse' ], scratchpad.voiceResponsesForChangesDescriptionMultilinkId, {\n        otherReferences: [  ]\n       } );\n      delete scratchpad.voiceResponsesForChangesDescriptionMultilinkId;\n      \n      // Remove the utterance\n      delete scratchpad.voiceResponsesForChangesDescriptionUtterance;\n    \n\n      // Remove the description multilink\n      phet.paperLand.removeModelPropertyMultilink( [ 'isFocused', 'checkboxHintResponse' ], scratchpad.voiceResponsesForFocusDescriptionMultilinkId, {\n        otherReferences: [ 'checkboxNameResponse' ]\n       } );\n      delete scratchpad.voiceResponsesForFocusDescriptionMultilinkId;\n      \n      // Remove the utterance\n      delete scratchpad.voiceResponsesForFocusDescriptionUtterance;\n    \n\n      // Remove the background rectangle from the view.\n      sharedData.scene.removeChild( scratchpad.setBackgroundWhiteBackgroundRectangle );\n      delete scratchpad.setBackgroundWhiteBackgroundRectangle;\n      \n      // Remove the multilink if there were any dependencies\n      if ( scratchpad.setBackgroundWhiteBackgroundMultilinkId ) {\n        phet.paperLand.removeModelPropertyMultilink( [  ], scratchpad.setBackgroundWhiteBackgroundMultilinkId, {\n          otherReferences: [  ]\n        } );\n        delete scratchpad.setBackgroundWhiteBackgroundMultilinkId;\n      }\n    \nif (scratchpad.checkbox) {\n    sharedData.scene.removeChild(scratchpad.checkbox);\n    scratchpad.checkbox = null;\n}\nelse {\n    alert('Error: Checkbox node not found in scratchpad data.');\n}\n  };\n\n  const onProgramChangedPosition = ( paperNumber, points, scratchpad, sharedData ) => {\n    \n    const modelProperty0 = phet.paperLand.getModelComponent( 'visualPosition' );\n    if ( modelProperty0 ) {\n      modelProperty0.value = phet.paperLand.utils.getProgramCenter( points );\n    }\n\n    const modelProperty1 = phet.paperLand.getModelComponent( 'isEnabled' );\n    if ( modelProperty1 ) {\n      modelProperty1.value = phet.paperLand.utils.getNormalizedProgramRotation( points ) > 0.25 && phet.paperLand.utils.getNormalizedProgramRotation( points ) < 0.75;\n    }\nconst visualPosition = phet.paperLand.getModelComponent(`visualPosition`);\nif (scratchpad.checkbox) {\n\n    // Center the image based on the position of the paper.\n    const centerPositionDisplayUnits = phet.paperLand.utils.paperToBoardCoordinates(visualPosition.value, sharedData.displaySize.width, sharedData.displaySize.height);\n    scratchpad.checkbox.centerX = centerPositionDisplayUnits.x;\n    scratchpad.checkbox.centerY = centerPositionDisplayUnits.y;\n}\n  };\n  \n  const onProgramMarkersAdded = ( paperNumber, points, scratchpad, sharedData, markers ) => {\n    \n    const modelProperty5 = phet.paperLand.getModelComponent( 'isFocused' );\n    if ( modelProperty5 ) {\n      modelProperty5.value = markers.length > 0;\n    }\n  };\n  \n  const onProgramMarkersRemoved = ( paperNumber, points, scratchpad, sharedData, markers ) => {\n    \n    const modelProperty9 = phet.paperLand.getModelComponent( 'isFocused' );\n    if ( modelProperty9 ) {\n      modelProperty9.value = markers.length > 0;\n    }\n  };\n  \n  const onProgramMarkersChangedPosition = ( paperNumber, points, scratchpad, sharedData, markers ) => {\n    \n  };\n  \n  const onProgramAdjacent = ( paperNumber, otherPaperNumber, direction, scratchpad, sharedData ) => {\n    \n  };\n  \n  const onProgramSeparated = ( paperNumber, otherPaperNumber, direction, scratchpad, sharedData ) => {\n    \n  };\n\n  await paper.set( 'data', {\n    paperPlaygroundData: {\n      updateTime: Date.now(),\n      eventHandlers: {\n        onProgramAdded: onProgramAdded.toString(),\n        onProgramRemoved: onProgramRemoved.toString(),\n        onProgramChangedPosition: onProgramChangedPosition.toString(),\n        onProgramMarkersAdded: onProgramMarkersAdded.toString(),\n        onProgramMarkersRemoved: onProgramMarkersRemoved.toString(),\n        onProgramMarkersChangedPosition: onProgramMarkersChangedPosition.toString(),\n        onProgramAdjacent: onProgramAdjacent.toString(),\n        onProgramSeparated: onProgramSeparated.toString(),\n      },\n      customWhiskerLengths: {\n        top: 0.2,\n        right: 0.2,\n        bottom: 0.2,\n        left: 0.2\n      }\n    }\n  } );\n  \n  // PROJECTOR CODE //\n  // Get a canvas object for this paper to draw something to the Projector.\n  const canvas = await paper.get('canvas');\n\n  // Draw the name of the program to the projector\n  const ctx = canvas.getContext('2d');\n  ctx.font = '20px sans-serif';\n  ctx.textAlign = 'center';\n  ctx.fillStyle = 'rgb(255,0,0)';\n  ctx.fillText('', canvas.width / 2, canvas.height / 2 - 10);\n  ctx.fillStyle = 'rgb(0,255,0)';\n  ctx.font = '10px sans-serif';\n  ctx.fillText('Multimodal Checkbox', canvas.width / 2, canvas.height / 2 + 20);\n})();\n",
  "currentCode": "// Multimodal Checkbox\n// Keywords: \n// Description: A sample checkbox with sound and voiced responses/ descriptions.\n// \n// Copy the template into your own project, edit the String Model Components to try out your own name, hint, and checkbox responses. The hint response is optional. To not hear it, just remove it from the View component called voiceResponsesForFocus.\n\nimportScripts('paper.js');\n\n(async () => {\n\n  const onProgramAdded = ( paperNumber, scratchpad, sharedData ) => {\n    \n      const isEnabled = new phet.axon.BooleanProperty(false);\n      phet.paperLand.addModelComponent( 'isEnabled', isEnabled );\n    \n\n      const isFocused = new phet.axon.BooleanProperty(false);\n      phet.paperLand.addModelComponent( 'isFocused', isFocused );\n    \n\n      const visualPosition = new phet.dot.Vector2Property(\n        new phet.dot.Vector2( 0.5, 0.5 )\n      );\n      phet.paperLand.addModelComponent( 'visualPosition', visualPosition );\n    \n\n      const fontSize = new phet.axon.NumberProperty( 24, {\n        range: new phet.dot.Range( 0, 48 )\n      });\n      phet.paperLand.addModelComponent( 'fontSize', fontSize );\n    \n\n      const checkboxNameResponse = new phet.axon.StringProperty( 'Force Values' );\n      phet.paperLand.addModelComponent( 'checkboxNameResponse', checkboxNameResponse );\n    \n\n      const checkedResponse = new phet.axon.StringProperty( 'Shown in newtons.' );\n      phet.paperLand.addModelComponent( 'checkedResponse', checkedResponse );\n    \n\n      const uncheckedResponse = new phet.axon.StringProperty( 'Hidden.' );\n      phet.paperLand.addModelComponent( 'uncheckedResponse', uncheckedResponse );\n    \n\n      const checkboxHintResponse = new phet.axon.StringProperty( 'Explore with or without newtons.' );\n      phet.paperLand.addModelComponent( 'checkboxHintResponse', checkboxHintResponse );\n    \n\n      const playCheckboxCheckedWrappedAudioBuffer = createAndLoadWrappedAudioBuffer( 'media/sounds/uploads/checkboxChecked.mp3' );\n      const playCheckboxCheckedSoundClip = new phet.tambo.SoundClip( playCheckboxCheckedWrappedAudioBuffer, {\n        loop: false,\n        initialOutputLevel: 0.5\n       } );\n      phet.tambo.soundManager.addSoundGenerator( playCheckboxCheckedSoundClip );\n      scratchpad.playCheckboxCheckedWrappedAudioBuffer = playCheckboxCheckedWrappedAudioBuffer;\n      \n      let playCheckboxCheckedStopSoundTimeout = null;\n      \n      // as a safety measure, sound can only be played every 0.25 seconds - initial value is very small\n      // so that it can be played immediately\n      let playCheckboxCheckedLastPlayTime = 0;\n      \n      // The listener that will observe the model and play sounds is added as soon as the sounds are loaded, and\n      // added to the scratch pad so that it can be removed later.\n      scratchpad.playCheckboxCheckedWrappedAudioBufferListener = _buffer => {\n        if ( _buffer ) {\n        \n          // Play the sound when any dependencies change value.\n          scratchpad.playCheckboxCheckedSoundMultilinkId = phet.paperLand.addModelPropertyMultilink( [ 'isEnabled' ], ( isEnabled ) => {\n            \n            // in a local scope, define the functions that the user can use to manipulate the sound\n            const setOutputLevel = ( level ) => {\n            \n              // As a safety measure, don't let the user set a level below zero and above 2.\n              const outputLevel = Math.max( 0, Math.min( 2, level ) );\n              playCheckboxCheckedSoundClip.outputLevel = outputLevel;\n            };\n            const setPlaybackRate = ( rate ) => {\n            \n              // As a safety measure, the playback rate cannot go below zero.\n              const playbackRate = Math.max( 0, rate );\n              playCheckboxCheckedSoundClip.setPlaybackRate( playbackRate );\n            };\n            \n            // a function the user can call to play the sound\n            const play = () => {\n            \n              // Play the sound - if looping, we don't want to start playing again if already playing. The sound\n              // can only be played at a limited interval for safety.\n              if ( ( !playCheckboxCheckedSoundClip.isPlaying || !false ) && phet.paperLand.elapsedTimeProperty.value - playCheckboxCheckedLastPlayTime > 0.25 ) {\n      \n                // only start playing again if it has been stopped - but we still enter this block to update\n                // the last play time and timeouts        \n                if ( !playCheckboxCheckedSoundClip.isPlaying ) {\n                  playCheckboxCheckedSoundClip.play();\n                }\n                playCheckboxCheckedLastPlayTime = phet.paperLand.elapsedTimeProperty.value;\n                \n                // Set a timer to turn off the sound when the value stops changing.\n                if ( playCheckboxCheckedStopSoundTimeout ){\n                  window.clearTimeout( playCheckboxCheckedStopSoundTimeout );\n                }\n                \n                // only stop if not looping\n                if ( !false ) {\n                  playCheckboxCheckedStopSoundTimeout = window.setTimeout( () => {\n                    playCheckboxCheckedSoundClip.stop();\n                  }, 5000 );\n                }  \n              }\n            };\n            \n            const stop = () => {\n              // Set a timer to turn off the sound when the value stops changing.\n              if ( playCheckboxCheckedStopSoundTimeout ){\n                window.clearTimeout( playCheckboxCheckedStopSoundTimeout );\n              }\n              playCheckboxCheckedSoundClip.stop();\n            };\n            \n            if ( false ) {\n              play();\n            }\n            \n            // declare the references so that they can be used in the control function\n            \n          \n            if (isEnabled) {\n    play();\n}\n          }, {\n            otherReferences: [  ],\n          } );  \n        }\n      };     \n      scratchpad.playCheckboxCheckedWrappedAudioBuffer.audioBufferProperty.link( scratchpad.playCheckboxCheckedWrappedAudioBufferListener );\n      \n      // Assign the sound to the scratchpad so that we can remove it later\n      scratchpad.playCheckboxCheckedSoundClip = playCheckboxCheckedSoundClip;\n    \n\n      const playCheckboxUncheckedWrappedAudioBuffer = createAndLoadWrappedAudioBuffer( 'media/sounds/uploads/checkboxUnchecked.mp3' );\n      const playCheckboxUncheckedSoundClip = new phet.tambo.SoundClip( playCheckboxUncheckedWrappedAudioBuffer, {\n        loop: false,\n        initialOutputLevel: 0.5\n       } );\n      phet.tambo.soundManager.addSoundGenerator( playCheckboxUncheckedSoundClip );\n      scratchpad.playCheckboxUncheckedWrappedAudioBuffer = playCheckboxUncheckedWrappedAudioBuffer;\n      \n      let playCheckboxUncheckedStopSoundTimeout = null;\n      \n      // as a safety measure, sound can only be played every 0.25 seconds - initial value is very small\n      // so that it can be played immediately\n      let playCheckboxUncheckedLastPlayTime = 0;\n      \n      // The listener that will observe the model and play sounds is added as soon as the sounds are loaded, and\n      // added to the scratch pad so that it can be removed later.\n      scratchpad.playCheckboxUncheckedWrappedAudioBufferListener = _buffer => {\n        if ( _buffer ) {\n        \n          // Play the sound when any dependencies change value.\n          scratchpad.playCheckboxUncheckedSoundMultilinkId = phet.paperLand.addModelPropertyMultilink( [ 'isEnabled' ], ( isEnabled ) => {\n            \n            // in a local scope, define the functions that the user can use to manipulate the sound\n            const setOutputLevel = ( level ) => {\n            \n              // As a safety measure, don't let the user set a level below zero and above 2.\n              const outputLevel = Math.max( 0, Math.min( 2, level ) );\n              playCheckboxUncheckedSoundClip.outputLevel = outputLevel;\n            };\n            const setPlaybackRate = ( rate ) => {\n            \n              // As a safety measure, the playback rate cannot go below zero.\n              const playbackRate = Math.max( 0, rate );\n              playCheckboxUncheckedSoundClip.setPlaybackRate( playbackRate );\n            };\n            \n            // a function the user can call to play the sound\n            const play = () => {\n            \n              // Play the sound - if looping, we don't want to start playing again if already playing. The sound\n              // can only be played at a limited interval for safety.\n              if ( ( !playCheckboxUncheckedSoundClip.isPlaying || !false ) && phet.paperLand.elapsedTimeProperty.value - playCheckboxUncheckedLastPlayTime > 0.25 ) {\n      \n                // only start playing again if it has been stopped - but we still enter this block to update\n                // the last play time and timeouts        \n                if ( !playCheckboxUncheckedSoundClip.isPlaying ) {\n                  playCheckboxUncheckedSoundClip.play();\n                }\n                playCheckboxUncheckedLastPlayTime = phet.paperLand.elapsedTimeProperty.value;\n                \n                // Set a timer to turn off the sound when the value stops changing.\n                if ( playCheckboxUncheckedStopSoundTimeout ){\n                  window.clearTimeout( playCheckboxUncheckedStopSoundTimeout );\n                }\n                \n                // only stop if not looping\n                if ( !false ) {\n                  playCheckboxUncheckedStopSoundTimeout = window.setTimeout( () => {\n                    playCheckboxUncheckedSoundClip.stop();\n                  }, 5000 );\n                }  \n              }\n            };\n            \n            const stop = () => {\n              // Set a timer to turn off the sound when the value stops changing.\n              if ( playCheckboxUncheckedStopSoundTimeout ){\n                window.clearTimeout( playCheckboxUncheckedStopSoundTimeout );\n              }\n              playCheckboxUncheckedSoundClip.stop();\n            };\n            \n            if ( false ) {\n              play();\n            }\n            \n            // declare the references so that they can be used in the control function\n            \n          \n            if (isEnabled === false){\n    play();\n}\n          }, {\n            otherReferences: [  ],\n          } );  \n        }\n      };     \n      scratchpad.playCheckboxUncheckedWrappedAudioBuffer.audioBufferProperty.link( scratchpad.playCheckboxUncheckedWrappedAudioBufferListener );\n      \n      // Assign the sound to the scratchpad so that we can remove it later\n      scratchpad.playCheckboxUncheckedSoundClip = playCheckboxUncheckedSoundClip;\n    \n\n      // Speak the description whenever the dependencies change.\n      const voiceResponsesForChangesDescriptionFunction = ( isEnabled, checkboxNameResponse, checkedResponse, uncheckedResponse ) => {\n      \n        // get the additional reference constants so they are available in the control function\n        \n      \n        // in a local scope, define the functions that the user can use to manipulate the text\n        \n      const unitBoundsToDisplayBounds = ( bounds ) => {\n        return phet.paperLand.utils.paperToBoardBounds( bounds, sharedData.displaySize.width, sharedData.displaySize.height );\n      };\n      \n      const unitPositionToDisplayPosition = ( position ) => {\n        return phet.paperLand.utils.paperToBoardCoordinates( position, sharedData.displaySize.width, sharedData.displaySize.height );\n      };\n    \n      const setCenterX = ( x ) => {\n        voiceResponsesForChangesDescription.centerX = x;\n      };\n      \n      const setCenterY = ( y ) => {\n        voiceResponsesForChangesDescription.centerY = y;\n      };\n      \n      const setLeft = ( left ) => {\n        voiceResponsesForChangesDescription.left = left;\n      };\n      \n      const setTop = ( top ) => {\n        voiceResponsesForChangesDescription.top = top;\n      };\n      \n      const setScale = ( scale ) => {\n        voiceResponsesForChangesDescription.setScaleMagnitude( scale );\n      };\n      \n      const setOpacity = ( opacity ) => {\n        voiceResponsesForChangesDescription.opacity = opacity;\n      };\n      \n      const setVisible = ( visible ) => {\n        voiceResponsesForChangesDescription.visible = visible;\n      };\n      \n      const moveToFront = () => {\n        voiceResponsesForChangesDescription.moveToFront();\n      };\n      \n      const moveToBack = () => {\n        voiceResponsesForChangesDescription.moveToBack();\n      };\n      \n      const setRotation = ( rotation ) => {\n        voiceResponsesForChangesDescription.rotation = rotation;\n      };\n\n      // Set the scale in X and Y and the       \n      const matchBounds = ( bounds, stretch ) => {\n      \n        // Find the scale to apply to the x and y dimensions so that the component bounds match the provided bounds\n        const voiceResponsesForChangesDescriptionViewBounds = phet.paperLand.utils.paperToBoardBounds(bounds, sharedData.displaySize.width, sharedData.displaySize.height);\n\n        // local bounds may be zero as things load\n        // const aspectRatio = ( voiceResponsesForChangesDescription.localBounds.width || 1 ) / ( voiceResponsesForChangesDescription.localBounds.height || 1 );\n\n        const scaleX = voiceResponsesForChangesDescriptionViewBounds.width / ( voiceResponsesForChangesDescription.localBounds.width || 1 );\n        const scaleY = voiceResponsesForChangesDescriptionViewBounds.height / ( voiceResponsesForChangesDescription.localBounds.height || 1 );\n\n        if ( stretch ) {\n          voiceResponsesForChangesDescription.setScaleMagnitude(scaleX, scaleY);\n        }\n        else {\n        \n          // Scale by the minimum of the x and y scale factors, preserving the aspect ratio\n          voiceResponsesForChangesDescription.setScaleMagnitude( Math.min( scaleX, scaleY ) );\n        }        \n\n        // Now put the component in the center of the bounds\n        voiceResponsesForChangesDescription.center = voiceResponsesForChangesDescriptionViewBounds.center;\n      };\n      \n\n      \n        // Stop all speech and clear the queue\n        const interruptSpeech = () => {\n          phet.scenery.voicingUtteranceQueue.cancel();;\n        };\n        \n        // Mute/unmute the utterance queue\n        const setMuted = ( v ) => {\n          phet.scenery.voicingUtteranceQueue.setMuted( v );\n        };\n        \n        // Sets the priority of this utterance in the queue\n        const setPriority = ( v ) => {\n          scratchpad.voiceResponsesForChangesDescriptionUtterance.priorityProperty.value = v;\n        }\n        \n        const setAlertStableDelay = ( v ) => {\n          scratchpad.voiceResponsesForChangesDescriptionUtterance.setAlertStableDelay( v );\n        };\n        \n        const setVoiceRate = ( v ) => {\n          phet.scenery.voicingManager.voiceRateProperty.value = v;\n        };\n        \n        const setVoicePitch = ( v ) => {\n          phet.scenery.voicingManager.voicePitchProperty.value = v;\n        };\n      \n      \n        if (isEnabled) {\n  return checkboxNameResponse + checkedResponse ;\n} \nelse {\n  return checkboxNameResponse + uncheckedResponse ;\n}\n      }\n      \n      // a reusable utterance for this description component so that only the latest value is spoken - in general\n      // it should not cancel other Utterances in this context but it should cancel itself\n      scratchpad.voiceResponsesForChangesDescriptionUtterance = new phet.utteranceQueue.Utterance( { announcerOptions: { cancelOther: false } } );\n      \n      scratchpad.voiceResponsesForChangesDescriptionMultilinkId = phet.paperLand.addModelPropertyMultilink( [ 'isEnabled', 'checkboxNameResponse', 'checkedResponse', 'uncheckedResponse' ], ( isEnabled, checkboxNameResponse, checkedResponse, uncheckedResponse ) => {\n\n        // Make sure there is a string to speak, including converting falsy values and numbers to a string       \n        const descriptionResult = voiceResponsesForChangesDescriptionFunction( isEnabled, checkboxNameResponse, checkedResponse, uncheckedResponse );\n        if ( descriptionResult && descriptionResult.toString ) {\n          const descriptionString = descriptionResult.toString();\n          if ( descriptionString && descriptionString.length > 0 ) {\n            scratchpad.voiceResponsesForChangesDescriptionUtterance.alert = descriptionString;\n            phet.scenery.voicingUtteranceQueue.addToBack( scratchpad.voiceResponsesForChangesDescriptionUtterance ); \n          }\n        }\n      }, {\n        lazy: true,\n        otherReferences: [  ]\n      } ); \n    \n\n      // Speak the description whenever the dependencies change.\n      const voiceResponsesForFocusDescriptionFunction = ( isFocused, checkboxHintResponse ) => {\n      \n        // get the additional reference constants so they are available in the control function\n        const checkboxNameResponse = phet.paperLand.getModelComponent('checkboxNameResponse').value;\n      \n        // in a local scope, define the functions that the user can use to manipulate the text\n        \n      const unitBoundsToDisplayBounds = ( bounds ) => {\n        return phet.paperLand.utils.paperToBoardBounds( bounds, sharedData.displaySize.width, sharedData.displaySize.height );\n      };\n      \n      const unitPositionToDisplayPosition = ( position ) => {\n        return phet.paperLand.utils.paperToBoardCoordinates( position, sharedData.displaySize.width, sharedData.displaySize.height );\n      };\n    \n      const setCenterX = ( x ) => {\n        voiceResponsesForFocusDescription.centerX = x;\n      };\n      \n      const setCenterY = ( y ) => {\n        voiceResponsesForFocusDescription.centerY = y;\n      };\n      \n      const setLeft = ( left ) => {\n        voiceResponsesForFocusDescription.left = left;\n      };\n      \n      const setTop = ( top ) => {\n        voiceResponsesForFocusDescription.top = top;\n      };\n      \n      const setScale = ( scale ) => {\n        voiceResponsesForFocusDescription.setScaleMagnitude( scale );\n      };\n      \n      const setOpacity = ( opacity ) => {\n        voiceResponsesForFocusDescription.opacity = opacity;\n      };\n      \n      const setVisible = ( visible ) => {\n        voiceResponsesForFocusDescription.visible = visible;\n      };\n      \n      const moveToFront = () => {\n        voiceResponsesForFocusDescription.moveToFront();\n      };\n      \n      const moveToBack = () => {\n        voiceResponsesForFocusDescription.moveToBack();\n      };\n      \n      const setRotation = ( rotation ) => {\n        voiceResponsesForFocusDescription.rotation = rotation;\n      };\n\n      // Set the scale in X and Y and the       \n      const matchBounds = ( bounds, stretch ) => {\n      \n        // Find the scale to apply to the x and y dimensions so that the component bounds match the provided bounds\n        const voiceResponsesForFocusDescriptionViewBounds = phet.paperLand.utils.paperToBoardBounds(bounds, sharedData.displaySize.width, sharedData.displaySize.height);\n\n        // local bounds may be zero as things load\n        // const aspectRatio = ( voiceResponsesForFocusDescription.localBounds.width || 1 ) / ( voiceResponsesForFocusDescription.localBounds.height || 1 );\n\n        const scaleX = voiceResponsesForFocusDescriptionViewBounds.width / ( voiceResponsesForFocusDescription.localBounds.width || 1 );\n        const scaleY = voiceResponsesForFocusDescriptionViewBounds.height / ( voiceResponsesForFocusDescription.localBounds.height || 1 );\n\n        if ( stretch ) {\n          voiceResponsesForFocusDescription.setScaleMagnitude(scaleX, scaleY);\n        }\n        else {\n        \n          // Scale by the minimum of the x and y scale factors, preserving the aspect ratio\n          voiceResponsesForFocusDescription.setScaleMagnitude( Math.min( scaleX, scaleY ) );\n        }        \n\n        // Now put the component in the center of the bounds\n        voiceResponsesForFocusDescription.center = voiceResponsesForFocusDescriptionViewBounds.center;\n      };\n      \n\n      \n        // Stop all speech and clear the queue\n        const interruptSpeech = () => {\n          phet.scenery.voicingUtteranceQueue.cancel();;\n        };\n        \n        // Mute/unmute the utterance queue\n        const setMuted = ( v ) => {\n          phet.scenery.voicingUtteranceQueue.setMuted( v );\n        };\n        \n        // Sets the priority of this utterance in the queue\n        const setPriority = ( v ) => {\n          scratchpad.voiceResponsesForFocusDescriptionUtterance.priorityProperty.value = v;\n        }\n        \n        const setAlertStableDelay = ( v ) => {\n          scratchpad.voiceResponsesForFocusDescriptionUtterance.setAlertStableDelay( v );\n        };\n        \n        const setVoiceRate = ( v ) => {\n          phet.scenery.voicingManager.voiceRateProperty.value = v;\n        };\n        \n        const setVoicePitch = ( v ) => {\n          phet.scenery.voicingManager.voicePitchProperty.value = v;\n        };\n      \n      \n        if (isFocused){\n    return ( checkboxNameResponse + checkboxHintResponse ) ;\n}\n      }\n      \n      // a reusable utterance for this description component so that only the latest value is spoken - in general\n      // it should not cancel other Utterances in this context but it should cancel itself\n      scratchpad.voiceResponsesForFocusDescriptionUtterance = new phet.utteranceQueue.Utterance( { announcerOptions: { cancelOther: false } } );\n      \n      scratchpad.voiceResponsesForFocusDescriptionMultilinkId = phet.paperLand.addModelPropertyMultilink( [ 'isFocused', 'checkboxHintResponse' ], ( isFocused, checkboxHintResponse ) => {\n\n        // Make sure there is a string to speak, including converting falsy values and numbers to a string       \n        const descriptionResult = voiceResponsesForFocusDescriptionFunction( isFocused, checkboxHintResponse );\n        if ( descriptionResult && descriptionResult.toString ) {\n          const descriptionString = descriptionResult.toString();\n          if ( descriptionString && descriptionString.length > 0 ) {\n            scratchpad.voiceResponsesForFocusDescriptionUtterance.alert = descriptionString;\n            phet.scenery.voicingUtteranceQueue.addToBack( scratchpad.voiceResponsesForFocusDescriptionUtterance ); \n          }\n        }\n      }, {\n        lazy: true,\n        otherReferences: [ 'checkboxNameResponse' ]\n      } ); \n    \n\n      // Create a background rectangle and add it to the view.\n      const setBackgroundWhiteBackgroundRectangle = new phet.scenery.Rectangle( 0, 0, sharedData.displaySize.width, sharedData.displaySize.height, {\n        fill: 'white'\n      } );\n      \n      // If there are no dependencies for the background, add it to the view immediately. Otherwise, we will add it\n      // once all dependencies are available.\n      if ( [  ].length === 0 ) {\n        sharedData.scene.addChild( setBackgroundWhiteBackgroundRectangle );\n        setBackgroundWhiteBackgroundRectangle.moveToBack();\n      }\n      \n      // Assign to the scratchpad so that we can remove it later.\n      scratchpad.setBackgroundWhiteBackgroundRectangle = setBackgroundWhiteBackgroundRectangle;\n  \n      const setBackgroundWhiteBackgroundColorDependencies = [  ];\n\n      // Get a new background color whenever a dependency changes. The control function should return a color string.\n      const setBackgroundWhiteBackgroundFunction = (  ) => {\n      \n        // bring in the references so they are available in the control function\n        \n      \n        \n      }\n      \n      // Update the background rectangle whenever the dependencies change.\n      scratchpad.setBackgroundWhiteBackgroundMultilinkId = phet.paperLand.addModelPropertyMultilink( [  ], (  ) => {\n    \n        const backgroundColorString = setBackgroundWhiteBackgroundFunction(  );\n        \n        // wait to add the background until all dependencies are available (only add this once)\n        if ( scratchpad.setBackgroundWhiteBackgroundRectangle.parents.length === 0 ) {\n          sharedData.scene.addChild( setBackgroundWhiteBackgroundRectangle );\n          setBackgroundWhiteBackgroundRectangle.moveToBack();\n        }\n        \n        // the function may not be implemented\n        if ( backgroundColorString ) {\n          setBackgroundWhiteBackgroundRectangle.fill = backgroundColorString;\n        }\n        \n        setBackgroundWhiteBackgroundRectangle.setRect( 0, 0, sharedData.displaySize.width, sharedData.displaySize.height );\n      }, {\n        otherProperties: [ phet.paperLand.displaySizeProperty ],\n        otherReferences: [  ]\n      } );\n    \n// Create a checkbox and add it to the scene.\nconst fontSizeA = phet.paperLand.getModelComponent(`fontSize`);\nconst checkboxLabelA = phet.paperLand.getModelComponent(`checkboxNameResponse`);\nconst isEnabledA = phet.paperLand.getModelComponent(`isEnabled`);\n\nconst checkboxLabelText = new phet.scenery.Text(checkboxLabelA.value, {\n    font: new phet.sceneryPhet.PhetFont( fontSizeA.value )\n});\n\nconst checkbox = new phet.sun.Checkbox(isEnabledA, checkboxLabelText);\nsharedData.scene.addChild(checkbox);\nscratchpad.checkbox = checkbox;\ncheckbox.moveToFront();\n  };\n\n  const onProgramRemoved = ( paperNumber, scratchpad, sharedData ) => {\n    \n      // Remove the component from the model\n      phet.paperLand.removeModelComponent( 'isEnabled' );\n    \n\n      // Remove the component from the model\n      phet.paperLand.removeModelComponent( 'isFocused' );\n    \n\n      // Remove the component from the model\n      phet.paperLand.removeModelComponent( 'visualPosition' );\n    \n\n      // Remove the component from the model\n      phet.paperLand.removeModelComponent( 'fontSize' );\n    \n\n      // Remove the component from the model\n      phet.paperLand.removeModelComponent( 'checkboxNameResponse' );\n    \n\n      // Remove the component from the model\n      phet.paperLand.removeModelComponent( 'checkedResponse' );\n    \n\n      // Remove the component from the model\n      phet.paperLand.removeModelComponent( 'uncheckedResponse' );\n    \n\n      // Remove the component from the model\n      phet.paperLand.removeModelComponent( 'checkboxHintResponse' );\n    \n\n      phet.tambo.soundManager.removeSoundGenerator( scratchpad.playCheckboxCheckedSoundClip );\n      delete scratchpad.playCheckboxCheckedSoundClip;\n      \n      scratchpad.playCheckboxCheckedWrappedAudioBuffer.audioBufferProperty.unlink( scratchpad.playCheckboxCheckedWrappedAudioBufferListener );\n      delete scratchpad.playCheckboxCheckedWrappedAudioBufferListener;\n      \n      phet.paperLand.removeModelPropertyMultilink( [ 'isEnabled' ], scratchpad.playCheckboxCheckedSoundMultilinkId, {\n        otherReferences: [  ]\n       } );\n      delete scratchpad.playCheckboxCheckedSoundMultilinkId;\n    \n\n      phet.tambo.soundManager.removeSoundGenerator( scratchpad.playCheckboxUncheckedSoundClip );\n      delete scratchpad.playCheckboxUncheckedSoundClip;\n      \n      scratchpad.playCheckboxUncheckedWrappedAudioBuffer.audioBufferProperty.unlink( scratchpad.playCheckboxUncheckedWrappedAudioBufferListener );\n      delete scratchpad.playCheckboxUncheckedWrappedAudioBufferListener;\n      \n      phet.paperLand.removeModelPropertyMultilink( [ 'isEnabled' ], scratchpad.playCheckboxUncheckedSoundMultilinkId, {\n        otherReferences: [  ]\n       } );\n      delete scratchpad.playCheckboxUncheckedSoundMultilinkId;\n    \n\n      // Remove the description multilink\n      phet.paperLand.removeModelPropertyMultilink( [ 'isEnabled', 'checkboxNameResponse', 'checkedResponse', 'uncheckedResponse' ], scratchpad.voiceResponsesForChangesDescriptionMultilinkId, {\n        otherReferences: [  ]\n       } );\n      delete scratchpad.voiceResponsesForChangesDescriptionMultilinkId;\n      \n      // Remove the utterance\n      delete scratchpad.voiceResponsesForChangesDescriptionUtterance;\n    \n\n      // Remove the description multilink\n      phet.paperLand.removeModelPropertyMultilink( [ 'isFocused', 'checkboxHintResponse' ], scratchpad.voiceResponsesForFocusDescriptionMultilinkId, {\n        otherReferences: [ 'checkboxNameResponse' ]\n       } );\n      delete scratchpad.voiceResponsesForFocusDescriptionMultilinkId;\n      \n      // Remove the utterance\n      delete scratchpad.voiceResponsesForFocusDescriptionUtterance;\n    \n\n      // Remove the background rectangle from the view.\n      sharedData.scene.removeChild( scratchpad.setBackgroundWhiteBackgroundRectangle );\n      delete scratchpad.setBackgroundWhiteBackgroundRectangle;\n      \n      // Remove the multilink if there were any dependencies\n      if ( scratchpad.setBackgroundWhiteBackgroundMultilinkId ) {\n        phet.paperLand.removeModelPropertyMultilink( [  ], scratchpad.setBackgroundWhiteBackgroundMultilinkId, {\n          otherReferences: [  ]\n        } );\n        delete scratchpad.setBackgroundWhiteBackgroundMultilinkId;\n      }\n    \nif (scratchpad.checkbox) {\n    sharedData.scene.removeChild(scratchpad.checkbox);\n    scratchpad.checkbox = null;\n}\nelse {\n    alert('Error: Checkbox node not found in scratchpad data.');\n}\n  };\n\n  const onProgramChangedPosition = ( paperNumber, points, scratchpad, sharedData ) => {\n    \n    const modelProperty0 = phet.paperLand.getModelComponent( 'visualPosition' );\n    if ( modelProperty0 ) {\n      modelProperty0.value = phet.paperLand.utils.getProgramCenter( points );\n    }\n\n    const modelProperty1 = phet.paperLand.getModelComponent( 'isEnabled' );\n    if ( modelProperty1 ) {\n      modelProperty1.value = phet.paperLand.utils.getNormalizedProgramRotation( points ) > 0.25 && phet.paperLand.utils.getNormalizedProgramRotation( points ) < 0.75;\n    }\nconst visualPosition = phet.paperLand.getModelComponent(`visualPosition`);\nif (scratchpad.checkbox) {\n\n    // Center the image based on the position of the paper.\n    const centerPositionDisplayUnits = phet.paperLand.utils.paperToBoardCoordinates(visualPosition.value, sharedData.displaySize.width, sharedData.displaySize.height);\n    scratchpad.checkbox.centerX = centerPositionDisplayUnits.x;\n    scratchpad.checkbox.centerY = centerPositionDisplayUnits.y;\n}\n  };\n  \n  const onProgramMarkersAdded = ( paperNumber, points, scratchpad, sharedData, markers ) => {\n    \n    const modelProperty5 = phet.paperLand.getModelComponent( 'isFocused' );\n    if ( modelProperty5 ) {\n      modelProperty5.value = markers.length > 0;\n    }\n  };\n  \n  const onProgramMarkersRemoved = ( paperNumber, points, scratchpad, sharedData, markers ) => {\n    \n    const modelProperty9 = phet.paperLand.getModelComponent( 'isFocused' );\n    if ( modelProperty9 ) {\n      modelProperty9.value = markers.length > 0;\n    }\n  };\n  \n  const onProgramMarkersChangedPosition = ( paperNumber, points, scratchpad, sharedData, markers ) => {\n    \n  };\n  \n  const onProgramAdjacent = ( paperNumber, otherPaperNumber, direction, scratchpad, sharedData ) => {\n    \n  };\n  \n  const onProgramSeparated = ( paperNumber, otherPaperNumber, direction, scratchpad, sharedData ) => {\n    \n  };\n\n  await paper.set( 'data', {\n    paperPlaygroundData: {\n      updateTime: Date.now(),\n      eventHandlers: {\n        onProgramAdded: onProgramAdded.toString(),\n        onProgramRemoved: onProgramRemoved.toString(),\n        onProgramChangedPosition: onProgramChangedPosition.toString(),\n        onProgramMarkersAdded: onProgramMarkersAdded.toString(),\n        onProgramMarkersRemoved: onProgramMarkersRemoved.toString(),\n        onProgramMarkersChangedPosition: onProgramMarkersChangedPosition.toString(),\n        onProgramAdjacent: onProgramAdjacent.toString(),\n        onProgramSeparated: onProgramSeparated.toString(),\n      },\n      customWhiskerLengths: {\n        top: 0.2,\n        right: 0.2,\n        bottom: 0.2,\n        left: 0.2\n      }\n    }\n  } );\n  \n  // PROJECTOR CODE //\n  // Get a canvas object for this paper to draw something to the Projector.\n  const canvas = await paper.get('canvas');\n\n  // Draw the name of the program to the projector\n  const ctx = canvas.getContext('2d');\n  ctx.font = '20px sans-serif';\n  ctx.textAlign = 'center';\n  ctx.fillStyle = 'rgb(255,0,0)';\n  ctx.fillText('', canvas.width / 2, canvas.height / 2 - 10);\n  ctx.fillStyle = 'rgb(0,255,0)';\n  ctx.font = '10px sans-serif';\n  ctx.fillText('Multimodal Checkbox', canvas.width / 2, canvas.height / 2 + 20);\n})();\n",
  "printed": false,
  "editorInfo": {},
  "currentCodeUrl": "program.ts-creator-tests.899.js",
  "currentCodeHash": "",
  "debugUrl": "/api/spaces/ts-creator-tests/programs/899/debugInfo",
  "claimUrl": "/api/spaces/ts-creator-tests/programs/899/claim",
  "codeHasChanged": false,
  "debugInfo": "{\"logs\":[]}"
}